'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

// DEFLATE is a complex format; to read this code, you should probably check the RFC first:
// https://tools.ietf.org/html/rfc1951
// You may also wish to take a look at the guide I made about this program:
// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad
// Some of the following code is similar to that of UZIP.js:
// https://github.com/photopea/UZIP.js
// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.
// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint
// is better for memory in most engines (I *think*).
var ch2 = {};
var wk = (function (c, id, msg, transfer, cb) {
    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([
        c + ';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'
    ], { type: 'text/javascript' }))));
    w.onmessage = function (e) {
        var d = e.data, ed = d.$e$;
        if (ed) {
            var err = new Error(ed[0]);
            err['code'] = ed[1];
            err.stack = ed[2];
            cb(err, null);
        }
        else
            cb(null, d);
    };
    w.postMessage(msg, transfer);
    return w;
});

// aliases for shorter compressed code (most minifers don't do this)
var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
// fixed length extra bits
var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);
// fixed distance extra bits
var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);
// code length index map
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
// get base, reverse index map from extra bits
var freb = function (eb, start) {
    var b = new u16(31);
    for (var i = 0; i < 31; ++i) {
        b[i] = start += 1 << eb[i - 1];
    }
    // numbers here are at max 18 bits
    var r = new i32(b[30]);
    for (var i = 1; i < 30; ++i) {
        for (var j = b[i]; j < b[i + 1]; ++j) {
            r[j] = ((j - b[i]) << 5) | i;
        }
    }
    return { b: b, r: r };
};
var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
// we can ignore the fact that the other numbers are wrong; they never happen anyway
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), revfd = _b.r;
// map of value to reverse (assuming 16 bits)
var rev = new u16(32768);
for (var i = 0; i < 32768; ++i) {
    // reverse table algorithm from SO
    var x$1 = ((i & 0xAAAA) >> 1) | ((i & 0x5555) << 1);
    x$1 = ((x$1 & 0xCCCC) >> 2) | ((x$1 & 0x3333) << 2);
    x$1 = ((x$1 & 0xF0F0) >> 4) | ((x$1 & 0x0F0F) << 4);
    rev[i] = (((x$1 & 0xFF00) >> 8) | ((x$1 & 0x00FF) << 8)) >> 1;
}
// create huffman tree from u8 "map": index -> code length for code index
// mb (max bits) must be at most 15
// TODO: optimize/split up?
var hMap = (function (cd, mb, r) {
    var s = cd.length;
    // index
    var i = 0;
    // u16 "map": index -> # of codes with bit length = index
    var l = new u16(mb);
    // length of cd must be 288 (total # of codes)
    for (; i < s; ++i) {
        if (cd[i])
            ++l[cd[i] - 1];
    }
    // u16 "map": index -> minimum code for bit length = index
    var le = new u16(mb);
    for (i = 1; i < mb; ++i) {
        le[i] = (le[i - 1] + l[i - 1]) << 1;
    }
    var co;
    if (r) {
        // u16 "map": index -> number of actual bits, symbol for code
        co = new u16(1 << mb);
        // bits to remove for reverser
        var rvb = 15 - mb;
        for (i = 0; i < s; ++i) {
            // ignore 0 lengths
            if (cd[i]) {
                // num encoding both symbol and bits read
                var sv = (i << 4) | cd[i];
                // free bits
                var r_1 = mb - cd[i];
                // start value
                var v = le[cd[i] - 1]++ << r_1;
                // m is end value
                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {
                    // every 16 bit value starting with the code yields the same result
                    co[rev[v] >> rvb] = sv;
                }
            }
        }
    }
    else {
        co = new u16(s);
        for (i = 0; i < s; ++i) {
            if (cd[i]) {
                co[i] = rev[le[cd[i] - 1]++] >> (15 - cd[i]);
            }
        }
    }
    return co;
});
// fixed length tree
var flt = new u8(288);
for (var i = 0; i < 144; ++i)
    flt[i] = 8;
for (var i = 144; i < 256; ++i)
    flt[i] = 9;
for (var i = 256; i < 280; ++i)
    flt[i] = 7;
for (var i = 280; i < 288; ++i)
    flt[i] = 8;
// fixed distance tree
var fdt = new u8(32);
for (var i = 0; i < 32; ++i)
    fdt[i] = 5;
// fixed length map
var flm = /*#__PURE__*/ hMap(flt, 9, 0);
// fixed distance map
var fdm = /*#__PURE__*/ hMap(fdt, 5, 0);
// get end of byte
var shft = function (p) { return ((p + 7) / 8) | 0; };
// typed array slice - allows garbage collector to free original reference,
// while being more compatible than .slice
var slc = function (v, s, e) {
    if (s == null || s < 0)
        s = 0;
    if (e == null || e > v.length)
        e = v.length;
    // can't use .constructor in case user-supplied
    return new u8(v.subarray(s, e));
};
// error codes
var ec = [
    'unexpected EOF',
    'invalid block type',
    'invalid length/literal',
    'invalid distance',
    'stream finished',
    'no stream handler',
    ,
    'no callback',
    'invalid UTF-8 data',
    'extra field too long',
    'date not in range 1980-2099',
    'filename too long',
    'stream finishing',
    'invalid zip data'
    // determined by unknown compression method
];
var err = function (ind, msg, nt) {
    var e = new Error(msg || ec[ind]);
    e.code = ind;
    if (Error.captureStackTrace)
        Error.captureStackTrace(e, err);
    if (!nt)
        throw e;
    return e;
};
// starting at p, write the minimum number of bits that can hold v to d
var wbits = function (d, p, v) {
    v <<= p & 7;
    var o = (p / 8) | 0;
    d[o] |= v;
    d[o + 1] |= v >> 8;
};
// starting at p, write the minimum number of bits (>8) that can hold v to d
var wbits16 = function (d, p, v) {
    v <<= p & 7;
    var o = (p / 8) | 0;
    d[o] |= v;
    d[o + 1] |= v >> 8;
    d[o + 2] |= v >> 16;
};
// creates code lengths from a frequency table
var hTree = function (d, mb) {
    // Need extra info to make a tree
    var t = [];
    for (var i = 0; i < d.length; ++i) {
        if (d[i])
            t.push({ s: i, f: d[i] });
    }
    var s = t.length;
    var t2 = t.slice();
    if (!s)
        return { t: et, l: 0 };
    if (s == 1) {
        var v = new u8(t[0].s + 1);
        v[t[0].s] = 1;
        return { t: v, l: 1 };
    }
    t.sort(function (a, b) { return a.f - b.f; });
    // after i2 reaches last ind, will be stopped
    // freq must be greater than largest possible number of symbols
    t.push({ s: -1, f: 25001 });
    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;
    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };
    // efficient algorithm from UZIP.js
    // i0 is lookbehind, i2 is lookahead - after processing two low-freq
    // symbols that combined have high freq, will start processing i2 (high-freq,
    // non-composite) symbols instead
    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/
    while (i1 != s - 1) {
        l = t[t[i0].f < t[i2].f ? i0++ : i2++];
        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };
    }
    var maxSym = t2[0].s;
    for (var i = 1; i < s; ++i) {
        if (t2[i].s > maxSym)
            maxSym = t2[i].s;
    }
    // code lengths
    var tr = new u16(maxSym + 1);
    // max bits in tree
    var mbt = ln(t[i1 - 1], tr, 0);
    if (mbt > mb) {
        // more algorithms from UZIP.js
        // TODO: find out how this code works (debt)
        //  ind    debt
        var i = 0, dt = 0;
        //    left            cost
        var lft = mbt - mb, cst = 1 << lft;
        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });
        for (; i < s; ++i) {
            var i2_1 = t2[i].s;
            if (tr[i2_1] > mb) {
                dt += cst - (1 << (mbt - tr[i2_1]));
                tr[i2_1] = mb;
            }
            else
                break;
        }
        dt >>= lft;
        while (dt > 0) {
            var i2_2 = t2[i].s;
            if (tr[i2_2] < mb)
                dt -= 1 << (mb - tr[i2_2]++ - 1);
            else
                ++i;
        }
        for (; i >= 0 && dt; --i) {
            var i2_3 = t2[i].s;
            if (tr[i2_3] == mb) {
                --tr[i2_3];
                ++dt;
            }
        }
        mbt = mb;
    }
    return { t: new u8(tr), l: mbt };
};
// get the max length and assign length codes
var ln = function (n, l, d) {
    return n.s == -1
        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))
        : (l[n.s] = d);
};
// length codes generation
var lc = function (c) {
    var s = c.length;
    // Note that the semicolon was intentional
    while (s && !c[--s])
        ;
    var cl = new u16(++s);
    //  ind      num         streak
    var cli = 0, cln = c[0], cls = 1;
    var w = function (v) { cl[cli++] = v; };
    for (var i = 1; i <= s; ++i) {
        if (c[i] == cln && i != s)
            ++cls;
        else {
            if (!cln && cls > 2) {
                for (; cls > 138; cls -= 138)
                    w(32754);
                if (cls > 2) {
                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);
                    cls = 0;
                }
            }
            else if (cls > 3) {
                w(cln), --cls;
                for (; cls > 6; cls -= 6)
                    w(8304);
                if (cls > 2)
                    w(((cls - 3) << 5) | 8208), cls = 0;
            }
            while (cls--)
                w(cln);
            cls = 1;
            cln = c[i];
        }
    }
    return { c: cl.subarray(0, cli), n: s };
};
// calculate the length of output from tree, code lengths
var clen = function (cf, cl) {
    var l = 0;
    for (var i = 0; i < cl.length; ++i)
        l += cf[i] * cl[i];
    return l;
};
// writes a fixed block
// returns the new bit pos
var wfblk = function (out, pos, dat) {
    // no need to write 00 as type: TypedArray defaults to 0
    var s = dat.length;
    var o = shft(pos + 2);
    out[o] = s & 255;
    out[o + 1] = s >> 8;
    out[o + 2] = out[o] ^ 255;
    out[o + 3] = out[o + 1] ^ 255;
    for (var i = 0; i < s; ++i)
        out[o + i + 4] = dat[i];
    return (o + 4 + s) * 8;
};
// writes a block
var wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
    wbits(out, p++, final);
    ++lf[256];
    var _a = hTree(lf, 15), dlt = _a.t, mlb = _a.l;
    var _b = hTree(df, 15), ddt = _b.t, mdb = _b.l;
    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
    var lcfreq = new u16(19);
    for (var i = 0; i < lclt.length; ++i)
        ++lcfreq[lclt[i] & 31];
    for (var i = 0; i < lcdt.length; ++i)
        ++lcfreq[lcdt[i] & 31];
    var _e = hTree(lcfreq, 7), lct = _e.t, mlcb = _e.l;
    var nlcc = 19;
    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
        ;
    var flen = (bl + 5) << 3;
    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
    if (bs >= 0 && flen <= ftlen && flen <= dtlen)
        return wfblk(out, p, dat.subarray(bs, bs + bl));
    var lm, ll, dm, dl;
    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
    if (dtlen < ftlen) {
        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
        var llm = hMap(lct, mlcb, 0);
        wbits(out, p, nlc - 257);
        wbits(out, p + 5, ndc - 1);
        wbits(out, p + 10, nlcc - 4);
        p += 14;
        for (var i = 0; i < nlcc; ++i)
            wbits(out, p + 3 * i, lct[clim[i]]);
        p += 3 * nlcc;
        var lcts = [lclt, lcdt];
        for (var it = 0; it < 2; ++it) {
            var clct = lcts[it];
            for (var i = 0; i < clct.length; ++i) {
                var len = clct[i] & 31;
                wbits(out, p, llm[len]), p += lct[len];
                if (len > 15)
                    wbits(out, p, (clct[i] >> 5) & 127), p += clct[i] >> 12;
            }
        }
    }
    else {
        lm = flm, ll = flt, dm = fdm, dl = fdt;
    }
    for (var i = 0; i < li; ++i) {
        var sym = syms[i];
        if (sym > 255) {
            var len = (sym >> 18) & 31;
            wbits16(out, p, lm[len + 257]), p += ll[len + 257];
            if (len > 7)
                wbits(out, p, (sym >> 23) & 31), p += fleb[len];
            var dst = sym & 31;
            wbits16(out, p, dm[dst]), p += dl[dst];
            if (dst > 3)
                wbits16(out, p, (sym >> 5) & 8191), p += fdeb[dst];
        }
        else {
            wbits16(out, p, lm[sym]), p += ll[sym];
        }
    }
    wbits16(out, p, lm[256]);
    return p + ll[256];
};
// deflate options (nice << 13) | chain
var deo = /*#__PURE__*/ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
// empty
var et = /*#__PURE__*/ new u8(0);
// compresses data into a raw DEFLATE buffer
var dflt = function (dat, lvl, plvl, pre, post, st) {
    var s = st.z || dat.length;
    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);
    // writing to this writes to the output buffer
    var w = o.subarray(pre, o.length - post);
    var lst = st.l;
    var pos = (st.r || 0) & 7;
    if (lvl) {
        if (pos)
            w[0] = st.r >> 3;
        var opt = deo[lvl - 1];
        var n = opt >> 13, c = opt & 8191;
        var msk_1 = (1 << plvl) - 1;
        //    prev 2-byte val map    curr 2-byte val map
        var prev = st.p || new u16(32768), head = st.h || new u16(msk_1 + 1);
        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };
        // 24576 is an arbitrary number of maximum symbols per block
        // 424 buffer for last block
        var syms = new i32(25000);
        // length/literal freq   distance freq
        var lf = new u16(288), df = new u16(32);
        //  l/lcnt  exbits  index          l/lind  waitdx          blkpos
        var lc_1 = 0, eb = 0, i = st.i || 0, li = 0, wi = st.w || 0, bs = 0;
        for (; i + 2 < s; ++i) {
            // hash value
            var hv = hsh(i);
            // index mod 32768    previous index mod
            var imod = i & 32767, pimod = head[hv];
            prev[imod] = pimod;
            head[hv] = imod;
            // We always should modify head and prev, but only add symbols if
            // this data is not yet processed ("wait" for wait index)
            if (wi <= i) {
                // bytes remaining
                var rem = s - i;
                if ((lc_1 > 7000 || li > 24576) && (rem > 423 || !lst)) {
                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
                    li = lc_1 = eb = 0, bs = i;
                    for (var j = 0; j < 286; ++j)
                        lf[j] = 0;
                    for (var j = 0; j < 30; ++j)
                        df[j] = 0;
                }
                //  len    dist   chain
                var l = 2, d = 0, ch_1 = c, dif = imod - pimod & 32767;
                if (rem > 2 && hv == hsh(i - dif)) {
                    var maxn = Math.min(n, rem) - 1;
                    var maxd = Math.min(32767, i);
                    // max possible length
                    // not capped at dif because decompressors implement "rolling" index population
                    var ml = Math.min(258, rem);
                    while (dif <= maxd && --ch_1 && imod != pimod) {
                        if (dat[i + l] == dat[i + l - dif]) {
                            var nl = 0;
                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)
                                ;
                            if (nl > l) {
                                l = nl, d = dif;
                                // break out early when we reach "nice" (we are satisfied enough)
                                if (nl > maxn)
                                    break;
                                // now, find the rarest 2-byte sequence within this
                                // length of literals and search for that instead.
                                // Much faster than just using the start
                                var mmd = Math.min(dif, nl - 2);
                                var md = 0;
                                for (var j = 0; j < mmd; ++j) {
                                    var ti = i - dif + j & 32767;
                                    var pti = prev[ti];
                                    var cd = ti - pti & 32767;
                                    if (cd > md)
                                        md = cd, pimod = ti;
                                }
                            }
                        }
                        // check the previous match
                        imod = pimod, pimod = prev[imod];
                        dif += imod - pimod & 32767;
                    }
                }
                // d will be nonzero only when a match was found
                if (d) {
                    // store both dist and len data in one int32
                    // Make sure this is recognized as a len/dist with 28th bit (2^28)
                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];
                    var lin = revfl[l] & 31, din = revfd[d] & 31;
                    eb += fleb[lin] + fdeb[din];
                    ++lf[257 + lin];
                    ++df[din];
                    wi = i + l;
                    ++lc_1;
                }
                else {
                    syms[li++] = dat[i];
                    ++lf[dat[i]];
                }
            }
        }
        for (i = Math.max(i, wi); i < s; ++i) {
            syms[li++] = dat[i];
            ++lf[dat[i]];
        }
        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);
        if (!lst) {
            st.r = (pos & 7) | w[(pos / 8) | 0] << 3;
            // shft(pos) now 1 less if pos & 7 != 0
            pos -= 7;
            st.h = head, st.p = prev, st.i = i, st.w = wi;
        }
    }
    else {
        for (var i = st.w || 0; i < s + lst; i += 65535) {
            // end
            var e = i + 65535;
            if (e >= s) {
                // write final block
                w[(pos / 8) | 0] = lst;
                e = s;
            }
            pos = wfblk(w, pos + 1, dat.subarray(i, e));
        }
        st.i = s;
    }
    return slc(o, 0, pre + shft(pos) + post);
};
// CRC32 table
var crct = /*#__PURE__*/ (function () {
    var t = new Int32Array(256);
    for (var i = 0; i < 256; ++i) {
        var c = i, k = 9;
        while (--k)
            c = ((c & 1) && -306674912) ^ (c >>> 1);
        t[i] = c;
    }
    return t;
})();
// CRC32
var crc = function () {
    var c = -1;
    return {
        p: function (d) {
            // closures have awful performance
            var cr = c;
            for (var i = 0; i < d.length; ++i)
                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);
            c = cr;
        },
        d: function () { return ~c; }
    };
};
// deflate with opts
var dopt = function (dat, opt, pre, post, st) {
    if (!st) {
        st = { l: 1 };
        if (opt.dictionary) {
            var dict = opt.dictionary.subarray(-32768);
            var newDat = new u8(dict.length + dat.length);
            newDat.set(dict);
            newDat.set(dat, dict.length);
            dat = newDat;
            st.w = dict.length;
        }
    }
    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? (st.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20) : (12 + opt.mem), pre, post, st);
};
// Walmart object spread
var mrg = function (a, b) {
    var o = {};
    for (var k in a)
        o[k] = a[k];
    for (var k in b)
        o[k] = b[k];
    return o;
};
// worker clone
// This is possibly the craziest part of the entire codebase, despite how simple it may seem.
// The only parameter to this function is a closure that returns an array of variables outside of the function scope.
// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.
// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).
// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.
// This took me three weeks to figure out how to do.
var wcln = function (fn, fnStr, td) {
    var dt = fn();
    var st = fn.toString();
    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/\s+/g, '').split(',');
    for (var i = 0; i < dt.length; ++i) {
        var v = dt[i], k = ks[i];
        if (typeof v == 'function') {
            fnStr += ';' + k + '=';
            var st_1 = v.toString();
            if (v.prototype) {
                // for global objects
                if (st_1.indexOf('[native code]') != -1) {
                    var spInd = st_1.indexOf(' ', 8) + 1;
                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));
                }
                else {
                    fnStr += st_1;
                    for (var t in v.prototype)
                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();
                }
            }
            else
                fnStr += st_1;
        }
        else
            td[k] = v;
    }
    return fnStr;
};
var ch = [];
// clone bufs
var cbfs = function (v) {
    var tl = [];
    for (var k in v) {
        if (v[k].buffer) {
            tl.push((v[k] = new v[k].constructor(v[k])).buffer);
        }
    }
    return tl;
};
// use a worker to execute code
var wrkr = function (fns, init, id, cb) {
    if (!ch[id]) {
        var fnStr = '', td_1 = {}, m = fns.length - 1;
        for (var i = 0; i < m; ++i)
            fnStr = wcln(fns[i], fnStr, td_1);
        ch[id] = { c: wcln(fns[m], fnStr, td_1), e: td_1 };
    }
    var td = mrg({}, ch[id].e);
    return wk(ch[id].c + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);
};
var bDflt = function () { return [u8, u16, i32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };
// gzip extra
var gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };
// post buf
var pbf = function (msg) { return postMessage(msg, [msg.buffer]); };
// async helper
var cbify = function (dat, opts, fns, init, id, cb) {
    var w = wrkr(fns, init, id, function (err, dat) {
        w.terminate();
        cb(err, dat);
    });
    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);
    return function () { w.terminate(); };
};
// write bytes
var wbytes = function (d, b, v) {
    for (; v; ++b)
        d[b] = v, v >>>= 8;
};
// gzip header
var gzh = function (c, o) {
    var fn = o.filename;
    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix
    if (o.mtime != 0)
        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));
    if (fn) {
        c[3] = 8;
        for (var i = 0; i <= fn.length; ++i)
            c[i + 10] = fn.charCodeAt(i);
    }
};
// gzip header length
var gzhl = function (o) { return 10 + (o.filename ? o.filename.length + 1 : 0); };
/**
 * Compresses data with DEFLATE without any wrapper
 * @param data The data to compress
 * @param opts The compression options
 * @returns The deflated version of the data
 */
function deflateSync(data, opts) {
    return dopt(data, opts || {}, 0, 0);
}
function gzip(data, opts, cb) {
    if (!cb)
        cb = opts, opts = {};
    if (typeof cb != 'function')
        err(7);
    return cbify(data, opts, [
        bDflt,
        gze,
        function () { return [gzipSync]; }
    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);
}
/**
 * Compresses data with GZIP
 * @param data The data to compress
 * @param opts The compression options
 * @returns The gzipped version of the data
 */
function gzipSync(data, opts) {
    if (!opts)
        opts = {};
    var c = crc(), l = data.length;
    c.p(data);
    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;
    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
}
// text decoder
var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();
// text decoder stream
var tds = 0;
try {
    td.decode(et, { stream: true });
    tds = 1;
}
catch (e) { }

class StringDictionary {
    constructor() {
        this.lastTs = 0;
        this.lastSuffix = 1;
        /** backwards dictionary of
         * [repeated str:key]
         * */
        this.backDict = {};
        this.getKey = (str) => {
            let isNew = false;
            // avoiding potential native object properties
            const safeKey = `__${str}`;
            if (!this.backDict[safeKey]) {
                isNew = true;
                // shaving the first 2 digits of the timestamp (since they are irrelevant for next millennia)
                const shavedTs = Date.now() % 10 ** (13 - 2);
                let id = shavedTs;
                if (id === this.lastTs) {
                    id = id * 10000 + this.lastSuffix;
                    this.lastSuffix += 1;
                }
                else {
                    this.lastSuffix = 1;
                }
                this.backDict[safeKey] = id;
                this.lastTs = shavedTs;
            }
            return [this.backDict[safeKey], isNew];
        };
    }
}
class AttributeSender {
    constructor(options) {
        this.sendSetAttribute = (id, name, value) => {
            if (this.isDictDisabled) {
                const msg = [12 /* Type.SetNodeAttribute */, id, name, value];
                return this.app.send(msg);
            }
            else {
                const message = [
                    35 /* Type.SetNodeAttributeDictGlobal */,
                    id,
                    this.applyDict(name),
                    this.applyDict(value),
                ];
                return this.app.send(message);
            }
        };
        this.app = options.app;
        this.isDictDisabled = options.isDictDisabled;
        this.dict = new StringDictionary();
    }
    applyDict(str) {
        const [key, isNew] = this.dict.getKey(str);
        if (isNew) {
            this.app.send([34 /* Type.StringDictGlobal */, key, str]);
        }
        return key;
    }
    clear() {
        this.dict = new StringDictionary();
    }
}

class ConditionsManager {
    constructor(app, startParams) {
        this.app = app;
        this.startParams = startParams;
        this.conditions = [];
        this.hasStarted = false;
        this.createConditionFromFilter = (filter) => {
            const resultCondition = mapCondition(filter);
            if (resultCondition.type) {
                return resultCondition;
            }
        };
        this.durationInt = null;
    }
    setConditions(conditions) {
        this.conditions = conditions;
    }
    async fetchConditions(projectId, token) {
        try {
            const r = await fetch(`${this.app.options.ingestPoint}/v1/web/conditions/${projectId}`, {
                method: 'GET',
                headers: {
                    Authorization: `Bearer ${token}`,
                },
            });
            const { conditions } = (await r.json());
            const mappedConditions = [];
            conditions.forEach((c) => {
                const filters = c.filters;
                filters.forEach((filter) => {
                    let cond;
                    if (filter.type === 'fetch') {
                        cond = {
                            type: 'network_request',
                            subConditions: [],
                            name: c.name,
                        };
                        filter.filters.forEach((f) => {
                            const subCond = this.createConditionFromFilter(f);
                            if (subCond) {
                                ;
                                cond.subConditions.push(subCond);
                            }
                        });
                    }
                    else {
                        cond = this.createConditionFromFilter(filter);
                    }
                    if (cond) {
                        if (cond.type === 'session_duration') {
                            this.processDuration(cond.value[0], c.name);
                        }
                        mappedConditions.push({ ...cond, name: c.name });
                    }
                });
            });
            this.conditions = mappedConditions;
        }
        catch (e) {
            this.app.debug.error('Critical: cannot fetch start conditions');
        }
    }
    trigger(conditionName) {
        if (this.hasStarted)
            return;
        try {
            this.hasStarted = true;
            void this.app.start(this.startParams, undefined, conditionName);
        }
        catch (e) {
            this.app.debug.error(e);
        }
    }
    processMessage(message) {
        if (this.hasStarted)
            return;
        switch (message[0]) {
            case 78 /* Type.JSException */:
                this.jsExceptionEvent(message);
                break;
            case 27 /* Type.CustomEvent */:
                this.customEvent(message);
                break;
            case 68 /* Type.MouseClick */:
                this.clickEvent(message);
                break;
            case 122 /* Type.SetPageLocation */:
                this.pageLocationEvent(message);
                break;
            case 83 /* Type.NetworkRequest */:
                this.networkRequest(message);
                break;
        }
    }
    processFlags(flag) {
        const flagConds = this.conditions.filter((c) => c.type === 'feature_flag');
        if (flagConds.length) {
            flagConds.forEach((flagCond) => {
                const operator = operators[flagCond.operator];
                if (operator && flag.find((f) => operator(f.key, flagCond.value))) {
                    this.trigger(flagCond.name);
                }
            });
        }
    }
    processDuration(durationMs, condName) {
        this.durationInt = setInterval(() => {
            const sessionLength = performance.now();
            if (sessionLength > durationMs) {
                this.trigger(condName);
            }
        }, 1000);
        this.app.attachStopCallback(() => {
            if (this.durationInt) {
                clearInterval(this.durationInt);
            }
        });
    }
    networkRequest(message) {
        // method - 2, url - 3, status - 6, duration - 8
        const reqConds = this.conditions.filter((c) => c.type === 'network_request');
        if (!reqConds.length)
            return;
        reqConds.forEach((reqCond) => {
            const validSubConditions = reqCond.subConditions.filter((c) => c.operator !== 'isAny');
            if (validSubConditions.length) {
                const allPass = validSubConditions.every((subCond) => {
                    let value;
                    switch (subCond.key) {
                        case 'url':
                            value = message[3];
                            break;
                        case 'status':
                            value = message[6];
                            break;
                        case 'method':
                            value = message[2];
                            break;
                        case 'duration':
                            value = message[8];
                            break;
                    }
                    const operator = operators[subCond.operator];
                    // @ts-ignore
                    if (operator && operator(value, subCond.value)) {
                        return true;
                    }
                });
                if (allPass) {
                    this.trigger(reqCond.name);
                }
            }
            else if (validSubConditions.length === 0 && reqCond.subConditions.length) {
                this.trigger(reqCond.name);
            }
        });
    }
    customEvent(message) {
        // name - 1, payload - 2
        const evConds = this.conditions.filter((c) => c.type === 'custom_event');
        if (evConds.length) {
            evConds.forEach((evCond) => {
                const operator = operators[evCond.operator];
                if (operator &&
                    (operator(message[1], evCond.value) || operator(message[2], evCond.value))) {
                    this.trigger(evCond.name);
                }
            });
        }
    }
    clickEvent(message) {
        // label - 3, selector - 4
        const clickCond = this.conditions.filter((c) => c.type === 'click');
        if (clickCond.length) {
            clickCond.forEach((click) => {
                const operator = operators[click.operator];
                if (operator && (operator(message[3], click.value) || operator(message[4], click.value))) {
                    this.trigger(click.name);
                }
            });
        }
    }
    pageLocationEvent(message) {
        // url - 1
        const urlConds = this.conditions.filter((c) => c.type === 'visited_url');
        if (urlConds) {
            urlConds.forEach((urlCond) => {
                const operator = operators[urlCond.operator];
                if (operator && operator(message[1], urlCond.value)) {
                    this.trigger(urlCond.name);
                }
            });
        }
    }
    jsExceptionEvent(message) {
        // name - 1, message - 2, payload - 3
        const testedValues = [message[1], message[2], message[3]];
        const exceptionConds = this.conditions.filter((c) => c.type === 'exception');
        if (exceptionConds) {
            exceptionConds.forEach((exceptionCond) => {
                const operator = operators[exceptionCond.operator];
                if (operator && testedValues.some((val) => operator(val, exceptionCond.value))) {
                    this.trigger(exceptionCond.name);
                }
            });
        }
    }
}
const operators = {
    is: (val, target) => target.some((t) => val.includes(t)),
    isAny: () => true,
    isNot: (val, target) => !target.some((t) => val.includes(t)),
    contains: (val, target) => target.some((t) => val.includes(t)),
    notContains: (val, target) => !target.some((t) => val.includes(t)),
    startsWith: (val, target) => target.some((t) => val.startsWith(t)),
    endsWith: (val, target) => target.some((t) => val.endsWith(t)),
    greaterThan: (val, target) => val > target,
    greaterOrEqual: (val, target) => val >= target,
    lessOrEqual: (val, target) => val <= target,
    lessThan: (val, target) => val < target,
};
const mapCondition = (condition) => {
    const opMap = {
        on: 'is',
        notOn: 'isNot',
        '\u003e': 'greaterThan',
        '\u003c': 'lessThan',
        '\u003d': 'is',
        '\u003c=': 'lessOrEqual',
        '\u003e=': 'greaterOrEqual',
    };
    const mapOperator = (operator) => {
        const keys = Object.keys(opMap);
        // @ts-ignore
        if (keys.includes(operator))
            return opMap[operator];
    };
    let con = {
        type: '',
        operator: '',
        value: condition.value,
        key: '',
    };
    switch (condition.type) {
        case 'click':
            con = {
                type: 'click',
                operator: mapOperator(condition.operator),
                value: condition.value,
                key: '',
            };
            break;
        case 'location':
            con = {
                type: 'visited_url',
                // @ts-ignore
                operator: condition.operator,
                value: condition.value,
                key: '',
            };
            break;
        case 'custom':
            con = {
                type: 'custom_event',
                // @ts-ignore
                operator: condition.operator,
                value: condition.value,
                key: '',
            };
            break;
        case 'metadata':
            con = {
                // @ts-ignore
                type: condition.source === 'featureFlag' ? 'feature_flag' : condition.type,
                // @ts-ignore
                operator: condition.operator,
                value: condition.value,
                key: '',
            };
            break;
        case 'error':
            con = {
                type: 'exception',
                // @ts-ignore
                operator: condition.operator,
                value: condition.value,
                key: '',
            };
            break;
        case 'duration':
            con = {
                type: 'session_duration',
                // @ts-ignore
                value: condition.value,
                key: '',
                operator: 'is',
            };
            break;
        case 'fetchUrl':
            con = {
                type: 'network_request',
                key: 'url',
                operator: condition.operator,
                value: condition.value,
            };
            break;
        case 'fetchStatusCode':
            con = {
                type: 'network_request',
                key: 'status',
                operator: mapOperator(condition.operator),
                value: condition.value,
            };
            break;
        case 'fetchMethod':
            con = {
                type: 'network_request',
                key: 'method',
                operator: mapOperator(condition.operator),
                value: condition.value,
            };
            break;
        case 'fetchDuration':
            con = {
                type: 'network_request',
                key: 'duration',
                operator: mapOperator(condition.operator),
                value: condition.value,
            };
            break;
    }
    // @ts-ignore
    return con;
};

class FeatureFlags {
    constructor(app) {
        this.app = app;
        this.flags = [];
        this.storageKey = '__openreplay_flags';
        const persistFlags = this.app.sessionStorage.getItem(this.storageKey);
        if (persistFlags) {
            const persistFlagsStrArr = persistFlags.split(';').filter(Boolean);
            this.flags = persistFlagsStrArr.map((flag) => JSON.parse(flag));
        }
    }
    getFeatureFlag(flagName) {
        return this.flags.find((flag) => flag.key === flagName);
    }
    isFlagEnabled(flagName) {
        return this.flags.findIndex((flag) => flag.key === flagName) !== -1;
    }
    onFlagsLoad(cb) {
        this.onFlagsCb = cb;
    }
    async reloadFlags(token) {
        const persistFlagsStr = this.app.sessionStorage.getItem(this.storageKey);
        const persistFlags = {};
        if (persistFlagsStr) {
            const persistArray = persistFlagsStr.split(';').filter(Boolean);
            persistArray.forEach((flag) => {
                const flagObj = JSON.parse(flag);
                persistFlags[flagObj.key] = { key: flagObj.key, value: flagObj.value };
            });
        }
        const sessionInfo = this.app.session.getInfo();
        const userInfo = this.app.session.userInfo;
        const requestObject = {
            projectID: sessionInfo.projectID,
            userID: sessionInfo.userID,
            metadata: sessionInfo.metadata,
            referrer: document.referrer,
            os: userInfo.userOS,
            device: userInfo.userDevice,
            country: userInfo.userCountry,
            state: userInfo.userState,
            city: userInfo.userCity,
            browser: userInfo.userBrowser,
            persistFlags: persistFlags,
        };
        const authToken = token ?? this.app.session.getSessionToken();
        const resp = await fetch(this.app.options.ingestPoint + '/v1/web/feature-flags', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${authToken}`,
            },
            body: JSON.stringify(requestObject),
        });
        if (resp.status === 200) {
            const data = await resp.json();
            return this.handleFlags(data.flags);
        }
    }
    handleFlags(flags) {
        const persistFlags = [];
        flags.forEach((flag) => {
            if (flag.is_persist)
                persistFlags.push(flag);
        });
        let str = '';
        const uniquePersistFlags = this.diffPersist(persistFlags);
        uniquePersistFlags.forEach((flag) => {
            str += `${JSON.stringify(flag)};`;
        });
        this.app.sessionStorage.setItem(this.storageKey, str);
        this.flags = flags;
        return this.onFlagsCb?.(flags);
    }
    clearPersistFlags() {
        this.app.sessionStorage.removeItem(this.storageKey);
    }
    diffPersist(flags) {
        const persistFlags = this.app.sessionStorage.getItem(this.storageKey);
        if (!persistFlags)
            return flags;
        const persistFlagsStrArr = persistFlags.split(';').filter(Boolean);
        const persistFlagsArr = persistFlagsStrArr.map((flag) => JSON.parse(flag));
        return flags.filter((flag) => persistFlagsArr.findIndex((pf) => pf.key === flag.key) === -1);
    }
}

const DEPRECATED_ATTRS = { htmlmasked: 'hidden', masked: 'obscured' };
const IN_BROWSER = !(typeof window === 'undefined');
const IS_FIREFOX = IN_BROWSER && navigator.userAgent.match(/firefox|fxios/i);
const MAX_STR_LEN = 1e5;
// Buggy to use `performance.timeOrigin || performance.timing.navigationStart`
// https://github.com/mdn/content/issues/4713
// Maybe move to timer/ticker
let timeOrigin = IN_BROWSER ? Date.now() - performance.now() : 0;
function adjustTimeOrigin() {
    timeOrigin = Date.now() - performance.now();
}
function getTimeOrigin() {
    return timeOrigin;
}
const now = IN_BROWSER && !!performance.now
    ? () => Math.round(performance.now() + timeOrigin)
    : () => Date.now();
const stars = 'repeat' in String.prototype
    ? (str) => '*'.repeat(str.length)
    : (str) => str.replace(/./g, '*');
function normSpaces(str) {
    return str.trim().replace(/\s+/g, ' ');
}
// isAbsoluteUrl regexp:  /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
function isURL(s) {
    return s.startsWith('https://') || s.startsWith('http://');
}
// TODO: JOIN IT WITH LOGGER somehow (use logging decorators?); Don't forget about index.js loggin when there is no logger instance.
const DOCS_HOST = 'https://docs.openreplay.com';
const warnedFeatures = {};
function deprecationWarn(nameOfFeature, useInstead, docsPath = '/') {
    if (warnedFeatures[nameOfFeature]) {
        return;
    }
    console.warn(`OpenReplay: ${nameOfFeature} is deprecated. ${useInstead ? `Please, use ${useInstead} instead.` : ''} Visit ${DOCS_HOST}${docsPath} for more information.`);
    warnedFeatures[nameOfFeature] = true;
}
function getLabelAttribute(e) {
    let value = e.getAttribute('data-openreplay-label');
    if (value !== null) {
        return value;
    }
    value = e.getAttribute('data-asayer-label');
    if (value !== null) {
        deprecationWarn('"data-asayer-label" attribute', '"data-openreplay-label" attribute', '/');
    }
    return value;
}
function hasOpenreplayAttribute(e, attr) {
    const newName = `data-openreplay-${attr}`;
    if (e.hasAttribute(newName)) {
        // @ts-ignore
        if (DEPRECATED_ATTRS[attr]) {
            deprecationWarn(`"${newName}" attribute`, 
            // @ts-ignore
            `"${DEPRECATED_ATTRS[attr]}" attribute`, '/en/sdk/sanitize-data');
        }
        return true;
    }
    return false;
}
/**
 * checks if iframe is accessible
 **/
function canAccessIframe(iframe) {
    try {
        return Boolean(iframe.contentDocument);
    }
    catch (e) {
        return false;
    }
}
function canAccessTarget(target) {
    try {
        if (target instanceof HTMLIFrameElement) {
            void target.contentDocument;
        }
        else if (target instanceof Window) {
            void target.document;
        }
        else if (target instanceof Document) {
            void target.defaultView;
        }
        else if ('nodeType' in target) {
            void target.nodeType;
        }
        else if ('addEventListener' in target) {
            void target.addEventListener;
        }
        return true;
    }
    catch (e) {
        if (e instanceof DOMException && e.name === 'SecurityError') {
            return false;
        }
    }
    return true;
}
function dec2hex(dec) {
    return dec.toString(16).padStart(2, '0');
}
function generateRandomId(len) {
    const arr = new Uint8Array((len) / 2);
    // msCrypto = IE11
    // @ts-ignore
    const safeCrypto = window.crypto || window.msCrypto;
    if (safeCrypto) {
        safeCrypto.getRandomValues(arr);
        return Array.from(arr, dec2hex).join('');
    }
    else {
        return Array.from({ length: len }, () => dec2hex(Math.floor(Math.random() * 16))).join('');
    }
}
function inIframe() {
    try {
        return window.self && window.top && window.self !== window.top;
    }
    catch (e) {
        return true;
    }
}
/**
 * Because angular devs decided that its a good idea to override a browser apis
 * we need to use this to achieve safe behavior
 * */
function ngSafeBrowserMethod(method) {
    // @ts-ignore
    return window.Zone && '__symbol__' in window.Zone
        ? // @ts-ignore
            window['Zone']['__symbol__'](method)
        : method;
}
function createMutationObserver(cb, forceNgOff) {
    if (!forceNgOff) {
        const mObserver = ngSafeBrowserMethod('MutationObserver');
        return new window[mObserver](cb);
    }
    else {
        return new MutationObserver(cb);
    }
}
function createEventListener(target, event, cb, capture, forceNgOff) {
    // we need to check if target is crossorigin frame or no and if we can access it
    if (!canAccessTarget(target)) {
        return;
    }
    let safeAddEventListener = 'addEventListener';
    if (!forceNgOff) {
        safeAddEventListener = ngSafeBrowserMethod('addEventListener');
    }
    try {
        // parent has angular, but child frame don't
        if (target[safeAddEventListener]) {
            target[safeAddEventListener](event, cb, capture);
        }
        else {
            // @ts-ignore
            target.addEventListener(event, cb, capture);
        }
    }
    catch (e) {
        const msg = e.message;
        console.error(
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        `Openreplay: ${msg}; if this error is caused by an IframeObserver, ignore it`, event, target);
    }
}
function deleteEventListener(target, event, cb, capture, forceNgOff) {
    if (!canAccessTarget(target)) {
        return;
    }
    let safeRemoveEventListener = 'removeEventListener';
    if (!forceNgOff) {
        safeRemoveEventListener = ngSafeBrowserMethod('removeEventListener');
    }
    try {
        if (target[safeRemoveEventListener]) {
            target[safeRemoveEventListener](event, cb, capture);
        }
        else {
            // @ts-ignore
            target.removeEventListener(event, cb, capture);
        }
    }
    catch (e) {
        const msg = e.message;
        console.error(
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        `Openreplay: ${msg}; if this error is caused by an IframeObserver, ignore it`, event, target);
    }
}
class FIFOTaskScheduler {
    constructor() {
        this.taskQueue = [];
        this.isRunning = false;
    }
    // Adds a task to the queue
    addTask(task) {
        this.taskQueue.push(task);
        this.runTasks();
    }
    // Runs tasks from the queue
    runTasks() {
        if (this.isRunning || this.taskQueue.length === 0) {
            return;
        }
        this.isRunning = true;
        const executeNextTask = () => {
            if (this.taskQueue.length === 0) {
                this.isRunning = false;
                return;
            }
            // Get the next task and execute it
            const nextTask = this.taskQueue.shift();
            Promise.resolve(nextTask()).then(() => {
                requestAnimationFrame(() => executeNextTask());
            });
        };
        executeNextTask();
    }
}
const scheduler = new FIFOTaskScheduler();
function requestIdleCb(callback) {
    // performance improvement experiment;
    scheduler.addTask(callback);
    /**
     * This is a brief polyfill that suits our needs
     * I took inspiration from Microsoft Clarity polyfill on this one
     * then adapted it a little bit
     *
     * I'm very grateful for their bright idea
     * */
    // const taskTimeout = 3000
    // if (window.requestIdleCallback) {
    //   return window.requestIdleCallback(callback, { timeout: taskTimeout })
    // } else {
    //   const channel = new MessageChannel()
    //   const incoming = channel.port1
    //   const outgoing = channel.port2
    //
    //   incoming.onmessage = (): void => {
    //     callback()
    //   }
    //   requestAnimationFrame((): void => {
    //     outgoing.postMessage(1)
    //   })
    // }
}
function simpleMerge(defaultObj, givenObj) {
    const result = { ...defaultObj };
    for (const key in givenObj) {
        // eslint-disable-next-line no-prototype-builtins
        if (givenObj.hasOwnProperty(key)) {
            const userOptionValue = givenObj[key];
            const defaultOptionValue = defaultObj[key];
            if (typeof userOptionValue === 'object' &&
                !Array.isArray(userOptionValue) &&
                userOptionValue !== null) {
                result[key] = simpleMerge(defaultOptionValue || {}, userOptionValue);
            }
            else {
                result[key] = userOptionValue;
            }
        }
    }
    return result;
}

// Auto-generated, do not edit
/* eslint-disable */
function Timestamp(timestamp) {
    return [
        0 /* Messages.Type.Timestamp */,
        timestamp,
    ];
}
function SetPageLocationDeprecated(url, referrer, navigationStart) {
    return [
        4 /* Messages.Type.SetPageLocationDeprecated */,
        url,
        referrer,
        navigationStart,
    ];
}
function SetViewportSize(width, height) {
    return [
        5 /* Messages.Type.SetViewportSize */,
        width,
        height,
    ];
}
function SetViewportScroll(x, y) {
    return [
        6 /* Messages.Type.SetViewportScroll */,
        x,
        y,
    ];
}
function CreateDocument() {
    return [
        7 /* Messages.Type.CreateDocument */,
    ];
}
function CreateElementNode(id, parentID, index, tag, svg) {
    return [
        8 /* Messages.Type.CreateElementNode */,
        id,
        parentID,
        index,
        tag,
        svg,
    ];
}
function CreateTextNode(id, parentID, index) {
    return [
        9 /* Messages.Type.CreateTextNode */,
        id,
        parentID,
        index,
    ];
}
function MoveNode(id, parentID, index) {
    return [
        10 /* Messages.Type.MoveNode */,
        id,
        parentID,
        index,
    ];
}
function RemoveNode(id) {
    return [
        11 /* Messages.Type.RemoveNode */,
        id,
    ];
}
function SetNodeAttribute(id, name, value) {
    return [
        12 /* Messages.Type.SetNodeAttribute */,
        id,
        name,
        value,
    ];
}
function RemoveNodeAttribute(id, name) {
    return [
        13 /* Messages.Type.RemoveNodeAttribute */,
        id,
        name,
    ];
}
function SetNodeData(id, data) {
    return [
        14 /* Messages.Type.SetNodeData */,
        id,
        data,
    ];
}
function SetNodeScroll(id, x, y) {
    return [
        16 /* Messages.Type.SetNodeScroll */,
        id,
        x,
        y,
    ];
}
function SetInputTarget(id, label) {
    return [
        17 /* Messages.Type.SetInputTarget */,
        id,
        label,
    ];
}
function SetInputValue(id, value, mask) {
    return [
        18 /* Messages.Type.SetInputValue */,
        id,
        value,
        mask,
    ];
}
function SetInputChecked(id, checked) {
    return [
        19 /* Messages.Type.SetInputChecked */,
        id,
        checked,
    ];
}
function MouseMove(x, y) {
    return [
        20 /* Messages.Type.MouseMove */,
        x,
        y,
    ];
}
function NetworkRequestDeprecated(type, method, url, request, response, status, timestamp, duration) {
    return [
        21 /* Messages.Type.NetworkRequestDeprecated */,
        type,
        method,
        url,
        request,
        response,
        status,
        timestamp,
        duration,
    ];
}
function ConsoleLog(level, value) {
    return [
        22 /* Messages.Type.ConsoleLog */,
        level,
        value,
    ];
}
function PageLoadTiming(requestStart, responseStart, responseEnd, domContentLoadedEventStart, domContentLoadedEventEnd, loadEventStart, loadEventEnd, firstPaint, firstContentfulPaint) {
    return [
        23 /* Messages.Type.PageLoadTiming */,
        requestStart,
        responseStart,
        responseEnd,
        domContentLoadedEventStart,
        domContentLoadedEventEnd,
        loadEventStart,
        loadEventEnd,
        firstPaint,
        firstContentfulPaint,
    ];
}
function PageRenderTiming(speedIndex, visuallyComplete, timeToInteractive) {
    return [
        24 /* Messages.Type.PageRenderTiming */,
        speedIndex,
        visuallyComplete,
        timeToInteractive,
    ];
}
function CustomEvent(name, payload) {
    return [
        27 /* Messages.Type.CustomEvent */,
        name,
        payload,
    ];
}
function UserID(id) {
    return [
        28 /* Messages.Type.UserID */,
        id,
    ];
}
function UserAnonymousID(id) {
    return [
        29 /* Messages.Type.UserAnonymousID */,
        id,
    ];
}
function Metadata(key, value) {
    return [
        30 /* Messages.Type.Metadata */,
        key,
        value,
    ];
}
function StringDictGlobal(key, value) {
    return [
        34 /* Messages.Type.StringDictGlobal */,
        key,
        value,
    ];
}
function SetNodeAttributeDictGlobal(id, name, value) {
    return [
        35 /* Messages.Type.SetNodeAttributeDictGlobal */,
        id,
        name,
        value,
    ];
}
function Profiler(name, duration, args, result) {
    return [
        40 /* Messages.Type.Profiler */,
        name,
        duration,
        args,
        result,
    ];
}
function OTable(key, value) {
    return [
        41 /* Messages.Type.OTable */,
        key,
        value,
    ];
}
function StateAction(type) {
    return [
        42 /* Messages.Type.StateAction */,
        type,
    ];
}
function ReduxDeprecated(action, state, duration) {
    return [
        44 /* Messages.Type.ReduxDeprecated */,
        action,
        state,
        duration,
    ];
}
function Vuex(mutation, state) {
    return [
        45 /* Messages.Type.Vuex */,
        mutation,
        state,
    ];
}
function MobX(type, payload) {
    return [
        46 /* Messages.Type.MobX */,
        type,
        payload,
    ];
}
function NgRx(action, state, duration) {
    return [
        47 /* Messages.Type.NgRx */,
        action,
        state,
        duration,
    ];
}
function GraphQLDeprecated(operationKind, operationName, variables, response, duration) {
    return [
        48 /* Messages.Type.GraphQLDeprecated */,
        operationKind,
        operationName,
        variables,
        response,
        duration,
    ];
}
function PerformanceTrack(frames, ticks, totalJSHeapSize, usedJSHeapSize) {
    return [
        49 /* Messages.Type.PerformanceTrack */,
        frames,
        ticks,
        totalJSHeapSize,
        usedJSHeapSize,
    ];
}
function StringDictDeprecated(key, value) {
    return [
        50 /* Messages.Type.StringDictDeprecated */,
        key,
        value,
    ];
}
function SetNodeAttributeDictDeprecated(id, nameKey, valueKey) {
    return [
        51 /* Messages.Type.SetNodeAttributeDictDeprecated */,
        id,
        nameKey,
        valueKey,
    ];
}
function StringDict(key, value) {
    return [
        43 /* Messages.Type.StringDict */,
        key,
        value,
    ];
}
function SetNodeAttributeDict(id, name, value) {
    return [
        52 /* Messages.Type.SetNodeAttributeDict */,
        id,
        name,
        value,
    ];
}
function ResourceTimingDeprecated(timestamp, duration, ttfb, headerSize, encodedBodySize, decodedBodySize, url, initiator) {
    return [
        53 /* Messages.Type.ResourceTimingDeprecated */,
        timestamp,
        duration,
        ttfb,
        headerSize,
        encodedBodySize,
        decodedBodySize,
        url,
        initiator,
    ];
}
function ConnectionInformation(downlink, type) {
    return [
        54 /* Messages.Type.ConnectionInformation */,
        downlink,
        type,
    ];
}
function SetPageVisibility(hidden) {
    return [
        55 /* Messages.Type.SetPageVisibility */,
        hidden,
    ];
}
function LoadFontFace(parentID, family, source, descriptors) {
    return [
        57 /* Messages.Type.LoadFontFace */,
        parentID,
        family,
        source,
        descriptors,
    ];
}
function SetNodeFocus(id) {
    return [
        58 /* Messages.Type.SetNodeFocus */,
        id,
    ];
}
function SetNodeAttributeURLBased(id, name, value, baseURL) {
    return [
        60 /* Messages.Type.SetNodeAttributeURLBased */,
        id,
        name,
        value,
        baseURL,
    ];
}
function SetCSSDataURLBased(id, data, baseURL) {
    return [
        61 /* Messages.Type.SetCSSDataURLBased */,
        id,
        data,
        baseURL,
    ];
}
function TechnicalInfo(type, value) {
    return [
        63 /* Messages.Type.TechnicalInfo */,
        type,
        value,
    ];
}
function CustomIssue(name, payload) {
    return [
        64 /* Messages.Type.CustomIssue */,
        name,
        payload,
    ];
}
function MouseClick(id, hesitationTime, label, selector, normalizedX, normalizedY) {
    return [
        68 /* Messages.Type.MouseClick */,
        id,
        hesitationTime,
        label,
        selector,
        normalizedX,
        normalizedY,
    ];
}
function MouseClickDeprecated(id, hesitationTime, label, selector) {
    return [
        69 /* Messages.Type.MouseClickDeprecated */,
        id,
        hesitationTime,
        label,
        selector,
    ];
}
function CreateIFrameDocument(frameID, id) {
    return [
        70 /* Messages.Type.CreateIFrameDocument */,
        frameID,
        id,
    ];
}
function AdoptedSSReplaceURLBased(sheetID, text, baseURL) {
    return [
        71 /* Messages.Type.AdoptedSSReplaceURLBased */,
        sheetID,
        text,
        baseURL,
    ];
}
function AdoptedSSInsertRuleURLBased(sheetID, rule, index, baseURL) {
    return [
        73 /* Messages.Type.AdoptedSSInsertRuleURLBased */,
        sheetID,
        rule,
        index,
        baseURL,
    ];
}
function AdoptedSSDeleteRule(sheetID, index) {
    return [
        75 /* Messages.Type.AdoptedSSDeleteRule */,
        sheetID,
        index,
    ];
}
function AdoptedSSAddOwner(sheetID, id) {
    return [
        76 /* Messages.Type.AdoptedSSAddOwner */,
        sheetID,
        id,
    ];
}
function AdoptedSSRemoveOwner(sheetID, id) {
    return [
        77 /* Messages.Type.AdoptedSSRemoveOwner */,
        sheetID,
        id,
    ];
}
function JSException(name, message, payload, metadata) {
    return [
        78 /* Messages.Type.JSException */,
        name,
        message,
        payload,
        metadata,
    ];
}
function Zustand(mutation, state) {
    return [
        79 /* Messages.Type.Zustand */,
        mutation,
        state,
    ];
}
function BatchMetadata(version, pageNo, firstIndex, timestamp, location) {
    return [
        81 /* Messages.Type.BatchMetadata */,
        version,
        pageNo,
        firstIndex,
        timestamp,
        location,
    ];
}
function PartitionedMessage(partNo, partTotal) {
    return [
        82 /* Messages.Type.PartitionedMessage */,
        partNo,
        partTotal,
    ];
}
function NetworkRequest(type, method, url, request, response, status, timestamp, duration, transferredBodySize) {
    return [
        83 /* Messages.Type.NetworkRequest */,
        type,
        method,
        url,
        request,
        response,
        status,
        timestamp,
        duration,
        transferredBodySize,
    ];
}
function WSChannel(chType, channelName, data, timestamp, dir, messageType) {
    return [
        84 /* Messages.Type.WSChannel */,
        chType,
        channelName,
        data,
        timestamp,
        dir,
        messageType,
    ];
}
function InputChange(id, value, valueMasked, label, hesitationTime, inputDuration) {
    return [
        112 /* Messages.Type.InputChange */,
        id,
        value,
        valueMasked,
        label,
        hesitationTime,
        inputDuration,
    ];
}
function SelectionChange(selectionStart, selectionEnd, selection) {
    return [
        113 /* Messages.Type.SelectionChange */,
        selectionStart,
        selectionEnd,
        selection,
    ];
}
function MouseThrashing(timestamp) {
    return [
        114 /* Messages.Type.MouseThrashing */,
        timestamp,
    ];
}
function UnbindNodes(totalRemovedPercent) {
    return [
        115 /* Messages.Type.UnbindNodes */,
        totalRemovedPercent,
    ];
}
function ResourceTiming(timestamp, duration, ttfb, headerSize, encodedBodySize, decodedBodySize, url, initiator, transferredSize, cached) {
    return [
        116 /* Messages.Type.ResourceTiming */,
        timestamp,
        duration,
        ttfb,
        headerSize,
        encodedBodySize,
        decodedBodySize,
        url,
        initiator,
        transferredSize,
        cached,
    ];
}
function TabChange(tabId) {
    return [
        117 /* Messages.Type.TabChange */,
        tabId,
    ];
}
function TabData(tabId) {
    return [
        118 /* Messages.Type.TabData */,
        tabId,
    ];
}
function CanvasNode(nodeId, timestamp) {
    return [
        119 /* Messages.Type.CanvasNode */,
        nodeId,
        timestamp,
    ];
}
function TagTrigger(tagId) {
    return [
        120 /* Messages.Type.TagTrigger */,
        tagId,
    ];
}
function Redux(action, state, duration, actionTime) {
    return [
        121 /* Messages.Type.Redux */,
        action,
        state,
        duration,
        actionTime,
    ];
}
function SetPageLocation(url, referrer, navigationStart, documentTitle) {
    return [
        122 /* Messages.Type.SetPageLocation */,
        url,
        referrer,
        navigationStart,
        documentTitle,
    ];
}
function GraphQL(operationKind, operationName, variables, response, duration) {
    return [
        123 /* Messages.Type.GraphQL */,
        operationKind,
        operationName,
        variables,
        response,
        duration,
    ];
}
function WebVitals(name, value) {
    return [
        124 /* Messages.Type.WebVitals */,
        name,
        value,
    ];
}

var _Messages = /*#__PURE__*/Object.freeze({
    __proto__: null,
    AdoptedSSAddOwner: AdoptedSSAddOwner,
    AdoptedSSDeleteRule: AdoptedSSDeleteRule,
    AdoptedSSInsertRuleURLBased: AdoptedSSInsertRuleURLBased,
    AdoptedSSRemoveOwner: AdoptedSSRemoveOwner,
    AdoptedSSReplaceURLBased: AdoptedSSReplaceURLBased,
    BatchMetadata: BatchMetadata,
    CanvasNode: CanvasNode,
    ConnectionInformation: ConnectionInformation,
    ConsoleLog: ConsoleLog,
    CreateDocument: CreateDocument,
    CreateElementNode: CreateElementNode,
    CreateIFrameDocument: CreateIFrameDocument,
    CreateTextNode: CreateTextNode,
    CustomEvent: CustomEvent,
    CustomIssue: CustomIssue,
    GraphQL: GraphQL,
    GraphQLDeprecated: GraphQLDeprecated,
    InputChange: InputChange,
    JSException: JSException,
    LoadFontFace: LoadFontFace,
    Metadata: Metadata,
    MobX: MobX,
    MouseClick: MouseClick,
    MouseClickDeprecated: MouseClickDeprecated,
    MouseMove: MouseMove,
    MouseThrashing: MouseThrashing,
    MoveNode: MoveNode,
    NetworkRequest: NetworkRequest,
    NetworkRequestDeprecated: NetworkRequestDeprecated,
    NgRx: NgRx,
    OTable: OTable,
    PageLoadTiming: PageLoadTiming,
    PageRenderTiming: PageRenderTiming,
    PartitionedMessage: PartitionedMessage,
    PerformanceTrack: PerformanceTrack,
    Profiler: Profiler,
    Redux: Redux,
    ReduxDeprecated: ReduxDeprecated,
    RemoveNode: RemoveNode,
    RemoveNodeAttribute: RemoveNodeAttribute,
    ResourceTiming: ResourceTiming,
    ResourceTimingDeprecated: ResourceTimingDeprecated,
    SelectionChange: SelectionChange,
    SetCSSDataURLBased: SetCSSDataURLBased,
    SetInputChecked: SetInputChecked,
    SetInputTarget: SetInputTarget,
    SetInputValue: SetInputValue,
    SetNodeAttribute: SetNodeAttribute,
    SetNodeAttributeDict: SetNodeAttributeDict,
    SetNodeAttributeDictDeprecated: SetNodeAttributeDictDeprecated,
    SetNodeAttributeDictGlobal: SetNodeAttributeDictGlobal,
    SetNodeAttributeURLBased: SetNodeAttributeURLBased,
    SetNodeData: SetNodeData,
    SetNodeFocus: SetNodeFocus,
    SetNodeScroll: SetNodeScroll,
    SetPageLocation: SetPageLocation,
    SetPageLocationDeprecated: SetPageLocationDeprecated,
    SetPageVisibility: SetPageVisibility,
    SetViewportScroll: SetViewportScroll,
    SetViewportSize: SetViewportSize,
    StateAction: StateAction,
    StringDict: StringDict,
    StringDictDeprecated: StringDictDeprecated,
    StringDictGlobal: StringDictGlobal,
    TabChange: TabChange,
    TabData: TabData,
    TagTrigger: TagTrigger,
    TechnicalInfo: TechnicalInfo,
    Timestamp: Timestamp,
    UnbindNodes: UnbindNodes,
    UserAnonymousID: UserAnonymousID,
    UserID: UserID,
    Vuex: Vuex,
    WSChannel: WSChannel,
    WebVitals: WebVitals,
    Zustand: Zustand
});

const perf = IN_BROWSER && 'performance' in window && 'memory' in performance // works in Chrome only
    ? performance
    : { memory: {} };
const deviceMemory = IN_BROWSER ? (navigator.deviceMemory || 0) * 1024 : 0;
const jsHeapSizeLimit = perf.memory.jsHeapSizeLimit || 0;
function Performance (app, opts) {
    const options = Object.assign({
        capturePerformance: true,
    }, opts);
    if (!options.capturePerformance) {
        return;
    }
    let frames;
    let ticks;
    const nextFrame = () => {
        if (frames === undefined || frames === -1) {
            return;
        }
        frames++;
        requestAnimationFrame(nextFrame);
    };
    app.ticker.attach(() => {
        if (ticks === undefined || ticks === -1) {
            return;
        }
        ticks++;
    }, 0, false);
    const sendPerformanceTrack = () => {
        if (frames === undefined || ticks === undefined) {
            return;
        }
        app.send(PerformanceTrack(frames, ticks, perf.memory.totalJSHeapSize || 0, perf.memory.usedJSHeapSize || 0));
        ticks = frames = document.hidden ? -1 : 0;
    };
    app.attachStartCallback(() => {
        ticks = frames = -1;
        sendPerformanceTrack();
        nextFrame();
    });
    app.attachStopCallback(() => {
        ticks = frames = undefined;
    });
    app.ticker.attach(sendPerformanceTrack, 165, false);
    if (document.hidden !== undefined) {
        app.attachEventListener(document, 'visibilitychange', sendPerformanceTrack, false, false);
    }
}

const WATCHED_TAGS_KEY = '__or__watched_tags__';
class TagWatcher {
    constructor(params) {
        this.intervals = {};
        this.tags = [];
        this.sessionStorage = params.sessionStorage;
        this.errLog = params.errLog;
        this.onTag = params.onTag;
        // @ts-ignore
        const tags = JSON.parse(params.sessionStorage.getItem(WATCHED_TAGS_KEY) ?? '[]');
        this.setTags(tags);
        this.observer = new IntersectionObserver((entries) => {
            entries.forEach((entry) => {
                if (entry.isIntersecting) {
                    if (entry.target) {
                        // @ts-ignore
                        const tag = entry.target.__or_watcher_tagname;
                        if (tag) {
                            this.onTagRendered(tag);
                        }
                        this.observer.unobserve(entry.target);
                    }
                }
            });
        });
    }
    async fetchTags(ingest, token) {
        return fetch(`${ingest}/v1/web/tags`, {
            method: 'GET',
            headers: {
                Authorization: `Bearer ${token}`,
            },
        })
            .then((r) => r.json())
            .then(({ tags }) => {
            if (tags && tags.length) {
                this.setTags(tags);
                const tagString = JSON.stringify(tags);
                this.sessionStorage.setItem(WATCHED_TAGS_KEY, tagString || '');
            }
        })
            .catch((e) => this.errLog(e));
    }
    setTags(tags) {
        this.tags = tags;
        this.intervals = {};
        tags.forEach((tag) => {
            this.intervals[tag.id] = setInterval(() => {
                const possibleEls = document.querySelectorAll(tag.selector);
                if (possibleEls.length > 0) {
                    const el = possibleEls[0];
                    // @ts-ignore
                    el.__or_watcher_tagname = tag.id;
                    this.observer.observe(el);
                }
            }, 500);
        });
    }
    onTagRendered(tagId) {
        if (this.intervals[tagId]) {
            clearInterval(this.intervals[tagId]);
        }
        this.onTag(tagId);
    }
    clear() {
        this.tags.forEach((tag) => {
            clearInterval(this.intervals[tag.id]);
        });
        this.tags = [];
        this.intervals = {};
        this.observer.disconnect();
    }
}

const bgStyle = {
    position: 'fixed',
    top: 0,
    left: 0,
    width: '100vw',
    height: '100vh',
    background: 'rgba(0, 0, 0, 0.40)',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    zIndex: 999999,
    fontFamily: `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
};
const containerStyle = {
    display: 'flex',
    flexDirection: 'column',
    gap: '2rem',
    alignItems: 'center',
    padding: '1.5rem',
    borderRadius: '2px',
    border: '1px solid rgb(255 255 255 / var(--tw-bg-opacity, 1))',
    background: '#FFF',
    width: '22rem',
};
const containerWidgetStyle = {
    display: 'flex',
    'flex-direction': 'column',
    gap: 'unset',
    'align-items': 'center',
    padding: 'unset',
    fontFamily: `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`,
    'border-radius': '2px',
    border: '1px solid rgb(255 255 255 / var(--tw-bg-opacity, 1))',
    background: 'rgba(255, 255, 255, 0.75)',
    width: '22rem',
};
const titleStyle = {
    fontFamily: 'Verdana, sans-serif',
    fontSize: '1.25rem',
    fontStyle: 'normal',
    fontWeight: '500',
    lineHeight: '1.75rem',
    color: 'rgba(0, 0, 0, 0.85)',
};
const descriptionStyle = {
    borderTop: '1px solid rgba(0, 0, 0, 0.06)',
    borderBottom: '1px solid rgba(0, 0, 0, 0.06)',
    padding: '1.25rem 0rem',
    color: 'rgba(0, 0, 0, 0.85)',
    fontFamily: 'Verdana, sans-serif',
    fontSize: '13px',
    fontStyle: 'normal',
    fontWeight: '400',
    lineHeight: 'auto',
    whiteSpace: 'pre-wrap',
};
const buttonStyle = {
    display: 'flex',
    padding: '0.4rem 0.9375rem',
    justifyContent: 'center',
    alignItems: 'center',
    gap: '0.625rem',
    borderRadius: '0.25rem',
    border: '1px solid #394EFF',
    background: '#394EFF',
    boxShadow: '0px 2px 0px 0px rgba(0, 0, 0, 0.04)',
    color: '#FFF',
    textAlign: 'center',
    fontFamily: 'Verdana, sans-serif',
    fontSize: '1rem',
    fontStyle: 'normal',
    fontWeight: '500',
    lineHeight: '1.5rem',
    cursor: 'pointer',
};
const sectionTitleStyle = {
    fontFamily: 'Verdana, sans-serif',
    fontSize: '13px',
    fontWeight: '500',
    lineHeight: 'auto',
    display: 'flex',
    justifyContent: 'space-between',
    width: '100%',
    cursor: 'pointer',
};
const contentStyle = {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'flex-start',
    gap: '0.625rem',
    fontSize: '13px',
    lineHeight: 'auto',
};
// New widget styles
const titleWidgetStyle = {
    padding: '0.5rem',
    gap: '0.5rem',
    fontFamily: 'Verdana, sans-serif',
    fontSize: '16px',
    fontStyle: 'normal',
    fontWeight: '500',
    lineHeight: 'auto',
    color: 'white',
    display: 'flex',
    alignItems: 'center',
    width: '100%',
    borderRadius: '2px',
    background: 'rgba(0, 0, 0, 0.75)',
    boxSizing: 'border-box',
};
const descriptionWidgetStyle = {
    boxSizing: 'border-box',
    display: 'block',
    width: '100%',
    borderBottom: '1px solid rgb(255 255 255 / var(--tw-bg-opacity, 1))',
    background: '#FFF',
    padding: '0.65rem',
    alignSelf: 'stretch',
    color: '#000',
    fontFamily: 'Verdana, sans-serif',
    // fontSize: '0.875rem',
    fontStyle: 'normal',
    fontWeight: '400',
    // lineHeight: '1.375rem',
};
const endSectionStyle = {
    ...descriptionWidgetStyle,
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    gap: '0.625rem',
};
const symbolIcon = {
    fontSize: '1.25rem',
    fontWeight: '500',
    cursor: 'pointer',
    color: '#394EFF',
};
const buttonWidgetStyle = {
    display: 'flex',
    padding: '0.4rem 0.9375rem',
    justifyContent: 'center',
    alignItems: 'center',
    gap: '0.625rem',
    borderRadius: '0.25rem',
    border: '1px solid #394EFF',
    background: '#394EFF',
    boxShadow: '0px 2px 0px 0px rgba(0, 0, 0, 0.04)',
    color: '#FFF',
    textAlign: 'center',
    fontFamily: 'Verdana, sans-serif',
    fontSize: '1rem',
    fontStyle: 'normal',
    fontWeight: '500',
    lineHeight: '1.5rem',
    width: '100%',
    boxSizing: 'border-box',
    cursor: 'pointer',
};
const stopWidgetStyle = {
    marginTop: '1rem',
    marginBottom: '1rem',
    cursor: 'pointer',
    display: 'block',
    fontWeight: '500',
    fontSize: '13px!important',
    lineHeight: 'auto',
};
const paginationStyle = {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    gap: '1rem',
    padding: '0.5rem',
    width: '100%',
    boxSizing: 'border-box',
};
const taskNumberActive = {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: '6.25em',
    outline: '1px solid #394EFF',
    fontSize: '13px',
    height: '24px',
    width: '24px',
};
const taskNumberDone = {
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    justifyContent: 'center',
    borderRadius: '6.25em',
    outline: '1px solid #D2DFFF',
    boxShadow: '0px 2px 0px 0px rgba(0, 0, 0, 0.04)',
    background: '#D2DFFF',
    fontSize: '13px',
    height: '24px',
    width: '24px',
};
const taskDescriptionCard = {
    borderRadius: '0.375rem',
    border: '1px solid rgba(0, 0, 0, 0.06)',
    background: '#F5F7FF',
    boxShadow: '0px 2px 0px 0px rgba(0, 0, 0, 0.04)',
    display: 'flex',
    flexDirection: 'column',
    padding: '0.625rem 0.9375rem',
    gap: '0.5rem',
    alignSelf: 'stretch',
};
const taskTextStyle = {
    fontWeight: 'bold',
};
const taskDescriptionStyle = {
    fontSize: '13px',
    lineHeight: 'auto',
};
const taskButtonStyle = {
    marginRight: '0.5rem',
    cursor: 'pointer',
    color: '#394EFF',
    textAlign: 'center',
    fontFamily: 'Verdana, sans-serif',
    fontSize: '13px',
    fontStyle: 'normal',
    fontWeight: '500',
    lineHeight: 'auto',
};
const taskButtonBorderedStyle = {
    ...taskButtonStyle,
    display: 'flex',
    padding: '0.25rem 0.9375rem',
    justifyContent: 'center',
    alignItems: 'center',
    gap: '0.5rem',
    borderRadius: '0.25rem',
    border: '1px solid #394EFF',
};
const taskButtonsRow = {
    display: 'flex',
    justifyContent: 'space-between',
    alignItems: 'center',
    width: '100%',
    boxSizing: 'border-box',
};
const spinnerStyles = {
    border: '4px solid rgba(255, 255, 255, 0.4)',
    width: '16px',
    height: '16px',
    borderRadius: '50%',
    borderLeftColor: '#fff',
    animation: 'spin 0.5s linear infinite',
};

const Quality = {
    Standard: { width: 1280, height: 720 }};
class Recorder {
    constructor(app) {
        this.app = app;
        this.mediaRecorder = null;
        this.recordedChunks = [];
        this.stream = null;
        this.recStartTs = null;
    }
    async startRecording(fps, quality, micReq, camReq) {
        this.recStartTs = this.app.timestamp();
        const videoConstraints = quality;
        try {
            this.stream = await navigator.mediaDevices.getUserMedia({
                video: camReq ? { ...videoConstraints, frameRate: { ideal: fps } } : false,
                audio: micReq,
            });
            this.mediaRecorder = new MediaRecorder(this.stream, {
                mimeType: 'video/webm;codecs=vp9',
            });
            this.recordedChunks = [];
            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.recordedChunks.push(event.data);
                }
            };
            this.mediaRecorder.start();
        }
        catch (error) {
            console.error(error);
        }
    }
    async stopRecording() {
        return new Promise((resolve) => {
            if (!this.mediaRecorder)
                return;
            this.mediaRecorder.onstop = () => {
                const blob = new Blob(this.recordedChunks, {
                    type: 'video/webm',
                });
                resolve(blob);
            };
            this.mediaRecorder.stop();
        });
    }
    async sendToAPI() {
        const blob = await this.stopRecording();
        // const formData = new FormData()
        // formData.append('file', blob, 'record.webm')
        // formData.append('start', this.recStartTs?.toString() ?? '')
        return fetch(`${this.app.options.ingestPoint}/v1/web/uxt/upload-url`, {
            headers: {
                Authorization: `Bearer ${this.app.session.getSessionToken()}`,
            },
        })
            .then((r) => {
            if (r.ok) {
                return r.json();
            }
            else {
                throw new Error('Failed to get upload url');
            }
        })
            .then(({ url }) => {
            return fetch(url, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'video/webm',
                },
                body: blob,
            });
        })
            .catch(console.error)
            .finally(() => {
            this.discard();
        });
    }
    async saveToFile(fileName = 'recorded-video.webm') {
        const blob = await this.stopRecording();
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
        document.body.removeChild(a);
    }
    discard() {
        this.mediaRecorder?.stop();
        this.stream?.getTracks().forEach((track) => track.stop());
    }
}

// @ts-nocheck
function attachDND(element, dragTarget) {
    dragTarget.onmousedown = function (event) {
        const clientRect = element.getBoundingClientRect();
        const shiftX = event.clientX - clientRect.left;
        const shiftY = event.clientY - clientRect.top;
        element.style.position = 'fixed';
        element.style.zIndex = 99999999999999;
        moveAt(event.pageX, event.pageY);
        function moveAt(pageX, pageY) {
            let leftC = pageX - shiftX;
            let topC = pageY - shiftY;
            if (leftC <= 5)
                leftC = 5;
            if (topC <= 5)
                topC = 5;
            if (leftC >= window.innerWidth - clientRect.width)
                leftC = window.innerWidth - clientRect.width;
            if (topC >= window.innerHeight - clientRect.height)
                topC = window.innerHeight - clientRect.height;
            element.style.left = `${leftC}px`;
            element.style.top = `${topC}px`;
        }
        function onMouseMove(event) {
            moveAt(event.pageX, event.pageY);
        }
        document.addEventListener('mousemove', onMouseMove);
        const clearAll = () => {
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', clearAll);
        };
        document.addEventListener('mouseup', clearAll);
    };
    dragTarget.ondragstart = function () {
        return false;
    };
}

function generateGrid() {
    const grid = document.createElement('div');
    grid.className = 'grid';
    for (let i = 0; i < 16; i++) {
        const cell = document.createElement('div');
        Object.assign(cell.style, {
            width: '2px',
            height: '2px',
            borderRadius: '10px',
            background: 'white',
        });
        cell.className = 'cell';
        grid.appendChild(cell);
    }
    Object.assign(grid.style, {
        display: 'grid',
        gridTemplateColumns: 'repeat(4, 1fr)',
        gridTemplateRows: 'repeat(4, 1fr)',
        gap: '2px',
        cursor: 'grab',
    });
    return grid;
}
function generateChevron() {
    const triangle = document.createElement('div');
    Object.assign(triangle.style, {
        width: '0',
        height: '0',
        borderLeft: '7px solid transparent',
        borderRight: '7px solid transparent',
        borderBottom: '7px solid white',
    });
    const container = document.createElement('div');
    container.appendChild(triangle);
    Object.assign(container.style, {
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        width: '16px',
        height: '16px',
        cursor: 'pointer',
        marginLeft: 'auto',
        transform: 'rotate(180deg)',
    });
    return container;
}
function addKeyframes() {
    const styleSheet = document.createElement('style');
    styleSheet.type = 'text/css';
    styleSheet.innerText = `@keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }`;
    document.head.appendChild(styleSheet);
}
function createSpinner() {
    addKeyframes();
    const spinner = document.createElement('div');
    spinner.classList.add('spinner');
    Object.assign(spinner.style, spinnerStyles);
    return spinner;
}
function createElement(tag, className, styles, textContent, id) {
    const element = document.createElement(tag);
    element.className = className;
    Object.assign(element.style, styles);
    if (textContent) {
        element.textContent = textContent;
    }
    if (id) {
        element.id = id;
    }
    return element;
}
const TEST_START = 'or_uxt_test_start';
const TASK_IND = 'or_uxt_task_index';
const SESSION_ID = 'or_uxt_session_id';
const TEST_ID = 'or_uxt_test_id';

class SignalManager {
    constructor(ingestPoint, getTimestamp, token, testId, storageKey, setStorageKey, removeStorageKey, getStorageKey, getSessionId) {
        this.ingestPoint = ingestPoint;
        this.getTimestamp = getTimestamp;
        this.token = token;
        this.testId = testId;
        this.storageKey = storageKey;
        this.setStorageKey = setStorageKey;
        this.removeStorageKey = removeStorageKey;
        this.getStorageKey = getStorageKey;
        this.getSessionId = getSessionId;
        this.durations = {
            testStart: 0,
            tasks: [],
        };
        this.getDurations = () => {
            return this.durations;
        };
        this.setDurations = (durations) => {
            this.durations.testStart = durations.testStart;
            this.durations.tasks = durations.tasks;
        };
        this.signalTask = (taskId, status, taskAnswer) => {
            if (!taskId)
                return console.error('User Testing: No Task ID Given');
            const taskStart = this.durations.tasks.find((t) => t.taskId === taskId);
            const timestamp = this.getTimestamp();
            const duration = taskStart ? timestamp - taskStart.started : 0;
            return fetch(`${this.ingestPoint}/v1/web/uxt/signals/task`, {
                method: 'POST',
                headers: {
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    Authorization: `Bearer ${this.token}`,
                },
                body: JSON.stringify({
                    testId: this.testId,
                    taskId,
                    status,
                    duration,
                    timestamp,
                    taskAnswer,
                }),
            });
        };
        this.signalTest = (status) => {
            const timestamp = this.getTimestamp();
            if (status === 'begin' && this.testId) {
                const sessionId = this.getSessionId();
                this.setStorageKey(SESSION_ID, sessionId);
                this.setStorageKey(this.storageKey, this.testId.toString());
                this.setStorageKey(TEST_START, timestamp.toString());
            }
            else {
                this.removeStorageKey(this.storageKey);
                this.removeStorageKey(TASK_IND);
                this.removeStorageKey(TEST_START);
            }
            const start = this.durations.testStart || timestamp;
            const duration = timestamp - start;
            return fetch(`${this.ingestPoint}/v1/web/uxt/signals/test`, {
                method: 'POST',
                headers: {
                    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                    Authorization: `Bearer ${this.token}`,
                },
                body: JSON.stringify({
                    testId: this.testId,
                    status,
                    duration,
                    timestamp,
                }),
            });
        };
        const possibleStart = this.getStorageKey(TEST_START);
        if (possibleStart) {
            this.durations.testStart = parseInt(possibleStart, 10);
        }
    }
}

class UserTestManager {
    constructor(app, storageKey) {
        this.app = app;
        this.storageKey = storageKey;
        this.bg = createElement('div', 'bg', bgStyle, undefined, '__or_ut_bg');
        this.container = createElement('div', 'container', containerStyle, undefined, '__or_ut_ct');
        this.widgetGuidelinesVisible = true;
        this.widgetTasksVisible = false;
        this.widgetVisible = true;
        this.isActive = false;
        this.descriptionSection = null;
        this.taskSection = null;
        this.endSection = null;
        this.stopButton = null;
        this.stopButtonContainer = null;
        this.test = null;
        this.testId = null;
        this.signalManager = null;
        this.getTest = (id, token, inProgress) => {
            this.testId = id;
            const ingest = this.app.options.ingestPoint;
            return fetch(`${ingest}/v1/web/uxt/test/${id}`, {
                headers: {
                    Authorization: `Bearer ${token}`,
                },
            })
                .then((res) => res.json())
                .then(({ test }) => {
                this.isActive = true;
                this.test = test;
                this.signalManager = new SignalManager(this.app.options.ingestPoint, () => this.app.timestamp(), token, id, this.storageKey, (k, v) => this.app.localStorage.setItem(k, v), (k) => this.app.localStorage.removeItem(k), (k) => this.app.localStorage.getItem(k), () => this.app.getSessionID());
                this.createGreeting(test.title, test.reqMic, test.reqCamera);
                if (inProgress) {
                    if (test.reqMic || test.reqCamera) {
                        void this.userRecorder.startRecording(30, Quality.Standard, test.reqMic, test.reqCamera);
                    }
                    this.showWidget(test.description, test.tasks, true);
                    this.showTaskSection();
                }
            })
                .then(() => id)
                .catch((err) => {
                console.log('OR: Error fetching test', err);
            });
        };
        this.hideTaskSection = () => false;
        this.showTaskSection = () => true;
        this.collapseWidget = () => false;
        this.removeGreeting = () => false;
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this.toggleDescriptionVisibility = () => { };
        this.currentTaskIndex = 0;
        this.userRecorder = new Recorder(app);
        const sessionId = this.app.getSessionID();
        const savedSessionId = this.app.localStorage.getItem(SESSION_ID);
        if (sessionId !== savedSessionId) {
            this.app.localStorage.removeItem(this.storageKey);
            this.app.localStorage.removeItem(SESSION_ID);
            this.app.localStorage.removeItem(TEST_ID);
            this.app.localStorage.removeItem(TASK_IND);
            this.app.localStorage.removeItem(TEST_START);
        }
        const taskIndex = this.app.localStorage.getItem(TASK_IND);
        if (taskIndex) {
            this.currentTaskIndex = parseInt(taskIndex, 10);
        }
    }
    getTestId() {
        return this.testId;
    }
    createGreeting(title, micRequired, cameraRequired) {
        const titleElement = createElement('div', 'title', titleStyle, title);
        const descriptionElement = createElement('div', 'description', descriptionStyle, `Welcome, you're here to help us improve, not to be judged. Your insights matter!\n
 We're recording this browser tab to learn from your experience.
 Please enable mic and camera if asked, to give us a complete picture.`);
        const buttonElement = createElement('div', 'button', buttonStyle, 'Read guidelines to begin');
        this.removeGreeting = () => {
            // this.container.innerHTML = ''
            if (micRequired || cameraRequired) {
                void this.userRecorder.startRecording(30, Quality.Standard, micRequired, cameraRequired);
            }
            this.container.removeChild(buttonElement);
            this.container.removeChild(descriptionElement);
            this.container.removeChild(titleElement);
            return false;
        };
        buttonElement.onclick = () => {
            this.removeGreeting();
            const durations = this.signalManager?.getDurations();
            if (durations && this.signalManager) {
                durations.testStart = this.app.timestamp();
                this.signalManager.setDurations(durations);
            }
            void this.signalManager?.signalTest('begin');
            this.container.style.fontFamily = `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
            Object.assign(this.container.style, containerWidgetStyle);
            this.showWidget(this.test?.guidelines || '', this.test?.tasks || []);
        };
        this.container.append(titleElement, descriptionElement, buttonElement);
        this.bg.appendChild(this.container);
        document.body.appendChild(this.bg);
    }
    showWidget(guidelines, tasks, inProgress) {
        this.container.innerHTML = '';
        Object.assign(this.bg.style, {
            position: 'fixed',
            zIndex: 99999999999999,
            right: '8px',
            left: 'unset',
            width: 'fit-content',
            top: '8px',
            height: 'fit-content',
            background: 'unset',
            display: 'unset',
            alignItems: 'unset',
            justifyContent: 'unset',
        });
        // Create title section
        const titleSection = this.createTitleSection();
        this.container.style.fontFamily = `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
        Object.assign(this.container.style, containerWidgetStyle);
        const descriptionSection = this.createDescriptionSection(guidelines);
        const tasksSection = this.createTasksSection(tasks);
        const stopButton = createElement('div', 'stop_bn_or', stopWidgetStyle, 'Abort Session');
        const stopContainer = createElement('div', 'stop_ct_or', { fontSize: '13px!important' });
        stopContainer.style.fontSize = '13px';
        stopContainer.append(stopButton);
        this.container.append(titleSection, descriptionSection, tasksSection, stopContainer);
        this.taskSection = tasksSection;
        this.descriptionSection = descriptionSection;
        this.stopButton = stopButton;
        this.stopButtonContainer = stopContainer;
        stopButton.onclick = () => {
            this.userRecorder.discard();
            void this.signalManager?.signalTest('skipped');
            document.body.removeChild(this.bg);
            window.close();
        };
        if (!inProgress) {
            this.hideTaskSection();
        }
        else {
            this.toggleDescriptionVisibility();
        }
    }
    createTitleSection() {
        const title = createElement('div', 'title', titleWidgetStyle);
        const leftIcon = generateGrid();
        const titleText = createElement('div', 'title_text', {
            maxWidth: '19rem',
            overflow: 'hidden',
            textOverflow: 'ellipsis',
            width: '100%',
            fontSize: 16,
            lineHeight: 'auto',
            cursor: 'pointer',
        }, this.test?.title);
        const rightIcon = generateChevron();
        title.append(leftIcon, titleText, rightIcon);
        const toggleWidget = (isVisible) => {
            this.widgetVisible = isVisible;
            this.container.style.fontFamily = `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
            Object.assign(this.container.style, this.widgetVisible
                ? containerWidgetStyle
                : { border: 'none', background: 'none', padding: 0 });
            if (this.taskSection) {
                Object.assign(this.taskSection.style, this.widgetVisible ? descriptionWidgetStyle : { display: 'none' });
            }
            if (this.descriptionSection) {
                Object.assign(this.descriptionSection.style, this.widgetVisible ? descriptionWidgetStyle : { display: 'none' });
            }
            if (this.endSection) {
                Object.assign(this.endSection.style, this.widgetVisible ? descriptionWidgetStyle : { display: 'none' });
            }
            if (this.stopButton) {
                Object.assign(this.stopButton.style, this.widgetVisible ? stopWidgetStyle : { display: 'none' });
            }
            return isVisible;
        };
        const collapseWidget = () => {
            Object.assign(rightIcon.style, {
                transform: this.widgetVisible ? 'rotate(0deg)' : 'rotate(180deg)',
            });
            toggleWidget(!this.widgetVisible);
        };
        titleText.onclick = collapseWidget;
        rightIcon.onclick = collapseWidget;
        attachDND(this.bg, leftIcon);
        this.collapseWidget = () => toggleWidget(false);
        return title;
    }
    createDescriptionSection(guidelines) {
        const section = createElement('div', 'description_section_or', descriptionWidgetStyle);
        const titleContainer = createElement('div', 'description_s_title_or', sectionTitleStyle);
        const title = createElement('div', 'title', {
            fontSize: 13,
            fontWeight: 500,
            lineHeight: 'auto',
        }, 'Introduction & Guidelines');
        const icon = createElement('div', 'icon', symbolIcon, '-');
        const content = createElement('div', 'content', contentStyle);
        const descriptionC = createElement('div', 'text_description', {
            maxHeight: '250px',
            overflowY: 'auto',
            whiteSpace: 'pre-wrap',
            fontSize: 13,
            color: '#454545',
            lineHeight: 'auto',
        });
        descriptionC.innerHTML = guidelines;
        const button = createElement('div', 'button_begin_or', buttonWidgetStyle, 'Begin Test');
        titleContainer.append(title, icon);
        content.append(descriptionC, button);
        section.append(titleContainer, content);
        const toggleDescriptionVisibility = () => {
            this.widgetGuidelinesVisible = !this.widgetGuidelinesVisible;
            icon.textContent = this.widgetGuidelinesVisible ? '-' : '+';
            Object.assign(content.style, this.widgetGuidelinesVisible ? contentStyle : { display: 'none' });
        };
        titleContainer.onclick = toggleDescriptionVisibility;
        this.toggleDescriptionVisibility = () => {
            this.widgetGuidelinesVisible = false;
            icon.textContent = this.widgetGuidelinesVisible ? '-' : '+';
            Object.assign(content.style, this.widgetGuidelinesVisible ? contentStyle : { display: 'none' });
            content.removeChild(button);
        };
        button.onclick = () => {
            toggleDescriptionVisibility();
            if (this.test) {
                const durations = this.signalManager?.getDurations();
                const taskDurationInd = durations
                    ? durations.tasks.findIndex((t) => this.test && t.taskId === this.test.tasks[0].task_id)
                    : null;
                if (durations && taskDurationInd === -1) {
                    durations.tasks.push({
                        taskId: this.test.tasks[0].task_id,
                        started: this.app.timestamp(),
                    });
                    this.signalManager?.setDurations(durations);
                }
                void this.signalManager?.signalTask(this.test.tasks[0].task_id, 'begin');
            }
            this.showTaskSection();
            content.removeChild(button);
        };
        return section;
    }
    createTasksSection(tasks) {
        this.container.style.fontFamily = `-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"`;
        Object.assign(this.container.style, containerWidgetStyle);
        const section = createElement('div', 'task_section_or', descriptionWidgetStyle);
        const titleContainer = createElement('div', 'description_t_title_or', sectionTitleStyle);
        const title = createElement('div', 'title', {
            fontSize: '13px',
            fontWeight: '500',
            lineHeight: 'auto',
        }, 'Tasks');
        const icon = createElement('div', 'icon', symbolIcon, '-');
        const content = createElement('div', 'content', contentStyle);
        const pagination = createElement('div', 'pagination', paginationStyle);
        // const leftArrow = createElement('span', 'leftArrow', {}, '<')
        // const rightArrow = createElement('span', 'rightArrow', {}, '>')
        const taskCard = createElement('div', 'taskCard', taskDescriptionCard);
        const taskText = createElement('div', 'taskText', taskTextStyle);
        const taskDescription = createElement('div', 'taskDescription', taskDescriptionStyle);
        const taskButtons = createElement('div', 'taskButtons', taskButtonsRow);
        const inputTitle = createElement('div', 'taskText', taskTextStyle);
        inputTitle.textContent = 'Your answer';
        const inputArea = createElement('textarea', 'taskDescription', {
            resize: 'vertical',
        });
        const inputContainer = createElement('div', 'inputArea', taskDescriptionCard);
        inputContainer.append(inputTitle, inputArea);
        const closePanelButton = createElement('div', 'closePanelButton', taskButtonStyle, 'Collapse Panel');
        const nextButton = createElement('div', 'nextButton', taskButtonBorderedStyle, 'Done, Next');
        titleContainer.append(title, icon);
        taskCard.append(taskText, taskDescription);
        taskButtons.append(closePanelButton, nextButton);
        content.append(pagination, taskCard, inputContainer, taskButtons);
        section.append(titleContainer, content);
        const updateTaskContent = () => {
            const task = tasks[this.currentTaskIndex];
            taskText.textContent = task.title;
            taskDescription.textContent = task.description;
            if (task.allow_typing) {
                inputContainer.style.display = 'flex';
            }
            else {
                inputContainer.style.display = 'none';
            }
        };
        // pagination.appendChild(leftArrow)
        tasks.forEach((_, index) => {
            const pageNumber = createElement('span', `or_task_${index}`, {
                outline: '1px solid #efefef',
                fontSize: '13px',
                height: '24px',
                width: '24px',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                borderRadius: '6.25em',
            }, (index + 1).toString());
            pageNumber.id = `or_task_${index}`;
            pagination.append(pageNumber);
        });
        // pagination.appendChild(rightArrow)
        const toggleTasksVisibility = () => {
            this.widgetTasksVisible = !this.widgetTasksVisible;
            icon.textContent = this.widgetTasksVisible ? '-' : '+';
            Object.assign(content.style, this.widgetTasksVisible ? contentStyle : { display: 'none' });
        };
        this.hideTaskSection = () => {
            icon.textContent = '+';
            Object.assign(content.style, {
                display: 'none',
            });
            this.widgetTasksVisible = false;
            return false;
        };
        this.showTaskSection = () => {
            icon.textContent = '-';
            Object.assign(content.style, contentStyle);
            this.widgetTasksVisible = true;
            return true;
        };
        const highlightActive = () => {
            const activeTaskEl = document.getElementById(`or_task_${this.currentTaskIndex}`);
            if (activeTaskEl) {
                Object.assign(activeTaskEl.style, taskNumberActive);
            }
            for (let i = 0; i < this.currentTaskIndex; i++) {
                const taskEl = document.getElementById(`or_task_${i}`);
                if (taskEl) {
                    Object.assign(taskEl.style, taskNumberDone);
                }
            }
        };
        titleContainer.onclick = toggleTasksVisibility;
        closePanelButton.onclick = this.collapseWidget;
        nextButton.onclick = () => {
            const textAnswer = tasks[this.currentTaskIndex].allow_typing ? inputArea.value : undefined;
            inputArea.value = '';
            void this.signalManager?.signalTask(tasks[this.currentTaskIndex].task_id, 'done', textAnswer);
            if (this.currentTaskIndex < tasks.length - 1) {
                this.currentTaskIndex++;
                updateTaskContent();
                const durations = this.signalManager?.getDurations();
                if (durations &&
                    durations.tasks.findIndex((t) => t.taskId === tasks[this.currentTaskIndex].task_id) === -1) {
                    durations.tasks.push({
                        taskId: tasks[this.currentTaskIndex].task_id,
                        started: this.app.timestamp(),
                    });
                    this.signalManager?.setDurations(durations);
                }
                void this.signalManager?.signalTask(tasks[this.currentTaskIndex].task_id, 'begin');
                highlightActive();
            }
            else {
                this.showEndSection();
            }
            this.app.localStorage.setItem('or_uxt_task_index', this.currentTaskIndex.toString());
        };
        setTimeout(() => {
            const firstTaskEl = document.getElementById('or_task_0');
            if (firstTaskEl) {
                Object.assign(firstTaskEl.style, taskNumberActive);
            }
            updateTaskContent();
            highlightActive();
        }, 1);
        return section;
    }
    showEndSection() {
        let isLoading = true;
        void this.signalManager?.signalTest('done');
        const section = createElement('div', 'end_section_or', endSectionStyle);
        const title = createElement('div', 'end_title_or', {
            fontSize: '1.25rem',
            fontWeight: '500',
        }, 'Thank you! ');
        const description = createElement('div', 'end_description_or', {}, this.test?.conclusion ??
            'Thank you for participating in our usability test. Your feedback has been captured and will be used to enhance our website. \n' +
                '\n' +
                'We appreciate your time and valuable input.');
        const button = createElement('div', 'end_button_or', buttonWidgetStyle, 'Submitting Feedback');
        const spinner = createSpinner();
        button.appendChild(spinner);
        if (this.test?.reqMic || this.test?.reqCamera) {
            void this.userRecorder
                .sendToAPI()
                .then(() => {
                button.removeChild(spinner);
                button.textContent = 'End Session';
                isLoading = false;
            })
                .catch((err) => {
                console.error(err);
                button.removeChild(spinner);
                button.textContent = 'End Session';
                isLoading = false;
            });
        }
        else {
            button.removeChild(spinner);
            button.textContent = 'End Session';
            isLoading = false;
        }
        if (this.taskSection) {
            this.container.removeChild(this.taskSection);
        }
        if (this.descriptionSection) {
            this.container.removeChild(this.descriptionSection);
        }
        if (this.stopButton && this.stopButtonContainer) {
            this.container.removeChild(this.stopButtonContainer);
        }
        button.onclick = () => {
            if (isLoading)
                return;
            window.close();
            document.body.removeChild(this.bg);
        };
        section.append(title, description, button);
        this.endSection = section;
        this.container.append(section);
    }
}

//@ts-ignore
function isNode(sth) {
    return !!sth && sth.nodeType != null;
}
function isSVGElement(node) {
    return (node.namespaceURI === 'http://www.w3.org/2000/svg' || node.localName === 'svg');
}
function isUseElement(node) {
    return node.localName === 'use';
}
function isElementNode(node) {
    return node.nodeType === Node.ELEMENT_NODE;
}
function isCommentNode(node) {
    return node.nodeType === Node.COMMENT_NODE;
}
function isTextNode(node) {
    return node.nodeType === Node.TEXT_NODE;
}
function isDocument(node) {
    return node.nodeType === Node.DOCUMENT_NODE;
}
function isRootNode(node) {
    return node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
}
function hasTag(el, tagName) {
    // @ts-ignore
    return el.localName === tagName;
}

class CanvasRecorder {
    constructor(app, options) {
        this.app = app;
        this.options = options;
        this.snapshots = {};
        this.intervals = [];
        this.restartTracking = () => {
            this.clear();
            this.app.nodes.scanTree(this.captureCanvas);
        };
        this.captureCanvas = (node) => {
            const id = this.app.nodes.getID(node);
            if (!id || !hasTag(node, 'canvas')) {
                return;
            }
            const isIgnored = this.app.sanitizer.isObscured(id) || this.app.sanitizer.isHidden(id);
            if (isIgnored || !hasTag(node, 'canvas') || this.snapshots[id]) {
                return;
            }
            const observer = new IntersectionObserver((entries) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        if (entry.target) {
                            if (this.snapshots[id] && this.snapshots[id].createdAt) {
                                this.snapshots[id].paused = false;
                            }
                            else {
                                this.recordCanvas(entry.target, id);
                            }
                            /**
                             * We can switch this to start observing when element is in the view
                             * but otherwise right now we're just pausing when it's not
                             * just to save some bandwidth and space on backend
                             * */
                            // observer.unobserve(entry.target)
                        }
                        else {
                            if (this.snapshots[id]) {
                                this.snapshots[id].paused = true;
                            }
                        }
                    }
                });
            });
            observer.observe(node);
        };
        this.recordCanvas = (node, id) => {
            const ts = this.app.timestamp();
            this.snapshots[id] = {
                images: [],
                createdAt: ts,
                paused: false,
                dummy: document.createElement('canvas'),
            };
            const canvasMsg = CanvasNode(id.toString(), ts);
            this.app.send(canvasMsg);
            const captureFn = (canvas) => {
                captureSnapshot(canvas, this.options.quality, this.snapshots[id].dummy, this.options.fixedScaling, this.fileExt, (blob) => {
                    if (!blob)
                        return;
                    if (!this.snapshots[id]) {
                        return this.app.debug.warn('Canvas not present in snapshots after capture:', this.snapshots, id);
                    }
                    this.snapshots[id].images.push({ id: this.app.timestamp(), data: blob });
                    if (this.snapshots[id].images.length > 9) {
                        this.sendSnaps(this.snapshots[id].images, id, this.snapshots[id].createdAt);
                        this.snapshots[id].images = [];
                    }
                });
            };
            const int = setInterval(() => {
                const cid = this.app.nodes.getID(node);
                const canvas = cid ? this.app.nodes.getNode(cid) : undefined;
                if (!this.snapshots[id]) {
                    this.app.debug.log('Canvas is not present in {snapshots}');
                    clearInterval(int);
                    return;
                }
                if (!canvas || !hasTag(canvas, 'canvas') || canvas !== node) {
                    this.app.debug.log('Canvas element not in sync', canvas, node);
                    clearInterval(int);
                    return;
                }
                else {
                    if (!this.snapshots[id].paused) {
                        if (this.options.useAnimationFrame) {
                            requestAnimationFrame(() => {
                                captureFn(canvas);
                            });
                        }
                        else {
                            captureFn(canvas);
                        }
                    }
                }
            }, this.interval);
            this.intervals.push(int);
        };
        this.fileExt = options.fileExt ?? 'webp';
        this.interval = 1000 / options.fps;
    }
    startTracking() {
        setTimeout(() => {
            this.app.nodes.scanTree(this.captureCanvas);
            this.app.nodes.attachNodeCallback(this.captureCanvas);
        }, 250);
    }
    sendSnaps(images, canvasId, createdAt) {
        if (Object.keys(this.snapshots).length === 0) {
            return;
        }
        const formData = new FormData();
        images.forEach((snapshot) => {
            const blob = snapshot.data;
            if (!blob)
                return;
            formData.append('snapshot', blob, `${createdAt}_${canvasId}_${snapshot.id}.${this.fileExt}`);
            if (this.options.isDebug) {
                saveImageData(blob, `${createdAt}_${canvasId}_${snapshot.id}.${this.fileExt}`);
            }
        });
        const initRestart = () => {
            this.app.debug.log('Restarting tracker; token expired');
            this.app.stop(false);
            setTimeout(() => {
                void this.app.start({}, true);
            }, 250);
        };
        fetch(this.app.options.ingestPoint + '/v1/web/images', {
            method: 'POST',
            headers: {
                Authorization: `Bearer ${this.app.session.getSessionToken() ?? ''}`,
            },
            body: formData,
        })
            .then((r) => {
            if (r.status === 401) {
                return initRestart();
            }
            return true;
        })
            .catch((e) => {
            this.app.debug.error('error saving canvas', e);
        });
    }
    clear() {
        this.intervals.forEach((int) => clearInterval(int));
        this.snapshots = {};
    }
}
const qualityInt = {
    low: 0.35,
    medium: 0.55,
    high: 0.8,
};
function captureSnapshot(canvas, quality = 'medium', dummy, fixedScaling = false, fileExt, onBlob) {
    const imageFormat = `image/${fileExt}`;
    if (fixedScaling) {
        const canvasScaleRatio = window.devicePixelRatio || 1;
        dummy.width = canvas.width / canvasScaleRatio;
        dummy.height = canvas.height / canvasScaleRatio;
        const ctx = dummy.getContext('2d');
        if (!ctx) {
            return '';
        }
        ctx.clearRect(0, 0, dummy.width, dummy.height);
        ctx.drawImage(canvas, 0, 0, dummy.width, dummy.height);
        dummy.toBlob(onBlob, imageFormat, qualityInt[quality]);
    }
    else {
        canvas.toBlob(onBlob, imageFormat, qualityInt[quality]);
    }
}
function saveImageData(imageDataBlob, name) {
    const imageDataUrl = URL.createObjectURL(imageDataBlob);
    const link = document.createElement('a');
    link.href = imageDataUrl;
    link.download = name;
    link.style.display = 'none';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

const LogLevel = {
    Verbose: 5,
    Log: 4,
    Warnings: 3,
    Errors: 2,
    Silent: 0,
};
class Logger {
    constructor(debugLevel = LogLevel.Silent) {
        this.shouldLog = (level) => {
            return this.level >= level;
        };
        this.info = (...args) => {
            if (this.shouldLog(LogLevel.Verbose)) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                console.info(...args);
            }
        };
        this.log = (...args) => {
            if (this.shouldLog(LogLevel.Log)) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                console.log(...args);
            }
        };
        this.warn = (...args) => {
            if (this.shouldLog(LogLevel.Warnings)) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                console.warn(...args);
            }
        };
        this.error = (...args) => {
            if (this.shouldLog(LogLevel.Errors)) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                console.error(...args);
            }
        };
        this.level = debugLevel;
    }
}

const SECOND = 1000;
function processMapInBatches(map, batchSize, processBatchCallback) {
    const iterator = map.entries();
    function processNextBatch() {
        const batch = [];
        let result = iterator.next();
        while (!result.done && batch.length < batchSize) {
            batch.push(result.value);
            result = iterator.next();
        }
        if (batch.length > 0) {
            batch.forEach(([_, node]) => {
                if (node) {
                    processBatchCallback(node);
                }
            });
            setTimeout(processNextBatch, 50);
        }
    }
    processNextBatch();
}
function isNodeStillActive(node) {
    try {
        if (!node.isConnected) {
            return [false, 'not connected'];
        }
        const nodeIsDocument = node.nodeType === Node.DOCUMENT_NODE;
        const nodeWindow = nodeIsDocument
            ? node.defaultView
            : node.ownerDocument?.defaultView;
        const ownerDoc = nodeIsDocument ? node : node.ownerDocument;
        if (!nodeWindow) {
            return [false, 'no window'];
        }
        if (nodeWindow.closed) {
            return [false, 'window closed'];
        }
        if (!ownerDoc?.documentElement.isConnected) {
            return [false, 'documentElement not connected'];
        }
        return [true, 'ok'];
    }
    catch (e) {
        return [false, e];
    }
}
const defaults = {
    interval: SECOND * 30,
    batchSize: 2500,
    enabled: true,
};
class Maintainer {
    constructor(nodes, unregisterNode, options) {
        this.nodes = nodes;
        this.unregisterNode = unregisterNode;
        this.start = () => {
            if (!this.options.enabled) {
                return;
            }
            this.stop();
            this.interval = setInterval(() => {
                processMapInBatches(this.nodes, this.options.batchSize, (node) => {
                    const isActive = isNodeStillActive(node)[0];
                    if (!isActive) {
                        this.unregisterNode(node);
                    }
                });
            }, this.options.interval);
        };
        this.stop = () => {
            if (this.interval) {
                clearInterval(this.interval);
            }
        };
        this.options = { ...defaults, ...options };
    }
}

class Nodes {
    constructor(params) {
        this.nodes = new Map();
        this.totalNodeAmount = 0;
        this.nodeCallbacks = [];
        this.elementListeners = new Map();
        this.nextNodeId = 0;
        // Attached once per Tracker instance
        this.attachNodeCallback = (nodeCallback) => {
            return this.nodeCallbacks.push(nodeCallback);
        };
        this.scanTree = (cb) => {
            this.nodes.forEach((node) => (node ? cb(node) : undefined));
        };
        this.attachNodeListener = (node, type, listener, useCapture = true) => {
            const id = this.getID(node);
            if (id === undefined) {
                return;
            }
            createEventListener(node, type, listener, useCapture, this.forceNgOff);
            let listeners = this.elementListeners.get(id);
            if (listeners === undefined) {
                listeners = [];
                this.elementListeners.set(id, listeners);
            }
            listeners.push([type, listener, useCapture]);
        };
        this.unregisterNode = (node) => {
            const id = node[this.node_id];
            if (id !== undefined) {
                node[this.node_id] = undefined;
                delete node[this.node_id];
                this.nodes.delete(id);
                const listeners = this.elementListeners.get(id);
                if (listeners !== undefined) {
                    this.elementListeners.delete(id);
                    listeners.forEach((listener) => deleteEventListener(node, listener[0], listener[1], listener[2], this.forceNgOff));
                }
                this.totalNodeAmount--;
            }
            return id;
        };
        this.node_id = params.node_id;
        this.forceNgOff = params.forceNgOff;
        this.maintainer = new Maintainer(this.nodes, this.unregisterNode, params.maintainer);
        this.maintainer.start();
    }
    syntheticMode(frameOrder) {
        const maxSafeNumber = Number.MAX_SAFE_INTEGER;
        const placeholderSize = 99999999;
        const nextFrameId = placeholderSize * frameOrder;
        // I highly doubt that this will ever happen,
        // but it will be easier to debug if it does
        if (nextFrameId > maxSafeNumber) {
            throw new Error('Placeholder id overflow');
        }
        this.nextNodeId = nextFrameId;
    }
    registerNode(node) {
        let id = node[this.node_id];
        const isNew = id === undefined;
        if (isNew) {
            id = this.nextNodeId;
            this.totalNodeAmount++;
            this.nextNodeId++;
            this.nodes.set(id, node);
            node[this.node_id] = id;
        }
        return [id, isNew];
    }
    cleanTree() {
        // sadly we keep empty items in array here resulting in some memory still being used
        // but its still better than keeping dead nodes or undef elements
        // plus we keep our index positions for new/alive nodes
        // performance test: 3ms for 30k nodes with 17k dead ones
        for (const [_, node] of this.nodes) {
            if (node && !document.contains(node)) {
                this.unregisterNode(node);
            }
        }
    }
    callNodeCallbacks(node, isStart) {
        this.nodeCallbacks.forEach((cb) => cb(node, isStart));
    }
    getID(node) {
        if (!node)
            return undefined;
        return node[this.node_id];
    }
    getNode(id) {
        return this.nodes.get(id);
    }
    getNodeCount() {
        return this.totalNodeAmount;
    }
    clear() {
        for (const [_, node] of this.nodes) {
            if (node) {
                this.unregisterNode(node);
            }
        }
        this.nextNodeId = 0;
        this.nodes.clear();
    }
}

const iconCache = {};
const svgUrlCache = {};
async function parseUseEl(useElement, mode, domParser) {
    try {
        const href = useElement.getAttribute('xlink:href') || useElement.getAttribute('href');
        if (!href) {
            console.debug('Openreplay: xlink:href or href not found on <use>.');
            return;
        }
        let [url, symbolId] = href.split('#');
        // happens if svg spritemap is local, fastest case for us
        if (!url && symbolId) {
            const symbol = document.querySelector(href);
            if (symbol) {
                const inlineSvg = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="${symbol.getAttribute('viewBox') || '0 0 24 24'}">
          ${symbol.innerHTML}
        </svg>
      `.trim();
                iconCache[symbolId] = inlineSvg;
                return inlineSvg;
            }
            else {
                console.warn('Openreplay: Sprite symbol not found in the document.');
                return;
            }
        }
        if (!url && !symbolId) {
            console.warn('Openreplay: Invalid xlink:href or href found on <use>.');
            return;
        }
        if (iconCache[symbolId]) {
            return iconCache[symbolId];
        }
        let svgDoc;
        if (svgUrlCache[url]) {
            if (svgUrlCache[url] === 1) {
                await new Promise((resolve) => {
                    let tries = 0;
                    const interval = setInterval(() => {
                        if (tries > 100) {
                            clearInterval(interval);
                            resolve(false);
                        }
                        if (svgUrlCache[url] !== 1) {
                            svgDoc = svgUrlCache[url];
                            clearInterval(interval);
                            resolve(true);
                        }
                        else {
                            tries++;
                        }
                    }, 100);
                });
            }
            else {
                svgDoc = svgUrlCache[url] ?? `<svg xmlns="http://www.w3.org/2000/svg"></svg>`;
            }
        }
        else {
            svgUrlCache[url] = 1;
            const response = await fetch(url);
            const svgText = await response.text();
            svgDoc = domParser.parseFromString(svgText, 'image/svg+xml');
            svgUrlCache[url] = svgDoc;
        }
        // @ts-ignore
        const symbol = svgDoc.getElementById(symbolId);
        if (!symbol) {
            console.debug('Openreplay: Symbol not found in SVG.');
            return '';
        }
        if (mode === 'inline') ;
        if (mode === 'svgtext') {
            const inlineSvg = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="${symbol.getAttribute('viewBox') || '0 0 24 24'}">
          ${symbol.innerHTML}
        </svg>
      `.trim();
            iconCache[symbolId] = inlineSvg;
            return inlineSvg;
        }
        if (mode === 'dataurl') ;
        console.debug(`Openreplay: Unknown mode: ${mode}. Use "inline" or "dataurl".`);
    }
    catch (error) {
        console.error('Openreplay: Error processing <use> element:', error);
    }
}
function isIgnored(node) {
    if (isCommentNode(node)) {
        return true;
    }
    if (isTextNode(node)) {
        return false;
    }
    if (!isElementNode(node)) {
        return true;
    }
    const tag = node.tagName.toUpperCase();
    if (tag === 'LINK') {
        const rel = node.getAttribute('rel');
        const as = node.getAttribute('as');
        return !(rel?.includes('stylesheet') || as === 'style' || as === 'font');
    }
    return (tag === 'SCRIPT' || tag === 'NOSCRIPT' || tag === 'META' || tag === 'TITLE' || tag === 'BASE');
}
function isObservable(node) {
    if (isRootNode(node)) {
        return true;
    }
    return !isIgnored(node);
}
/*
  TODO:
    - fix unbinding logic + send all removals first (ensure sequence is correct)
    - use document as a 0-node in the upper context (should be updated in player at first)
*/
var RecentsType;
(function (RecentsType) {
    RecentsType[RecentsType["New"] = 0] = "New";
    RecentsType[RecentsType["Removed"] = 1] = "Removed";
    RecentsType[RecentsType["Changed"] = 2] = "Changed";
})(RecentsType || (RecentsType = {}));
class Observer {
    constructor(app, isTopContext = false, options = { disableSprites: false }) {
        this.app = app;
        this.isTopContext = isTopContext;
        this.commited = [];
        this.recents = new Map();
        this.indexes = [];
        this.attributesMap = new Map();
        this.textSet = new Set();
        this.disableSprites = false;
        this.domParser = new DOMParser();
        this.disableSprites = options.disableSprites;
        this.observer = createMutationObserver(this.app.safe((mutations) => {
            for (const mutation of mutations) {
                // mutations order is sequential
                const target = mutation.target;
                const type = mutation.type;
                if (!isObservable(target)) {
                    continue;
                }
                if (type === 'childList') {
                    for (let i = 0; i < mutation.removedNodes.length; i++) {
                        // Should be the same as bindTree(mutation.removedNodes[i]), but logic needs to be be untied
                        if (isObservable(mutation.removedNodes[i])) {
                            this.bindNode(mutation.removedNodes[i]);
                        }
                    }
                    for (let i = 0; i < mutation.addedNodes.length; i++) {
                        this.bindTree(mutation.addedNodes[i]);
                    }
                    continue;
                }
                const id = this.app.nodes.getID(target);
                if (id === undefined) {
                    continue;
                }
                if (!this.recents.has(id)) {
                    this.recents.set(id, RecentsType.Changed); // TODO only when altered
                }
                if (type === 'attributes') {
                    const name = mutation.attributeName;
                    if (name === null) {
                        continue;
                    }
                    let attr = this.attributesMap.get(id);
                    if (attr === undefined) {
                        this.attributesMap.set(id, (attr = new Set()));
                    }
                    attr.add(name);
                    continue;
                }
                if (type === 'characterData') {
                    this.textSet.add(id);
                    continue;
                }
            }
            this.commitNodes();
        }), this.app.options.forceNgOff);
    }
    clear() {
        this.commited.length = 0;
        this.recents.clear();
        this.indexes.length = 1;
        this.attributesMap.clear();
        this.textSet.clear();
    }
    /**
     * EXPERIMENTAL: Unbinds the removed nodes in case of iframe src change.
     *
     * right now, we're relying on nodes.maintainer
     */
    handleIframeSrcChange(iframe) {
        const oldContentDocument = iframe.contentDocument;
        if (oldContentDocument) {
            const id = this.app.nodes.getID(oldContentDocument);
            if (id !== undefined) {
                const walker = document.createTreeWalker(oldContentDocument, NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT, {
                    acceptNode: (node) => isIgnored(node) || this.app.nodes.getID(node) === undefined
                        ? NodeFilter.FILTER_REJECT
                        : NodeFilter.FILTER_ACCEPT,
                }, 
                // @ts-ignore
                false);
                let removed = 0;
                const totalBeforeRemove = this.app.nodes.getNodeCount();
                while (walker.nextNode()) {
                    if (!iframe.contentDocument.contains(walker.currentNode)) {
                        removed += 1;
                        this.app.nodes.unregisterNode(walker.currentNode);
                    }
                }
                const removedPercent = Math.floor((removed / totalBeforeRemove) * 100);
                if (removedPercent > 30) {
                    this.app.send(UnbindNodes(removedPercent));
                }
            }
        }
    }
    sendNodeAttribute(id, node, name, value) {
        if (isSVGElement(node)) {
            if (name.substring(0, 6) === 'xlink:') {
                name = name.substring(6);
            }
            if (value === null) {
                this.app.send(RemoveNodeAttribute(id, name));
            }
            if (isUseElement(node) && name === 'href' && !this.disableSprites) {
                parseUseEl(node, 'svgtext', this.domParser)
                    .then((svgData) => {
                    if (svgData) {
                        this.app.send(SetNodeAttribute(id, name, `_$OPENREPLAY_SPRITE$_${svgData}`));
                    }
                })
                    .catch((e) => {
                    console.error('Openreplay: Error parsing <use> element:', e);
                });
                return;
            }
            if (name === 'href') {
                if (value.length > 1e5) {
                    value = '';
                }
                this.app.send(SetNodeAttributeURLBased(id, name, value, this.app.getBaseHref()));
            }
            else {
                this.app.attributeSender.sendSetAttribute(id, name, value);
            }
            return;
        }
        if (name === 'src' ||
            name === 'srcset' ||
            name === 'integrity' ||
            name === 'crossorigin' ||
            name === 'autocomplete' ||
            name.substring(0, 2) === 'on') {
            return;
        }
        if (name === 'value' &&
            hasTag(node, 'input') &&
            node.type !== 'button' &&
            node.type !== 'reset' &&
            node.type !== 'submit') {
            return;
        }
        if (value === null) {
            this.app.send(RemoveNodeAttribute(id, name));
            return;
        }
        if (name === 'style' || (name === 'href' && hasTag(node, 'link'))) {
            this.app.send(SetNodeAttributeURLBased(id, name, value, this.app.getBaseHref()));
            return;
        }
        if (name === 'href' || value.length > 1e5) {
            value = '';
        }
        if (['alt', 'placeholder'].includes(name) && this.app.sanitizer.privateMode) {
            value = value.replaceAll(/./g, '*');
        }
        this.app.attributeSender.sendSetAttribute(id, name, value);
    }
    sendNodeData(id, parentElement, data) {
        if (hasTag(parentElement, 'style')) {
            this.app.send(SetCSSDataURLBased(id, data, this.app.getBaseHref()));
            return;
        }
        data = this.app.sanitizer.sanitize(id, data);
        this.app.send(SetNodeData(id, data));
    }
    bindNode(node) {
        const [id, isNew] = this.app.nodes.registerNode(node);
        if (isNew) {
            this.recents.set(id, RecentsType.New);
        }
        else if (this.recents.get(id) !== RecentsType.New) {
            this.recents.set(id, RecentsType.Removed);
        }
    }
    bindTree(node) {
        if (!isObservable(node)) {
            return;
        }
        this.bindNode(node);
        const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT, {
            acceptNode: (node) => {
                if (this.app.nodes.getID(node) !== undefined) {
                    this.app.debug.info('! Node is already bound', node);
                }
                return isIgnored(node) || this.app.nodes.getID(node) !== undefined
                    ? NodeFilter.FILTER_REJECT
                    : NodeFilter.FILTER_ACCEPT;
            },
        }, 
        // @ts-ignore
        false);
        while (walker.nextNode()) {
            this.bindNode(walker.currentNode);
        }
    }
    unbindTree(node) {
        const id = this.app.nodes.unregisterNode(node);
        if (id !== undefined && this.recents.get(id) === RecentsType.Removed) {
            // Sending RemoveNode only for parent to maintain
            this.app.send(RemoveNode(id));
            // Unregistering all the children in order to clear the memory
            const walker = document.createTreeWalker(node, NodeFilter.SHOW_ELEMENT + NodeFilter.SHOW_TEXT, {
                acceptNode: (node) => isIgnored(node) || this.app.nodes.getID(node) === undefined
                    ? NodeFilter.FILTER_REJECT
                    : NodeFilter.FILTER_ACCEPT,
            }, 
            // @ts-ignore
            false);
            let removed = 0;
            const totalBeforeRemove = this.app.nodes.getNodeCount();
            while (walker.nextNode()) {
                removed += 1;
                this.app.nodes.unregisterNode(walker.currentNode);
            }
            const removedPercent = Math.floor((removed / totalBeforeRemove) * 100);
            if (removedPercent > 30) {
                this.app.send(UnbindNodes(removedPercent));
            }
        }
    }
    // A top-consumption function on the infinite lists test. (~1% of performance resources)
    _commitNode(id, node) {
        if (isRootNode(node)) {
            return true;
        }
        const parent = node.parentNode;
        let parentID;
        // Disable parent check for the upper context HTMLHtmlElement, because it is root there... (before)
        // TODO: get rid of "special" cases (there is an issue with CreateDocument altered behaviour though)
        // TODO: Clean the logic (though now it workd fine)
        if (!hasTag(node, 'html') || !this.isTopContext) {
            if (parent === null) {
                // Sometimes one observation contains attribute mutations for the removimg node, which gets ignored here.
                // That shouldn't affect the visual rendering ( should it? maybe when transition applied? )
                this.unbindTree(node);
                return false;
            }
            parentID = this.app.nodes.getID(parent);
            if (parentID === undefined) {
                this.unbindTree(node);
                return false;
            }
            if (!this.commitNode(parentID)) {
                this.unbindTree(node);
                return false;
            }
            this.app.sanitizer.handleNode(id, parentID, node);
            if (this.app.sanitizer.isHidden(parentID)) {
                return false;
            }
        }
        // From here parentID === undefined if node is top context HTML node
        let sibling = node.previousSibling;
        while (sibling !== null) {
            const siblingID = this.app.nodes.getID(sibling);
            if (siblingID !== undefined) {
                this.commitNode(siblingID);
                this.indexes[id] = this.indexes[siblingID] + 1;
                break;
            }
            sibling = sibling.previousSibling;
        }
        if (sibling === null) {
            this.indexes[id] = 0;
        }
        const recentsType = this.recents.get(id);
        const isNew = recentsType === RecentsType.New;
        const index = this.indexes[id];
        if (index === undefined) {
            throw 'commitNode: missing node index';
        }
        if (isNew) {
            if (isElementNode(node)) {
                let el = node;
                if (parentID !== undefined) {
                    if (this.app.sanitizer.isHidden(id)) {
                        const width = el.clientWidth;
                        const height = el.clientHeight;
                        el = node.cloneNode();
                        el.style.width = `${width}px`;
                        el.style.height = `${height}px`;
                    }
                    this.app.send(CreateElementNode(id, parentID, index, el.tagName, isSVGElement(node)));
                }
                for (let i = 0; i < el.attributes.length; i++) {
                    const attr = el.attributes[i];
                    this.sendNodeAttribute(id, el, attr.nodeName, attr.value);
                }
            }
            else if (isTextNode(node)) {
                // for text node id != 0, hence parentID !== undefined and parent is Element
                this.app.send(CreateTextNode(id, parentID, index));
                this.sendNodeData(id, parent, node.data);
            }
            return true;
        }
        if (recentsType === RecentsType.Removed && parentID !== undefined) {
            this.app.send(MoveNode(id, parentID, index));
        }
        const attr = this.attributesMap.get(id);
        if (attr !== undefined) {
            if (!isElementNode(node)) {
                throw 'commitNode: node is not an element';
            }
            for (const name of attr) {
                this.sendNodeAttribute(id, node, name, node.getAttribute(name));
            }
        }
        if (this.textSet.has(id)) {
            if (!isTextNode(node)) {
                throw 'commitNode: node is not a text';
            }
            // for text node id != 0, hence parent is Element
            this.sendNodeData(id, parent, node.data);
        }
        return true;
    }
    commitNode(id) {
        const node = this.app.nodes.getNode(id);
        if (!node) {
            return false;
        }
        const cmt = this.commited[id];
        if (cmt !== undefined) {
            return cmt;
        }
        return (this.commited[id] = this._commitNode(id, node));
    }
    commitNodes(isStart = false) {
        let node;
        this.recents.forEach((type, id) => {
            this.commitNode(id);
            if (type === RecentsType.New && (node = this.app.nodes.getNode(id))) {
                this.app.nodes.callNodeCallbacks(node, isStart);
            }
        });
        this.clear();
    }
    // ISSSUE (nodeToBinde should be the same as node in all cases. Look at the comment about 0-node at the beginning of the file.)
    // TODO: use one observer instance for all iframes/shadowRoots (composition instiad of inheritance)
    observeRoot(node, beforeCommit, nodeToBind = node) {
        this.observer.observe(node, {
            childList: true,
            attributes: true,
            characterData: true,
            subtree: true,
            attributeOldValue: false,
            characterDataOldValue: false,
        });
        this.bindTree(nodeToBind);
        beforeCommit(this.app.nodes.getID(node));
        this.commitNodes(true);
    }
    disconnect() {
        this.observer.disconnect();
        this.clear();
    }
}

class IFrameObserver extends Observer {
    observe(iframe) {
        const doc = iframe.contentDocument;
        const hostID = this.app.nodes.getID(iframe);
        if (!doc || hostID === undefined) {
            return;
        }
        // Have to observe document, because the inner <html> might be changed
        this.observeRoot(doc, (docID) => {
            //MBTODO: do not send if empty (send on load? it might be in-place iframe, like our replayer, which does not get loaded)
            if (docID === undefined) {
                this.app.debug.log('OpenReplay: Iframe document not bound');
                return;
            }
            this.docId = docID;
            this.app.send(CreateIFrameDocument(hostID, docID));
        });
    }
    syntheticObserve(rootNodeId, doc) {
        this.observeRoot(doc, (docID) => {
            if (docID === undefined) {
                this.app.debug.log('OpenReplay: Iframe document not bound');
                return;
            }
            this.app.send(CreateIFrameDocument(rootNodeId, docID));
        });
    }
}

class ShadowRootObserver extends Observer {
    observe(el) {
        const shRoot = el.shadowRoot;
        const hostID = this.app.nodes.getID(el);
        if (!shRoot || hostID === undefined) {
            return;
        } // log
        this.observeRoot(shRoot, (rootID) => {
            if (rootID === undefined) {
                this.app.debug.error('OpenReplay: Shadow Root was not bound');
                return;
            }
            this.app.send(CreateIFrameDocument(hostID, rootID));
        });
    }
}

class IFrameOffsets {
    constructor() {
        this.states = new WeakMap();
    }
    calcOffset(state) {
        let parLeft = 0, parTop = 0;
        if (state.parent) {
            [parLeft, parTop] = this.calcOffset(state.parent);
        }
        if (!state.offset) {
            const { left, top } = state.iFrame.getBoundingClientRect();
            state.offset = [left, top];
        }
        const [left, top] = state.offset;
        return [parLeft + left, parTop + top]; // TODO: store absolute sum, invalidate whole subtree. Otherwise it is summated on each mousemove
    }
    getDocumentOffset(doc) {
        const state = this.states.get(doc);
        if (!state) {
            return [0, 0];
        } // topmost doc
        return this.calcOffset(state);
    }
    observe(iFrame) {
        const doc = iFrame.contentDocument;
        if (!doc) {
            return;
        }
        const parentDoc = iFrame.ownerDocument;
        const parentState = this.states.get(parentDoc);
        const state = {
            offset: null, // lazy calc
            iFrame,
            parent: parentState || null, // null when parentDoc is the topmost document
            clear: () => {
                parentDoc.removeEventListener('scroll', invalidateOffset);
                parentDoc.defaultView?.removeEventListener('resize', invalidateOffset);
            },
        };
        const invalidateOffset = () => {
            state.offset = null;
        };
        // anything more reliable? This does not cover all cases (layout changes are ignored, for ex.)
        parentDoc.addEventListener('scroll', invalidateOffset);
        parentDoc.defaultView?.addEventListener('resize', invalidateOffset);
        this.states.set(doc, state);
    }
    clear() {
        this.states = new WeakMap();
    }
}

const attachShadowNativeFn = IN_BROWSER ? Element.prototype.attachShadow : () => new ShadowRoot();
class TopObserver extends Observer {
    constructor(params) {
        const opts = Object.assign({
            captureIFrames: true,
            disableSprites: false,
        }, params.options);
        super(params.app, true, opts);
        this.iframeOffsets = new IFrameOffsets();
        this.contextCallbacks = [];
        // Attached once per Tracker instance
        this.contextsSet = new WeakSet();
        this.iframeObserversArr = [];
        this.iframeObservers = new WeakMap();
        this.docObservers = new WeakMap();
        this.shadowRootObservers = new WeakMap();
        this.app = params.app;
        this.options = opts;
        // IFrames
        this.app.nodes.attachNodeCallback((node) => {
            if (hasTag(node, 'iframe') &&
                ((this.options.captureIFrames && !hasOpenreplayAttribute(node, 'obscured')) ||
                    hasOpenreplayAttribute(node, 'capture'))) {
                this.handleIframe(node);
            }
        });
        // ShadowDOM
        this.app.nodes.attachNodeCallback((node) => {
            if (isElementNode(node) && node.shadowRoot !== null) {
                this.handleShadowRoot(node.shadowRoot);
            }
        });
    }
    attachContextCallback(cb) {
        this.contextCallbacks.push(cb);
    }
    getDocumentOffset(doc) {
        return this.iframeOffsets.getDocumentOffset(doc);
    }
    handleIframe(iframe) {
        // setTimeout is required. Otherwise some event listeners (scroll, mousemove) applied in modules
        // do not work on the iframe document when it 've been loaded dynamically ((why?))
        const handle = this.app.safe(() => setTimeout(() => {
            const id = this.app.nodes.getID(iframe);
            if (id === undefined || !canAccessIframe(iframe))
                return;
            const currentWin = iframe.contentWindow;
            const currentDoc = iframe.contentDocument;
            if (!currentDoc) {
                this.app.debug.warn('no doc for iframe found', iframe);
                return;
            }
            if (currentDoc && this.docObservers.has(currentDoc)) {
                this.app.debug.info('doc already observed for', id);
                return;
            }
            const observer = new IFrameObserver(this.app);
            this.iframeObservers.set(iframe, observer);
            this.docObservers.set(currentDoc, observer);
            this.iframeObserversArr.push(observer);
            observer.observe(iframe);
            this.iframeOffsets.observe(iframe);
            if (currentWin &&
                // Sometimes currentWin.window is null (not in specification). Such window object is not functional
                currentWin === currentWin.window &&
                !this.contextsSet.has(currentWin) // for each context callbacks called once per Tracker (TopObserver) instance
            //TODO: more explicit logic
            ) {
                this.contextsSet.add(currentWin);
                // @ts-ignore https://github.com/microsoft/TypeScript/issues/41684
                this.contextCallbacks.forEach((cb) => cb(currentWin));
            }
            // we need this delay because few iframes stacked one in another with rapid updates will break the player (or browser engine rather?)
        }, 250));
        iframe.addEventListener('load', handle);
        handle();
    }
    handleShadowRoot(shRoot) {
        const observer = new ShadowRootObserver(this.app);
        this.shadowRootObservers.set(shRoot, observer);
        observer.observe(shRoot.host);
    }
    observe() {
        // Protection from several subsequent calls?
        const observer = this;
        Element.prototype.attachShadow = function () {
            // eslint-disable-next-line
            const shadow = attachShadowNativeFn.apply(this, arguments);
            observer.handleShadowRoot(shadow);
            return shadow;
        };
        this.app.nodes.clear();
        // Can observe documentElement (<html>) here, because it is not supposed to be changing.
        // However, it is possible in some exotic cases and may cause an ignorance of the newly created <html>
        // In this case context.document have to be observed, but this will cause
        // the change in the re-player behaviour caused by CreateDocument message:
        //   the 0-node ("fRoot") will become #document rather than documentElement as it is now.
        // Alternatively - observe(#document) then bindNode(documentElement)
        this.observeRoot(window.document, () => {
            this.app.send(CreateDocument());
            // it has no node_id here
            this.app.nodes.callNodeCallbacks(document, true);
        }, window.document.documentElement);
    }
    crossdomainObserve(rootNodeId, frameOder) {
        const observer = this;
        Element.prototype.attachShadow = function () {
            // eslint-disable-next-line
            const shadow = attachShadowNativeFn.apply(this, arguments);
            observer.handleShadowRoot(shadow);
            return shadow;
        };
        this.app.nodes.clear();
        this.app.nodes.syntheticMode(frameOder);
        const iframeObserver = new IFrameObserver(this.app);
        this.iframeObservers.set(window.document, iframeObserver);
        iframeObserver.syntheticObserve(rootNodeId, window.document);
    }
    disconnect() {
        this.iframeOffsets.clear();
        Element.prototype.attachShadow = attachShadowNativeFn;
        this.iframeObserversArr.forEach((observer) => observer.disconnect());
        this.iframeObserversArr = [];
        this.iframeObservers = new WeakMap();
        this.shadowRootObservers = new WeakMap();
        this.docObservers = new WeakMap();
        super.disconnect();
    }
}

exports.SanitizeLevel = void 0;
(function (SanitizeLevel) {
    SanitizeLevel[SanitizeLevel["Plain"] = 0] = "Plain";
    SanitizeLevel[SanitizeLevel["Obscured"] = 1] = "Obscured";
    SanitizeLevel[SanitizeLevel["Hidden"] = 2] = "Hidden";
})(exports.SanitizeLevel || (exports.SanitizeLevel = {}));
const stringWiper = (input) => input
    .trim()
    .replace(/[^\f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff\s]/g, '*');
class Sanitizer {
    constructor(params) {
        this.obscured = new Set();
        this.hidden = new Set();
        this.app = params.app;
        const defaultOptions = {
            obscureTextEmails: true,
            obscureTextNumbers: false,
            privateMode: false,
            domSanitizer: undefined,
        };
        this.privateMode = params.options?.privateMode ?? false;
        this.options = Object.assign(defaultOptions, params.options);
    }
    handleNode(id, parentID, node) {
        if (this.options.privateMode) {
            if (isElementNode(node) && !hasOpenreplayAttribute(node, 'unmask')) {
                return this.obscured.add(id);
            }
            if (isTextNode(node) && !hasOpenreplayAttribute(node.parentNode, 'unmask')) {
                return this.obscured.add(id);
            }
        }
        if (this.obscured.has(parentID) ||
            (isElementNode(node) &&
                (hasOpenreplayAttribute(node, 'masked') || hasOpenreplayAttribute(node, 'obscured')))) {
            this.obscured.add(id);
        }
        if (this.hidden.has(parentID) ||
            (isElementNode(node) &&
                (hasOpenreplayAttribute(node, 'htmlmasked') || hasOpenreplayAttribute(node, 'hidden')))) {
            this.hidden.add(id);
        }
        if (this.options.domSanitizer !== undefined && isElementNode(node)) {
            const sanitizeLevel = this.options.domSanitizer(node);
            if (sanitizeLevel === exports.SanitizeLevel.Obscured) {
                this.obscured.add(id);
            }
            if (sanitizeLevel === exports.SanitizeLevel.Hidden) {
                this.hidden.add(id);
            }
        }
    }
    sanitize(id, data) {
        if (this.obscured.has(id)) {
            // TODO: is it the best place to put trim() ? Might trimmed spaces be considered in layout in certain cases?
            return stringWiper(data);
        }
        if (this.options.obscureTextNumbers) {
            data = data.replace(/\d/g, '0');
        }
        if (this.options.obscureTextEmails) {
            data = data.replace(/^\w+([+.-]\w+)*@\w+([.-]\w+)*\.\w{2,3}$/g, (email) => {
                const [name, domain] = email.split('@');
                const [domainName, host] = domain.split('.');
                return `${stars(name)}@${stars(domainName)}.${stars(host)}`;
            });
        }
        return data;
    }
    isObscured(id) {
        return this.obscured.has(id);
    }
    isHidden(id) {
        return this.hidden.has(id);
    }
    getInnerTextSecure(el) {
        const id = this.app.nodes.getID(el);
        if (!id) {
            return '';
        }
        return this.sanitize(id, el.innerText);
    }
    clear() {
        this.obscured.clear();
        this.hidden.clear();
    }
}

class Session {
    constructor(params) {
        this.metadata = {};
        this.userID = null;
        this.callbacks = [];
        this.timestamp = 0;
        this.getPageNumber = () => {
            const pageNoStr = this.app.sessionStorage.getItem(this.options.session_pageno_key);
            if (pageNoStr == null) {
                return undefined;
            }
            return parseInt(pageNoStr);
        };
        this.incPageNo = () => {
            let pageNo = this.getPageNumber();
            if (pageNo === undefined) {
                pageNo = 0;
            }
            else {
                pageNo++;
            }
            this.app.sessionStorage.setItem(this.options.session_pageno_key, pageNo.toString());
            return pageNo;
        };
        this.app = params.app;
        this.options = params.options;
        this.createTabId();
    }
    attachUpdateCallback(cb) {
        this.callbacks.push(cb);
    }
    handleUpdate(newInfo) {
        if (newInfo.userID == null) {
            delete newInfo.userID;
        }
        if (newInfo.sessionID == null) {
            delete newInfo.sessionID;
        }
        this.callbacks.forEach((cb) => cb(newInfo));
    }
    assign(newInfo) {
        if (newInfo.userID !== undefined) {
            // TODO clear nullable/undefinable types
            this.userID = newInfo.userID;
        }
        if (newInfo.metadata !== undefined) {
            Object.entries(newInfo.metadata).forEach(([k, v]) => (this.metadata[k] = v));
        }
        if (newInfo.sessionID !== undefined) {
            this.sessionID = newInfo.sessionID;
        }
        if (newInfo.timestamp !== undefined) {
            this.timestamp = newInfo.timestamp;
        }
        if (newInfo.projectID !== undefined) {
            this.projectID = newInfo.projectID;
        }
        this.handleUpdate(newInfo);
    }
    setMetadata(key, value) {
        this.metadata[key] = value;
        this.handleUpdate({ metadata: { [key]: value } });
    }
    setUserID(userID) {
        this.userID = userID;
        this.handleUpdate({ userID });
    }
    setUserInfo(userInfo) {
        this.userInfo = userInfo;
    }
    getSessionToken() {
        const token = this.token || this.app.sessionStorage.getItem(this.options.session_token_key);
        return token || undefined;
    }
    setSessionToken(token) {
        this.token = token;
        this.app.sessionStorage.setItem(this.options.session_token_key, token);
    }
    applySessionHash(hash) {
        const hashParts = decodeURI(hash).split('&');
        let token = hash;
        let pageNoStr = '100500'; // back-compat for sessionToken
        if (hashParts.length == 2) {
            [pageNoStr, token] = hashParts;
        }
        if (!pageNoStr || !token) {
            return;
        }
        this.app.sessionStorage.setItem(this.options.session_token_key, token);
        this.app.sessionStorage.setItem(this.options.session_pageno_key, pageNoStr);
    }
    getSessionHash() {
        const pageNo = this.getPageNumber();
        const token = this.getSessionToken();
        if (pageNo === undefined || token === undefined) {
            return;
        }
        return encodeURI(String(pageNo) + '&' + token);
    }
    getTabId() {
        if (!this.tabId)
            this.createTabId();
        return this.tabId;
    }
    regenerateTabId() {
        const randomId = generateRandomId(12);
        this.app.sessionStorage.setItem(this.options.session_tabid_key, randomId);
        this.tabId = randomId;
    }
    createTabId() {
        const localId = this.app.sessionStorage.getItem(this.options.session_tabid_key);
        if (localId) {
            this.tabId = localId;
        }
        else {
            this.regenerateTabId();
        }
    }
    getInfo() {
        return {
            sessionID: this.sessionID,
            metadata: this.metadata,
            userID: this.userID,
            timestamp: this.timestamp,
            projectID: this.projectID,
        };
    }
    reset() {
        this.app.sessionStorage.removeItem(this.options.session_token_key);
        this.metadata = {};
        this.userID = null;
        this.sessionID = undefined;
        this.timestamp = 0;
    }
}

function wrap(callback, n) {
    let t = 0;
    return () => {
        if (t++ >= n) {
            t = 0;
            callback();
        }
    };
}
class Ticker {
    constructor(app) {
        this.app = app;
        this.timer = null;
        this.callbacks = [];
    }
    /**
     * @param {Callback} callback - repeated cb
     * @param {number} n - number of turn skips; ticker have a 30 ms cycle
     * @param {boolean} useSafe - using safe wrapper to check if app is active
     * @param {object} thisArg - link to <this>
     * */
    attach(callback, n = 0, useSafe = true, thisArg) {
        if (thisArg) {
            callback = callback.bind(thisArg);
        }
        if (useSafe) {
            callback = this.app.safe(callback);
        }
        this.callbacks.unshift(n ? wrap(callback, n) : callback) - 1;
    }
    start() {
        if (this.timer === null) {
            this.timer = setInterval(() => this.callbacks.forEach((cb) => {
                if (cb)
                    cb();
            }), 30);
        }
    }
    stop() {
        if (this.timer !== null) {
            clearInterval(this.timer);
            this.timer = null;
        }
    }
}

/**
 * this value is injected during build time via rollup
 * */
// @ts-ignore
const workerBodyFn = "!function(){\"use strict\";class t{constructor(t,s,i,e=10,n=250,h,r){this.onUnauthorised=s,this.onFailure=i,this.MAX_ATTEMPTS_COUNT=e,this.ATTEMPT_TIMEOUT=n,this.onCompress=h,this.pageNo=r,this.attemptsCount=0,this.busy=!1,this.queue=[],this.token=null,this.lastBatchNum=0,this.ingestURL=t+\"/v1/web/i\",this.isCompressing=void 0!==h}getQueueStatus(){return 0===this.queue.length&&!this.busy}authorise(t){this.token=t,this.busy||this.sendNext()}push(t){if(this.busy||!this.token)this.queue.push(t);else if(this.busy=!0,this.isCompressing&&this.onCompress)this.onCompress(t);else{const s=++this.lastBatchNum;this.sendBatch(t,!1,s)}}sendNext(){const t=this.queue.shift();if(t)if(this.busy=!0,this.isCompressing&&this.onCompress)this.onCompress(t);else{const s=++this.lastBatchNum;this.sendBatch(t,!1,s)}else this.busy=!1}retry(t,s,i){this.attemptsCount>=this.MAX_ATTEMPTS_COUNT?this.onFailure(`Failed to send batch after ${this.attemptsCount} attempts.`):(this.attemptsCount++,setTimeout((()=>this.sendBatch(t,s,i)),this.ATTEMPT_TIMEOUT*this.attemptsCount))}sendBatch(t,s,i){var e;const n=null==i?void 0:i.toString().replace(/^([^_]+)_([^_]+).*/,\"$1_$2_$3\");this.busy=!0;const h={Authorization:`Bearer ${this.token}`};s&&(h[\"Content-Encoding\"]=\"gzip\"),null!==this.token?fetch(`${this.ingestURL}?batch=${null!==(e=this.pageNo)&&void 0!==e?e:\"noPageNum\"}_${null!=n?n:\"noBatchNum\"}`,{body:t,method:\"POST\",headers:h,keepalive:t.length<65536}).then((e=>{if(401===e.status)return this.busy=!1,void this.onUnauthorised();e.status>=400?this.retry(t,s,`${null!=i?i:\"noBatchNum\"}_network:${e.status}`):(this.attemptsCount=0,this.sendNext())})).catch((e=>{console.warn(\"OpenReplay:\",e),this.retry(t,s,`${null!=i?i:\"noBatchNum\"}_reject:${e.message}`)})):setTimeout((()=>{this.sendBatch(t,s,`${null!=i?i:\"noBatchNum\"}_newToken`)}),500)}sendCompressed(t){const s=++this.lastBatchNum;this.sendBatch(t,!0,s)}sendUncompressed(t){const s=++this.lastBatchNum;this.sendBatch(t,!1,s)}clean(){this.sendNext(),setTimeout((()=>{this.token=null,this.queue.length=0}),10)}}const s=\"function\"==typeof TextEncoder?new TextEncoder:{encode(t){const s=t.length,i=new Uint8Array(3*s);let e=-1;for(let n=0,h=0,r=0;r!==s;){if(n=t.charCodeAt(r),r+=1,n>=55296&&n<=56319){if(r===s){i[e+=1]=239,i[e+=1]=191,i[e+=1]=189;break}if(h=t.charCodeAt(r),!(h>=56320&&h<=57343)){i[e+=1]=239,i[e+=1]=191,i[e+=1]=189;continue}if(n=1024*(n-55296)+h-56320+65536,r+=1,n>65535){i[e+=1]=240|n>>>18,i[e+=1]=128|n>>>12&63,i[e+=1]=128|n>>>6&63,i[e+=1]=128|63&n;continue}}n<=127?i[e+=1]=0|n:n<=2047?(i[e+=1]=192|n>>>6,i[e+=1]=128|63&n):(i[e+=1]=224|n>>>12,i[e+=1]=128|n>>>6&63,i[e+=1]=128|63&n)}return i.subarray(0,e+1)}};class i{constructor(t){this.size=t,this.offset=0,this.checkpointOffset=0,this.data=new Uint8Array(t)}getCurrentOffset(){return this.offset}checkpoint(){this.checkpointOffset=this.offset}get isEmpty(){return 0===this.offset}skip(t){return this.offset+=t,this.offset<=this.size}set(t,s){this.data.set(t,s)}boolean(t){return this.data[this.offset++]=+t,this.offset<=this.size}uint(t){for((t<0||t>Number.MAX_SAFE_INTEGER)&&(t=0);t>=128;)this.data[this.offset++]=t%256|128,t=Math.floor(t/128);return this.data[this.offset++]=t,this.offset<=this.size}int(t){return t=Math.round(t),this.uint(t>=0?2*t:-2*t-1)}string(t){const i=s.encode(t),e=i.byteLength;return!(!this.uint(e)||this.offset+e>this.size)&&(this.data.set(i,this.offset),this.offset+=e,!0)}reset(){this.offset=0,this.checkpointOffset=0}flush(){const t=this.data.slice(0,this.checkpointOffset);return this.reset(),t}}class e extends i{encode(t){switch(t[0]){case 0:case 11:case 114:case 115:return this.uint(t[1]);case 4:case 44:case 47:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3]);case 5:case 20:case 70:case 75:case 76:case 77:case 82:return this.uint(t[1])&&this.uint(t[2]);case 6:return this.int(t[1])&&this.int(t[2]);case 7:return!0;case 8:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.string(t[4])&&this.boolean(t[5]);case 9:case 10:case 24:case 35:case 51:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3]);case 12:case 52:case 61:case 71:return this.uint(t[1])&&this.string(t[2])&&this.string(t[3]);case 13:case 14:case 17:case 34:case 50:case 54:return this.uint(t[1])&&this.string(t[2]);case 16:return this.uint(t[1])&&this.int(t[2])&&this.int(t[3]);case 18:return this.uint(t[1])&&this.string(t[2])&&this.int(t[3]);case 19:return this.uint(t[1])&&this.boolean(t[2]);case 21:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.string(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8]);case 22:case 27:case 30:case 41:case 45:case 46:case 43:case 63:case 64:case 79:case 124:return this.string(t[1])&&this.string(t[2]);case 23:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8])&&this.uint(t[9]);case 28:case 29:case 42:case 117:case 118:return this.string(t[1]);case 40:return this.string(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4]);case 48:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.int(t[5]);case 49:return this.int(t[1])&&this.int(t[2])&&this.uint(t[3])&&this.uint(t[4]);case 53:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.string(t[7])&&this.string(t[8]);case 55:return this.boolean(t[1]);case 57:case 60:return this.uint(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4]);case 58:case 120:return this.int(t[1]);case 68:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4])&&this.uint(t[5])&&this.uint(t[6]);case 69:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3])&&this.string(t[4]);case 73:return this.uint(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.string(t[4]);case 78:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4]);case 81:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.int(t[4])&&this.string(t[5]);case 83:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.string(t[5])&&this.uint(t[6])&&this.uint(t[7])&&this.uint(t[8])&&this.uint(t[9]);case 84:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.uint(t[4])&&this.string(t[5])&&this.string(t[6]);case 112:return this.uint(t[1])&&this.string(t[2])&&this.boolean(t[3])&&this.string(t[4])&&this.int(t[5])&&this.int(t[6]);case 113:return this.uint(t[1])&&this.uint(t[2])&&this.string(t[3]);case 116:return this.uint(t[1])&&this.uint(t[2])&&this.uint(t[3])&&this.uint(t[4])&&this.uint(t[5])&&this.uint(t[6])&&this.string(t[7])&&this.string(t[8])&&this.uint(t[9])&&this.boolean(t[10]);case 119:return this.string(t[1])&&this.uint(t[2]);case 121:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.uint(t[4]);case 122:return this.string(t[1])&&this.string(t[2])&&this.uint(t[3])&&this.string(t[4]);case 123:return this.string(t[1])&&this.string(t[2])&&this.string(t[3])&&this.string(t[4])&&this.uint(t[5])}}}class n{constructor(t,s,i,n,h,r){this.pageNo=t,this.timestamp=s,this.url=i,this.onBatch=n,this.tabId=h,this.onOfflineEnd=r,this.nextIndex=0,this.beaconSize=2e5,this.encoder=new e(this.beaconSize),this.sizeBuffer=new Uint8Array(3),this.isEmpty=!0,this.beaconSizeLimit=1e6,this.prepare()}writeType(t){return this.encoder.uint(t[0])}writeFields(t){return this.encoder.encode(t)}writeSizeAt(t,s){for(let s=0;s<3;s++)this.sizeBuffer[s]=t>>8*s;this.encoder.set(this.sizeBuffer,s)}prepare(){if(!this.encoder.isEmpty)return;const t=[81,1,this.pageNo,this.nextIndex,this.timestamp,this.url],s=[0,this.timestamp],i=[118,this.tabId];this.writeType(t),this.writeFields(t),this.writeWithSize(s),this.writeWithSize(i),this.isEmpty=!0}writeWithSize(t){const s=this.encoder;if(!this.writeType(t)||!s.skip(3))return!1;const i=s.getCurrentOffset(),e=this.writeFields(t);if(e){const e=s.getCurrentOffset()-i;if(e>16777215)return console.warn(\"OpenReplay: max message size overflow.\"),!1;this.writeSizeAt(e,i-3),s.checkpoint(),this.isEmpty=this.isEmpty&&0===t[0],this.nextIndex++}return e}setBeaconSizeLimit(t){this.beaconSizeLimit=t}writeMessage(t){if(\"q_end\"===t[0])return this.finaliseBatch(),this.onOfflineEnd();0===t[0]&&(this.timestamp=t[1]),122===t[0]&&(this.url=t[1]),this.writeWithSize(t)||(this.finaliseBatch(),this.writeWithSize(t)||(this.encoder=new e(this.beaconSizeLimit),this.prepare(),this.writeWithSize(t)?this.finaliseBatch():console.warn(\"OpenReplay: beacon size overflow. Skipping large message.\",t,this),this.encoder=new e(this.beaconSize),this.prepare()))}finaliseBatch(){if(this.isEmpty)return;const t=this.encoder.flush();this.onBatch(t),this.prepare()}clean(){this.encoder.reset()}}var h;!function(t){t[t.NotActive=0]=\"NotActive\",t[t.Starting=1]=\"Starting\",t[t.Stopping=2]=\"Stopping\",t[t.Active=3]=\"Active\",t[t.Stopped=4]=\"Stopped\"}(h||(h={}));let r=null,a=null,u=h.NotActive;function o(){a&&a.finaliseBatch()}function c(){return new Promise((t=>{u=h.Stopping,null!==p&&(clearInterval(p),p=null),a&&(a.clean(),a=null),r&&(r.clean(),setTimeout((()=>{r=null}),20)),setTimeout((()=>{u=h.NotActive,t(null)}),100)}))}function l(){[h.Stopped,h.Stopping].includes(u)||(postMessage(\"a_stop\"),c().then((()=>{postMessage(\"a_start\")})))}let g,p=null;self.onmessage=({data:s})=>{if(null!=s){if(\"stop\"===s)return o(),void c().then((()=>{u=h.Stopped}));if(\"forceFlushBatch\"!==s){if(!Array.isArray(s)){if(\"compressed\"===s.type){if(!r)return console.debug(\"OR WebWorker: sender not initialised. Compressed batch.\"),void l();s.batch&&r.sendCompressed(s.batch)}if(\"uncompressed\"===s.type){if(!r)return console.debug(\"OR WebWorker: sender not initialised. Uncompressed batch.\"),void l();s.batch&&r.sendUncompressed(s.batch)}return\"start\"===s.type?(u=h.Starting,r=new t(s.ingestPoint,(()=>{l()}),(t=>{!function(t){postMessage({type:\"failure\",reason:t}),c()}(t)}),s.connAttemptCount,s.connAttemptGap,(t=>{postMessage({type:\"compress\",batch:t},[t.buffer])}),s.pageNo),a=new n(s.pageNo,s.timestamp,s.url,(t=>{r&&r.push(t)}),s.tabId,(()=>postMessage({type:\"queue_empty\"}))),null===p&&(p=setInterval(o,1e4)),u=h.Active):\"auth\"===s.type?r?a?(r.authorise(s.token),void(s.beaconSizeLimit&&a.setBeaconSizeLimit(s.beaconSizeLimit))):(console.debug(\"OR WebWorker: writer not initialised. Received auth.\"),void l()):(console.debug(\"OR WebWorker: sender not initialised. Received auth.\"),void l()):void 0}if(a){const t=a;s.forEach((s=>{55===s[0]&&(s[1]?g=setTimeout((()=>l()),18e5):clearTimeout(g)),t.writeMessage(s)}))}else postMessage(\"not_init\"),l()}else o()}else o()}}();\n";
const CANCELED = 'canceled';
const uxtStorageKey = 'or_uxt_active';
const bufferStorageKey = 'or_buffer_1';
const UnsuccessfulStart = (reason) => ({ reason, success: false });
const SuccessfulStart = (body) => ({ ...body, success: true });
var ActivityState;
(function (ActivityState) {
    ActivityState[ActivityState["NotActive"] = 0] = "NotActive";
    ActivityState[ActivityState["Starting"] = 1] = "Starting";
    ActivityState[ActivityState["Active"] = 2] = "Active";
    ActivityState[ActivityState["ColdStart"] = 3] = "ColdStart";
})(ActivityState || (ActivityState = {}));
// TODO: use backendHost only
const DEFAULT_INGEST_POINT = 'https://api.openreplay.com/ingest';
function getTimezone() {
    const offset = new Date().getTimezoneOffset() * -1;
    const sign = offset >= 0 ? '+' : '-';
    const hours = Math.floor(Math.abs(offset) / 60);
    const minutes = Math.abs(offset) % 60;
    return `UTC${sign}${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}`;
}
const delay = (ms) => new Promise((res) => setTimeout(res, ms));
const proto = {
    // ask if there are any tabs alive
    ask: 'never-gonna-give-you-up',
    // response from another tab
    resp: 'never-gonna-let-you-down',
    // regenerating id (copied other tab)
    reg: 'never-gonna-run-around-and-desert-you',
    iframeSignal: 'tracker inside a child iframe',
    iframeId: 'getting node id for child iframe',
    iframeBatch: 'batch of messages from an iframe window',
    parentAlive: 'signal that parent is live',
    killIframe: 'stop tracker inside frame',
    startIframe: 'start tracker inside frame',
    // checking updates
    polling: 'hello-how-are-you-im-under-the-water-please-help-me',
};
class App {
    constructor(projectKey, sessionToken, options, signalError, insideIframe) {
        this.signalError = signalError;
        this.insideIframe = insideIframe;
        this.messages = [];
        /**
         * we need 2 buffers, so we don't lose anything
         * @read coldStart implementation
         * */
        this.bufferedMessages1 = [];
        this.bufferedMessages2 = [];
        this.startCallbacks = [];
        this.stopCallbacks = [];
        this.commitCallbacks = [];
        this.activityState = ActivityState.NotActive;
        this.version = '16.1.1'; // TODO: version compatability check inside each plugin.
        this.socketMode = false;
        this.compressionThreshold = 24 * 1000;
        this.bc = null;
        this.canvasRecorder = null;
        this.conditionsManager = null;
        this.canStart = false;
        this.rootId = null;
        this.pageFrames = [];
        this.frameOderNumber = 0;
        this.features = {
            'feature-flags': true,
            'usability-test': true,
        };
        this.emptyBatchCounter = 0;
        /** used by child iframes for crossdomain only */
        this.parentActive = false;
        this.checkStatus = () => {
            return this.parentActive;
        };
        this.parentCrossDomainFrameListener = (event) => {
            const { data } = event;
            if (!data || event.source === window)
                return;
            if (data.line === proto.startIframe) {
                if (this.active())
                    return;
                try {
                    this.allowAppStart();
                    void this.start();
                }
                catch (e) {
                    console.error('children frame restart failed:', e);
                }
            }
            if (data.line === proto.parentAlive) {
                this.parentActive = true;
            }
            if (data.line === proto.iframeId) {
                this.parentActive = true;
                this.rootId = data.id;
                this.session.setSessionToken(data.token);
                this.frameOderNumber = data.frameOrderNumber;
                this.debug.log('starting iframe tracking', data);
                this.allowAppStart();
            }
            if (data.line === proto.killIframe) {
                if (this.active()) {
                    this.stop();
                }
            }
        };
        /**
         * context ids for iframes,
         * order is not so important as long as its consistent
         * */
        this.trackedFrames = [];
        this.crossDomainIframeListener = (event) => {
            if (!this.active() || event.source === window)
                return;
            const { data } = event;
            if (!data)
                return;
            if (data.line === proto.iframeSignal) {
                // @ts-ignore
                event.source?.postMessage({ ping: true, line: proto.parentAlive }, '*');
                const signalId = async () => {
                    if (event.source === null) {
                        return console.error('Couldnt connect to event.source for child iframe tracking');
                    }
                    const id = await this.checkNodeId(event.source);
                    if (!id) {
                        this.debug.log('Couldnt get node id for iframe', event.source);
                        return;
                    }
                    try {
                        if (this.trackedFrames.includes(data.context)) {
                            this.debug.log('Trying to observe already added iframe; ignore if its a restart');
                        }
                        else {
                            this.trackedFrames.push(data.context);
                        }
                        await this.waitStarted();
                        const token = this.session.getSessionToken();
                        const order = this.trackedFrames.findIndex((f) => f === data.context) + 1;
                        if (order === 0) {
                            this.debug.error('Couldnt get order number for iframe', data.context, this.trackedFrames);
                        }
                        const iframeData = {
                            line: proto.iframeId,
                            id,
                            token,
                            // since indexes go from 0 we +1
                            frameOrderNumber: order,
                        };
                        this.debug.log('Got child frame signal; nodeId', id, event.source, iframeData);
                        // @ts-ignore
                        event.source?.postMessage(iframeData, '*');
                    }
                    catch (e) {
                        console.error(e);
                    }
                };
                void signalId();
            }
            /**
             * proxying messages from iframe to main body, so they can be in one batch (same indexes, etc)
             * plus we rewrite some of the messages to be relative to the main context/window
             * */
            if (data.line === proto.iframeBatch) {
                const msgBatch = data.messages;
                const mappedMessages = msgBatch.map((msg) => {
                    if (msg[0] === 20 /* MType.MouseMove */) {
                        let fixedMessage = msg;
                        this.pageFrames.forEach((frame) => {
                            if (frame.contentWindow === event.source) {
                                const [type, x, y] = msg;
                                const { left, top } = frame.getBoundingClientRect();
                                fixedMessage = [type, x + left, y + top];
                            }
                        });
                        return fixedMessage;
                    }
                    if (msg[0] === 68 /* MType.MouseClick */) {
                        let fixedMessage = msg;
                        this.pageFrames.forEach((frame) => {
                            if (frame.contentWindow === event.source) {
                                const [type, id, hesitationTime, label, selector, normX, normY] = msg;
                                const { left, top, width, height } = frame.getBoundingClientRect();
                                const contentWidth = document.documentElement.scrollWidth;
                                const contentHeight = document.documentElement.scrollHeight;
                                // (normalizedX * frameWidth + frameLeftOffset)/docSize
                                const fullX = (normX / 100) * width + left;
                                const fullY = (normY / 100) * height + top;
                                const fixedX = fullX / contentWidth;
                                const fixedY = fullY / contentHeight;
                                fixedMessage = [
                                    type,
                                    id,
                                    hesitationTime,
                                    label,
                                    selector,
                                    Math.round(fixedX * 1e3) / 1e1,
                                    Math.round(fixedY * 1e3) / 1e1,
                                ];
                            }
                        });
                        return fixedMessage;
                    }
                    return msg;
                });
                this.messages.push(...mappedMessages);
            }
            if (data.line === proto.polling) {
                if (!this.pollingQueue.order.length) {
                    return;
                }
                const nextCommand = this.pollingQueue.order[0];
                if (nextCommand && this.pollingQueue[nextCommand].length === 0) {
                    this.pollingQueue.order = this.pollingQueue.order.filter((c) => c !== nextCommand);
                    return;
                }
                if (this.pollingQueue[nextCommand].includes(data.context)) {
                    this.pollingQueue[nextCommand] = this.pollingQueue[nextCommand].filter((c) => c !== data.context);
                    // @ts-ignore
                    event.source?.postMessage({ line: nextCommand }, '*');
                    if (this.pollingQueue[nextCommand].length === 0) {
                        this.pollingQueue.order.shift();
                    }
                }
            }
        };
        /**
         * { command : [remaining iframes] }
         * + order of commands
         **/
        this.pollingQueue = {
            order: [],
        };
        this.addCommand = (cmd) => {
            this.pollingQueue.order.push(cmd);
            this.pollingQueue[cmd] = [...this.trackedFrames];
        };
        this.bootChildrenFrames = async () => {
            await this.waitStarted();
            this.addCommand(proto.startIframe);
        };
        this.killChildrenFrames = () => {
            this.addCommand(proto.killIframe);
        };
        this.signalIframeTracker = () => {
            const thisTab = this.session.getTabId();
            window.parent.postMessage({
                line: proto.iframeSignal,
                source: thisTab,
                context: this.contextId,
            }, this.options.crossdomain?.parentDomain ?? '*');
            /**
             * since we need to wait uncertain amount of time
             * and I don't want to have recursion going on,
             * we'll just use a timeout loop with backoff
             * */
            const maxRetries = 10;
            let retries = 0;
            let delay = 250;
            let cumulativeDelay = 0;
            let stopAttempts = false;
            const checkAndSendMessage = () => {
                if (stopAttempts || this.checkStatus()) {
                    stopAttempts = true;
                    return;
                }
                window.parent.postMessage({
                    line: proto.iframeSignal,
                    source: thisTab,
                    context: this.contextId,
                }, this.options.crossdomain?.parentDomain ?? '*');
                this.debug.info('Trying to signal to parent, attempt:', retries + 1);
                retries++;
            };
            for (let i = 0; i < maxRetries; i++) {
                if (this.checkStatus()) {
                    stopAttempts = true;
                    break;
                }
                cumulativeDelay += delay;
                setTimeout(() => {
                    checkAndSendMessage();
                }, cumulativeDelay);
                delay *= 1.5;
            }
        };
        this.startTimeout = null;
        this.coldStartCommitN = 0;
        this.delay = 0;
        this.attachStartCallback = (cb, useSafe = false) => {
            if (useSafe) {
                cb = this.safe(cb);
            }
            this.startCallbacks.push(cb);
        };
        this.attachStopCallback = (cb, useSafe = false) => {
            if (useSafe) {
                cb = this.safe(cb);
            }
            this.stopCallbacks.push(cb);
        };
        this.attachEventListener = (target, type, listener, useSafe = true, useCapture = true) => {
            if (useSafe) {
                listener = this.safe(listener);
            }
            const createListener = () => target
                ? createEventListener(target, type, listener, useCapture, this.options.forceNgOff)
                : null;
            const deleteListener = () => target
                ? deleteEventListener(target, type, listener, useCapture, this.options.forceNgOff)
                : null;
            this.attachStartCallback(createListener, useSafe);
            this.attachStopCallback(deleteListener, useSafe);
        };
        this.coldInterval = null;
        this.orderNumber = 0;
        this.coldStartTs = 0;
        this.singleBuffer = false;
        this.onSessionSent = () => {
            return;
        };
        this.prevOpts = {};
        this.restartCanvasTracking = () => {
            this.canvasRecorder?.restartTracking();
        };
        this.flushBuffer = async (buffer) => {
            return new Promise((res, reject) => {
                if (buffer.length === 0) {
                    res(null);
                    return;
                }
                // Since the first element is always a Timestamp, include it by default.
                let endIndex = 1;
                while (endIndex < buffer.length && buffer[endIndex][0] !== 0 /* MType.Timestamp */) {
                    endIndex++;
                }
                requestIdleCb(() => {
                    try {
                        const messagesBatch = buffer.splice(0, endIndex);
                        // Cast out potential proxy objects (produced from vue.js deep reactivity, for example) to a regular array.
                        this.postToWorker(messagesBatch.map((x) => [...x]));
                        res(null);
                    }
                    catch (e) {
                        this._debug('flushBuffer', e);
                        reject(new Error('flushBuffer failed'));
                    }
                });
            });
        };
        this.onUxtCb = [];
        this.contextId = Math.random().toString(36).slice(2);
        this.projectKey = projectKey;
        if (Object.keys(options).findIndex((k) => ['fixedCanvasScaling', 'disableCanvas'].includes(k)) !==
            -1) {
            console.warn('Openreplay: canvas options are moving to separate key "canvas" in next update. Please update your configuration.');
            options = {
                ...options,
                canvas: {
                    __save_canvas_locally: options.__save_canvas_locally,
                    fixedCanvasScaling: options.fixedCanvasScaling,
                    disableCanvas: options.disableCanvas,
                },
            };
        }
        this.networkOptions = options.network;
        const defaultOptions = {
            revID: '',
            node_id: '__openreplay_id',
            session_token_key: '__openreplay_token',
            session_pageno_key: '__openreplay_pageno',
            session_reset_key: '__openreplay_reset',
            session_tabid_key: '__openreplay_tabid',
            local_uuid_key: '__openreplay_uuid',
            ingestPoint: DEFAULT_INGEST_POINT,
            resourceBaseHref: null,
            __is_snippet: false,
            __debug_report_edp: null,
            __debug__: LogLevel.Silent,
            __save_canvas_locally: false,
            localStorage: null,
            sessionStorage: null,
            disableStringDict: false,
            forceSingleTab: false,
            assistSocketHost: '',
            fixedCanvasScaling: false,
            disableCanvas: false,
            captureIFrames: true,
            disableSprites: false,
            obscureTextEmails: true,
            obscureTextNumbers: false,
            crossdomain: {
                parentDomain: '*',
            },
            canvas: {
                disableCanvas: false,
                fixedCanvasScaling: false,
                __save_canvas_locally: false,
                useAnimationFrame: false,
            },
            forceNgOff: false,
        };
        this.options = simpleMerge(defaultOptions, options);
        if (!this.insideIframe &&
            !this.options.forceSingleTab &&
            globalThis &&
            'BroadcastChannel' in globalThis) {
            const host = location.hostname.split('.').slice(-2).join('_');
            this.bc = new BroadcastChannel(`rick_${host}`);
        }
        else if (this.options.forceSingleTab) {
            this.allowAppStart();
        }
        this.revID = this.options.revID;
        this.localStorage = this.options.localStorage ?? window.localStorage;
        this.sessionStorage = this.options.sessionStorage ?? window.sessionStorage;
        this.sanitizer = new Sanitizer({ app: this, options });
        this.nodes = new Nodes({
            node_id: this.options.node_id,
            forceNgOff: Boolean(options.forceNgOff),
            maintainer: this.options.nodes?.maintainer,
        });
        this.observer = new TopObserver({ app: this, options });
        this.ticker = new Ticker(this);
        this.ticker.attach(() => this.commit());
        this.debug = new Logger(this.options.__debug__);
        this.session = new Session({ app: this, options: this.options });
        this.attributeSender = new AttributeSender({
            app: this,
            isDictDisabled: Boolean(this.options.disableStringDict || this.options.crossdomain?.enabled),
        });
        this.featureFlags = new FeatureFlags(this);
        this.tagWatcher = new TagWatcher({
            sessionStorage: this.sessionStorage,
            errLog: this.debug.error,
            onTag: (tag) => this.send(TagTrigger(tag)),
        });
        this.session.attachUpdateCallback(({ userID, metadata }) => {
            if (userID != null) {
                // TODO: nullable userID
                this.send(UserID(userID));
            }
            if (metadata != null) {
                Object.entries(metadata).forEach(([key, value]) => this.send(Metadata(key, value)));
            }
        });
        // @deprecated (use sessionHash on start instead)
        if (sessionToken != null) {
            this.session.applySessionHash(sessionToken);
        }
        const thisTab = this.session.getTabId();
        if (this.insideIframe) {
            /**
             * listen for messages from parent window, so we can signal that we're alive
             * */
            window.addEventListener('message', this.parentCrossDomainFrameListener);
            setInterval(() => {
                if (document.hidden) {
                    return;
                }
                window.parent.postMessage({
                    line: proto.polling,
                    context: this.contextId,
                }, options.crossdomain?.parentDomain ?? '*');
            }, 250);
        }
        else {
            this.initWorker();
            /**
             * if we get a signal from child iframes, we check for their node_id and send it back,
             * so they can act as if it was just a same-domain iframe
             * */
            window.addEventListener('message', this.crossDomainIframeListener);
        }
        if (this.bc !== null) {
            this.bc.postMessage({
                line: proto.ask,
                source: thisTab,
                context: this.contextId,
            });
            this.startTimeout = setTimeout(() => {
                this.allowAppStart();
            }, 250);
            this.bc.onmessage = (ev) => {
                if (ev.data.context === this.contextId) {
                    return;
                }
                if (ev.data.line === proto.resp) {
                    const sessionToken = ev.data.token;
                    this.session.setSessionToken(sessionToken);
                    this.allowAppStart();
                }
                if (ev.data.line === proto.reg) {
                    const sessionToken = ev.data.token;
                    this.session.regenerateTabId();
                    this.session.setSessionToken(sessionToken);
                    this.allowAppStart();
                }
                if (ev.data.line === proto.ask) {
                    const token = this.session.getSessionToken();
                    if (token && this.bc) {
                        this.bc.postMessage({
                            line: ev.data.source === thisTab ? proto.reg : proto.resp,
                            token,
                            source: thisTab,
                            context: this.contextId,
                        });
                    }
                }
            };
        }
    }
    allowAppStart() {
        this.canStart = true;
        if (this.startTimeout) {
            clearTimeout(this.startTimeout);
            this.startTimeout = null;
        }
    }
    async checkNodeId(source) {
        let targetFrame;
        if (this.pageFrames.length > 0) {
            targetFrame = this.pageFrames.find((frame) => frame.contentWindow === source);
        }
        if (!targetFrame || !this.pageFrames.length) {
            const pageIframes = Array.from(document.querySelectorAll('iframe'));
            this.pageFrames = pageIframes;
            targetFrame = pageIframes.find((frame) => frame.contentWindow === source);
        }
        if (!targetFrame) {
            return null;
        }
        /**
         * Here we're trying to get node id from the iframe (which is kept in observer)
         * because of async nature of dom initialization, we give 100 retries with 100ms delay each
         * which equals to 10 seconds. This way we have a period where we give app some time to load
         * and tracker some time to parse the initial DOM tree even on slower devices
         * */
        let tries = 0;
        while (tries < 100) {
            // @ts-ignore
            const potentialId = targetFrame[this.options.node_id];
            if (potentialId !== undefined) {
                tries = 100;
                return potentialId;
            }
            else {
                tries++;
                await delay(100);
            }
        }
        return null;
    }
    initWorker() {
        try {
            this.worker = new Worker(URL.createObjectURL(new Blob([workerBodyFn], { type: 'text/javascript' })));
            this.worker.onerror = (e) => {
                this._debug('webworker_error', e);
            };
            this.worker.onmessage = ({ data }) => {
                this.handleWorkerMsg(data);
            };
            const alertWorker = () => {
                if (this.worker) {
                    this.worker.postMessage(null);
                }
            };
            // keep better tactics, discard others?
            this.attachEventListener(window, 'beforeunload', alertWorker, false);
            this.attachEventListener(document.body, 'mouseleave', alertWorker, false, false);
            // TODO: stop session after inactivity timeout (make configurable)
            this.attachEventListener(document, 'visibilitychange', alertWorker, false);
        }
        catch (e) {
            this._debug('worker_start', e);
        }
    }
    handleWorkerMsg(data) {
        // handling 401 auth restart (new token assignment)
        if (data === 'a_stop') {
            this.stop(false);
        }
        else if (data === 'a_start') {
            this.waitStatus(ActivityState.NotActive).then(() => {
                this.allowAppStart();
                this.start(this.prevOpts, true)
                    .then((r) => {
                    this.debug.info('Worker restart, session too long', r);
                })
                    .catch((e) => {
                    this.debug.error('Worker restart failed', e);
                });
            });
        }
        else if (data === 'not_init') {
            this.debug.warn('OR WebWorker: writer not initialised. Restarting tracker');
        }
        else if (data.type === 'failure') {
            this.stop(false);
            this.debug.error('worker_failed', data.reason);
            this._debug('worker_failed', data.reason);
        }
        else if (data.type === 'compress') {
            const batch = data.batch;
            const batchSize = batch.byteLength;
            if (batchSize > this.compressionThreshold) {
                gzip(data.batch, { mtime: 0 }, (err, result) => {
                    if (err) {
                        this.debug.error('Openreplay compression error:', err);
                        this.worker?.postMessage({ type: 'uncompressed', batch: batch });
                    }
                    else {
                        this.worker?.postMessage({ type: 'compressed', batch: result });
                    }
                });
            }
            else {
                this.worker?.postMessage({ type: 'uncompressed', batch: batch });
            }
        }
        else if (data.type === 'queue_empty') {
            this.onSessionSent();
        }
    }
    _debug(context, e) {
        if (this.options.__debug_report_edp !== null) {
            void fetch(this.options.__debug_report_edp, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    context,
                    // @ts-ignore
                    error: `${e}`,
                }),
            });
        }
        this.debug.error('OpenReplay error: ', context, e);
    }
    send(message, urgent = false) {
        if (this.activityState === ActivityState.NotActive) {
            return;
        }
        // ====================================================
        if (this.activityState === ActivityState.ColdStart) {
            this.bufferedMessages1.push(message);
            if (!this.singleBuffer) {
                this.bufferedMessages2.push(message);
            }
            this.conditionsManager?.processMessage(message);
        }
        else {
            this.messages.push(message);
        }
        // TODO: commit on start if there were `urgent` sends;
        // Clarify where urgent can be used for;
        // Clarify workflow for each type of message in case it was sent before start
        //      (like Fetch before start; maybe add an option "preCapture: boolean" or sth alike)
        // Careful: `this.delay` is equal to zero before start so all Timestamp-s will have to be updated on start
        if (this.activityState === ActivityState.Active && urgent) {
            this.commit();
        }
    }
    /**
     * Normal workflow: add timestamp and tab data to batch, then commit it
     * every ~30ms
     * */
    _nCommit() {
        if (this.socketMode) {
            this.messages.unshift(Timestamp(this.timestamp()), TabData(this.session.getTabId()));
            this.commitCallbacks.forEach((cb) => cb(this.messages));
            this.messages.length = 0;
            return;
        }
        if (this.insideIframe) {
            window.parent.postMessage({
                line: proto.iframeBatch,
                messages: this.messages,
            }, this.options.crossdomain?.parentDomain ?? '*');
            this.commitCallbacks.forEach((cb) => cb(this.messages));
            this.messages.length = 0;
            return;
        }
        if (this.worker === undefined || !this.messages.length) {
            return;
        }
        if (!this.messages.length) {
            // Release empty batches every 30 secs (1000 * 30ms)
            if (this.emptyBatchCounter < 1000) {
                this.emptyBatchCounter++;
                return;
            }
        }
        this.emptyBatchCounter = 0;
        try {
            requestIdleCb(() => {
                this.messages.unshift(Timestamp(this.timestamp()), TabData(this.session.getTabId()));
                this.worker?.postMessage(this.messages);
                this.commitCallbacks.forEach((cb) => cb(this.messages));
                this.messages.length = 0;
            });
        }
        catch (e) {
            this._debug('worker_commit', e);
            this.stop(true);
            setTimeout(() => {
                void this.start();
            }, 500);
        }
    }
    /**
     * Cold start: add timestamp and tab data to both batches
     * every 2nd tick, ~60ms
     * this will make batches a bit larger and replay will work with bigger jumps every frame
     * but in turn we don't overload batch writer on session start with 1000 batches
     * */
    _cStartCommit() {
        this.coldStartCommitN += 1;
        if (this.coldStartCommitN === 2) {
            const payload = [Timestamp(this.timestamp()), TabData(this.session.getTabId())];
            this.bufferedMessages1.push(...payload);
            this.bufferedMessages2.push(...payload);
            this.coldStartCommitN = 0;
        }
    }
    commit() {
        if (this.activityState === ActivityState.ColdStart) {
            this._cStartCommit();
        }
        else {
            this._nCommit();
        }
    }
    postToWorker(messages) {
        this.worker?.postMessage(messages);
        this.commitCallbacks.forEach((cb) => cb(messages));
    }
    timestamp() {
        return now() + this.delay;
    }
    safe(fn) {
        const app = this;
        return function (...args) {
            try {
                fn.apply(this, args);
            }
            catch (e) {
                app._debug('safe_fn_call', e);
                // time: this.timestamp(),
                // name: e.name,
                // message: e.message,
                // stack: e.stack
            }
        }; // TODO: correct typing
    }
    attachCommitCallback(cb) {
        this.commitCallbacks.push(cb);
    }
    // TODO: full correct semantic
    checkRequiredVersion(version) {
        const reqVer = version.split(/[.-]/);
        const ver = this.version.split(/[.-]/);
        for (let i = 0; i < 3; i++) {
            if (isNaN(Number(ver[i])) || isNaN(Number(reqVer[i]))) {
                return false;
            }
            if (Number(ver[i]) > Number(reqVer[i])) {
                return true;
            }
            if (Number(ver[i]) < Number(reqVer[i])) {
                return false;
            }
        }
        return true;
    }
    getTrackerInfo() {
        return {
            userUUID: this.localStorage.getItem(this.options.local_uuid_key),
            projectKey: this.projectKey,
            revID: this.revID,
            trackerVersion: this.version,
            isSnippet: this.options.__is_snippet,
        };
    }
    getSessionInfo() {
        return {
            ...this.session.getInfo(),
            ...this.getTrackerInfo(),
        };
    }
    getSessionToken() {
        return this.session.getSessionToken();
    }
    getSessionID() {
        return this.session.getInfo().sessionID || undefined;
    }
    getSessionURL(options) {
        const { projectID, sessionID, timestamp } = this.session.getInfo();
        if (!projectID || !sessionID) {
            this.debug.error('OpenReplay error: Unable to build session URL');
            return undefined;
        }
        const ingest = this.options.ingestPoint;
        const isSaas = /api\.openreplay\.com/.test(ingest);
        const projectPath = isSaas ? 'https://app.openreplay.com/ingest' : ingest;
        const url = projectPath.replace(/ingest$/, `${projectID}/session/${sessionID}`);
        if (options?.withCurrentTime) {
            const jumpTo = now() - timestamp;
            return `${url}?jumpto=${jumpTo}`;
        }
        return url;
    }
    getHost() {
        return new URL(this.options.ingestPoint).host;
    }
    getProjectKey() {
        return this.projectKey;
    }
    getBaseHref() {
        if (typeof this.options.resourceBaseHref === 'string') {
            return this.options.resourceBaseHref;
        }
        else if (typeof this.options.resourceBaseHref === 'object') ;
        if (document.baseURI) {
            return document.baseURI;
        }
        // IE only
        return (document.head?.getElementsByTagName('base')[0]?.getAttribute('href') ||
            location.origin + location.pathname);
    }
    resolveResourceURL(resourceURL) {
        const base = new URL(this.getBaseHref());
        base.pathname += '/' + new URL(resourceURL).pathname;
        base.pathname.replace(/\/+/g, '/');
        return base.toString();
    }
    isServiceURL(url) {
        return url.startsWith(this.options.ingestPoint);
    }
    active() {
        return this.activityState === ActivityState.Active;
    }
    resetNextPageSession(flag) {
        if (flag) {
            this.sessionStorage.setItem(this.options.session_reset_key, 't');
        }
        else {
            this.sessionStorage.removeItem(this.options.session_reset_key);
        }
    }
    checkSessionToken(forceNew) {
        const lsReset = this.sessionStorage.getItem(this.options.session_reset_key) !== null;
        const needNewSessionID = forceNew || lsReset;
        const sessionToken = this.session.getSessionToken();
        return needNewSessionID || !sessionToken;
    }
    /**
     * start buffering messages without starting the actual session, which gives
     * user 30 seconds to "activate" and record session by calling `start()` on conditional trigger,
     * and we will then send buffered batch, so it won't get lost
     * */
    async coldStart(startOpts = {}, conditional) {
        this.singleBuffer = false;
        const second = 1000;
        const isNewSession = this.checkSessionToken(startOpts.forceNew);
        if (conditional) {
            await this.setupConditionalStart(startOpts);
        }
        const cycle = () => {
            this.orderNumber += 1;
            adjustTimeOrigin();
            this.coldStartTs = now();
            if (this.orderNumber % 2 === 0) {
                this.bufferedMessages1.length = 0;
                this.bufferedMessages1.push(Timestamp(this.timestamp()));
                this.bufferedMessages1.push(TabData(this.session.getTabId()));
            }
            else {
                this.bufferedMessages2.length = 0;
                this.bufferedMessages2.push(Timestamp(this.timestamp()));
                this.bufferedMessages2.push(TabData(this.session.getTabId()));
            }
            this.stop(false);
            this.activityState = ActivityState.ColdStart;
            if (startOpts.sessionHash) {
                this.session.applySessionHash(startOpts.sessionHash);
            }
            if (startOpts.forceNew) {
                this.session.reset();
            }
            this.session.assign({
                userID: startOpts.userID,
                metadata: startOpts.metadata,
            });
            if (!isNewSession) {
                this.debug.log('continuing session on new tab', this.session.getTabId());
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                this.send(TabChange(this.session.getTabId()));
            }
            this.observer.observe();
            this.ticker.start();
        };
        this.coldInterval = setInterval(() => {
            cycle();
        }, 30 * second);
        cycle();
    }
    async setupConditionalStart(startOpts) {
        this.conditionsManager = new ConditionsManager(this, startOpts);
        const r = await fetch(this.options.ingestPoint + '/v1/web/start', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                ...this.getTrackerInfo(),
                timestamp: now(),
                doNotRecord: true,
                bufferDiff: 0,
                userID: this.session.getInfo().userID,
                token: undefined,
                deviceMemory,
                jsHeapSizeLimit,
                timezone: getTimezone(),
                width: window.screen.width,
                height: window.screen.height,
            }),
        });
        const { 
        // this token is needed to fetch conditions and flags,
        // but it can't be used to record a session
        token, userBrowser, userCity, userCountry, userDevice, userOS, userState, projectID, features, } = await r.json();
        this.features = features ? features : this.features;
        this.session.assign({ projectID });
        this.session.setUserInfo({
            userBrowser,
            userCity,
            userCountry,
            userDevice,
            userOS,
            userState,
        });
        const onStartInfo = { sessionToken: token, userUUID: '', sessionID: '' };
        this.startCallbacks.forEach((cb) => cb(onStartInfo));
        await this.conditionsManager?.fetchConditions(projectID, token);
        if (this.features['feature-flags']) {
            await this.featureFlags.reloadFlags(token);
            this.conditionsManager?.processFlags(this.featureFlags.flags);
        }
        await this.tagWatcher.fetchTags(this.options.ingestPoint, token);
    }
    /**
     * Starts offline session recording
     * @param {Object} startOpts - options for session start, same as .start()
     * @param {Function} onSessionSent - callback that will be called once session is fully sent
     * */
    offlineRecording(startOpts = {}, onSessionSent) {
        this.onSessionSent = onSessionSent;
        this.singleBuffer = true;
        const isNewSession = this.checkSessionToken(startOpts.forceNew);
        adjustTimeOrigin();
        this.coldStartTs = now();
        const saverBuffer = this.localStorage.getItem(bufferStorageKey);
        if (saverBuffer) {
            const data = JSON.parse(saverBuffer);
            this.bufferedMessages1 = Array.isArray(data) ? data : this.bufferedMessages1;
            this.localStorage.removeItem(bufferStorageKey);
        }
        this.bufferedMessages1.push(Timestamp(this.timestamp()));
        this.bufferedMessages1.push(TabData(this.session.getTabId()));
        this.activityState = ActivityState.ColdStart;
        if (startOpts.sessionHash) {
            this.session.applySessionHash(startOpts.sessionHash);
        }
        if (startOpts.forceNew) {
            this.session.reset();
        }
        this.session.assign({
            userID: startOpts.userID,
            metadata: startOpts.metadata,
        });
        const onStartInfo = { sessionToken: '', userUUID: '', sessionID: '' };
        this.startCallbacks.forEach((cb) => cb(onStartInfo));
        if (!isNewSession) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
            this.send(TabChange(this.session.getTabId()));
        }
        this.observer.observe();
        this.ticker.start();
        return {
            saveBuffer: this.saveBuffer,
            getBuffer: this.getBuffer,
            setBuffer: this.setBuffer,
        };
    }
    /**
     * Saves the captured messages in localStorage (or whatever is used in its place)
     *
     * Then, when this.offlineRecording is called, it will preload this messages and clear the storage item
     *
     * Keeping the size of local storage reasonable is up to the end users of this library
     * */
    saveBuffer() {
        this.localStorage.setItem(bufferStorageKey, JSON.stringify(this.bufferedMessages1));
    }
    /**
     * @returns buffer with stored messages for offline recording
     * */
    getBuffer() {
        return this.bufferedMessages1;
    }
    /**
     * Used to set a buffer with messages array
     * */
    setBuffer(buffer) {
        this.bufferedMessages1 = buffer;
    }
    /**
     * Uploads the stored session buffer to backend
     * @returns promise that resolves once messages are loaded, it has to be awaited
     * so the session can be uploaded properly
     * @resolve - if messages were loaded in service worker successfully
     * @reject {string} - error message
     * */
    async uploadOfflineRecording() {
        this.stop(false);
        const timestamp = now();
        this.worker?.postMessage({
            type: 'start',
            pageNo: this.session.incPageNo(),
            ingestPoint: this.options.ingestPoint,
            timestamp: this.coldStartTs,
            url: document.URL,
            connAttemptCount: this.options.connAttemptCount,
            connAttemptGap: this.options.connAttemptGap,
            tabId: this.session.getTabId(),
        });
        const r = await fetch(this.options.ingestPoint + '/v1/web/start', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                ...this.getTrackerInfo(),
                timestamp: timestamp,
                doNotRecord: false,
                bufferDiff: timestamp - this.coldStartTs,
                userID: this.session.getInfo().userID,
                token: undefined,
                deviceMemory,
                jsHeapSizeLimit,
                timezone: getTimezone(),
            }),
        });
        const { token, userBrowser, userCity, userCountry, userDevice, userOS, userState, beaconSizeLimit, projectID, } = await r.json();
        this.worker?.postMessage({
            type: 'auth',
            token,
            beaconSizeLimit,
        });
        this.session.assign({ projectID });
        this.session.setUserInfo({
            userBrowser,
            userCity,
            userCountry,
            userDevice,
            userOS,
            userState,
        });
        while (this.bufferedMessages1.length > 0) {
            await this.flushBuffer(this.bufferedMessages1);
        }
        this.postToWorker([['q_end']]);
        this.clearBuffers();
    }
    async _start(startOpts = {}, resetByWorker = false, conditionName) {
        if (Object.keys(startOpts).length !== 0) {
            this.prevOpts = startOpts;
        }
        const isColdStart = this.activityState === ActivityState.ColdStart;
        if (isColdStart && this.coldInterval) {
            clearInterval(this.coldInterval);
        }
        if (!this.worker && !this.insideIframe) {
            const reason = 'No worker found: perhaps, CSP is not set.';
            this.signalError(reason, []);
            return Promise.resolve(UnsuccessfulStart(reason));
        }
        if (this.activityState === ActivityState.Active ||
            this.activityState === ActivityState.Starting) {
            const reason = 'OpenReplay: trying to call `start()` on the instance that has been started already.';
            return Promise.resolve(UnsuccessfulStart(reason));
        }
        this.activityState = ActivityState.Starting;
        if (!isColdStart) {
            adjustTimeOrigin();
        }
        if (startOpts.sessionHash) {
            this.session.applySessionHash(startOpts.sessionHash);
        }
        if (startOpts.forceNew) {
            // Reset session metadata only if requested directly
            this.session.reset();
        }
        this.session.assign({
            // MBTODO: maybe it would make sense to `forceNew` if the `userID` was changed
            userID: startOpts.userID,
            metadata: startOpts.metadata,
        });
        const timestamp = now();
        this.worker?.postMessage({
            type: 'start',
            pageNo: this.session.incPageNo(),
            ingestPoint: this.options.ingestPoint,
            timestamp: isColdStart ? this.coldStartTs : timestamp,
            url: document.URL,
            connAttemptCount: this.options.connAttemptCount,
            connAttemptGap: this.options.connAttemptGap,
            tabId: this.session.getTabId(),
        });
        const sessionToken = this.session.getSessionToken();
        const isNewSession = this.checkSessionToken(startOpts.forceNew);
        this.sessionStorage.removeItem(this.options.session_reset_key);
        this.debug.log('OpenReplay: starting session; need new session id?', isNewSession, 'session token: ', sessionToken);
        try {
            const r = await window.fetch(this.options.ingestPoint + '/v1/web/start', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    ...this.getTrackerInfo(),
                    timestamp,
                    doNotRecord: false,
                    bufferDiff: timestamp - this.coldStartTs,
                    userID: this.session.getInfo().userID,
                    token: isNewSession ? undefined : sessionToken,
                    deviceMemory,
                    jsHeapSizeLimit,
                    timezone: getTimezone(),
                    condition: conditionName,
                    assistOnly: startOpts.assistOnly ?? this.socketMode,
                    width: window.screen.width,
                    height: window.screen.height,
                }),
            });
            if (r.status !== 200) {
                const error = await r.text();
                const reason = error === CANCELED ? CANCELED : `Server error: ${r.status}. ${error}`;
                return UnsuccessfulStart(reason);
            }
            if (!this.worker && !this.insideIframe) {
                const reason = 'no worker found after start request (this should not happen in real world)';
                this.signalError(reason, []);
                return UnsuccessfulStart(reason);
            }
            const { token, userUUID, projectID, beaconSizeLimit, compressionThreshold, // how big the batch should be before we decide to compress it
            delay, //  derived from token
            sessionID, //  derived from token
            startTimestamp, // real startTS (server time), derived from sessionID
            userBrowser, userCity, userCountry, userDevice, userOS, userState, canvasEnabled, canvasQuality, canvasFPS, assistOnly: socketOnly, features, } = await r.json();
            this.features = features ? features : this.features;
            if (typeof token !== 'string' ||
                typeof userUUID !== 'string' ||
                (typeof startTimestamp !== 'number' && typeof startTimestamp !== 'undefined') ||
                typeof sessionID !== 'string' ||
                typeof delay !== 'number' ||
                (typeof beaconSizeLimit !== 'number' && typeof beaconSizeLimit !== 'undefined')) {
                const reason = `Incorrect server response: ${JSON.stringify(r)}`;
                this.signalError(reason, []);
                return UnsuccessfulStart(reason);
            }
            this.delay = delay;
            this.session.setSessionToken(token);
            this.session.setUserInfo({
                userBrowser,
                userCity,
                userCountry,
                userDevice,
                userOS,
                userState,
            });
            this.session.assign({
                sessionID,
                timestamp: startTimestamp || timestamp,
                projectID,
            });
            if (socketOnly) {
                this.socketMode = true;
                this.worker?.postMessage('stop');
            }
            else {
                this.worker?.postMessage({
                    type: 'auth',
                    token,
                    beaconSizeLimit,
                });
            }
            if (!isNewSession && token === sessionToken) {
                this.debug.log('continuing session on new tab', this.session.getTabId());
                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                this.send(TabChange(this.session.getTabId()));
            }
            // (Re)send Metadata for the case of a new session
            Object.entries(this.session.getInfo().metadata).forEach(([key, value]) => this.send(Metadata(key, value)));
            this.localStorage.setItem(this.options.local_uuid_key, userUUID);
            this.compressionThreshold = compressionThreshold;
            const onStartInfo = { sessionToken: token, userUUID, sessionID };
            // TODO: start as early as possible (before receiving the token)
            /** after start */
            this.startCallbacks.forEach((cb) => cb(onStartInfo)); // MBTODO: callbacks after DOM "mounted" (observed)
            if (startOpts.startCallback) {
                startOpts.startCallback(SuccessfulStart(onStartInfo));
            }
            if (this.features['feature-flags']) {
                void this.featureFlags.reloadFlags();
            }
            await this.tagWatcher.fetchTags(this.options.ingestPoint, token);
            this.activityState = ActivityState.Active;
            if (this.options.crossdomain?.enabled && !this.insideIframe) {
                void this.bootChildrenFrames();
            }
            if (canvasEnabled && !this.options.canvas.disableCanvas) {
                this.canvasRecorder =
                    this.canvasRecorder ??
                        new CanvasRecorder(this, {
                            fps: canvasFPS,
                            quality: canvasQuality,
                            isDebug: this.options.canvas.__save_canvas_locally,
                            fixedScaling: this.options.canvas.fixedCanvasScaling,
                            useAnimationFrame: this.options.canvas.useAnimationFrame,
                        });
            }
            /** --------------- COLD START BUFFER ------------------*/
            if (isColdStart) {
                const biggestBuffer = this.bufferedMessages1.length > this.bufferedMessages2.length
                    ? this.bufferedMessages1
                    : this.bufferedMessages2;
                while (biggestBuffer.length > 0) {
                    await this.flushBuffer(biggestBuffer);
                }
                this.clearBuffers();
                this.commit();
                /** --------------- COLD START BUFFER ------------------*/
            }
            else {
                if (this.insideIframe && this.rootId) {
                    this.observer.crossdomainObserve(this.rootId, this.frameOderNumber);
                }
                else {
                    this.observer.observe();
                }
                this.ticker.start();
            }
            this.canvasRecorder?.startTracking();
            if (this.features['usability-test'] && !this.insideIframe) {
                this.uxtManager = this.uxtManager
                    ? this.uxtManager
                    : new UserTestManager(this, uxtStorageKey);
                let uxtId;
                const savedUxtTag = this.localStorage.getItem(uxtStorageKey);
                if (savedUxtTag) {
                    uxtId = parseInt(savedUxtTag, 10);
                }
                if (location?.search) {
                    const query = new URLSearchParams(location.search);
                    if (query.has('oruxt')) {
                        const qId = query.get('oruxt');
                        uxtId = qId ? parseInt(qId, 10) : undefined;
                    }
                }
                if (uxtId) {
                    if (!this.uxtManager.isActive) {
                        // eslint-disable-next-line
                        this.uxtManager.getTest(uxtId, token, Boolean(savedUxtTag)).then((id) => {
                            if (id) {
                                this.onUxtCb.forEach((cb) => cb(id));
                            }
                        });
                    }
                    else {
                        // @ts-ignore
                        this.onUxtCb.forEach((cb) => cb(uxtId));
                    }
                }
            }
            return SuccessfulStart(onStartInfo);
        }
        catch (reason) {
            this.stop();
            this.session.reset();
            if (!reason) {
                console.error('Unknown error during start');
                this.signalError('Unknown error', []);
                return UnsuccessfulStart('Unknown error');
            }
            if (reason === CANCELED) {
                this.signalError(CANCELED, []);
                return UnsuccessfulStart(CANCELED);
            }
            this._debug('session_start', reason);
            const errorMessage = reason instanceof Error ? reason.message : reason.toString();
            this.signalError(errorMessage, []);
            return UnsuccessfulStart(errorMessage);
        }
    }
    addOnUxtCb(cb) {
        // @ts-ignore
        this.onUxtCb.push(cb);
    }
    getUxtId() {
        return this.uxtManager?.getTestId();
    }
    async waitStart() {
        return new Promise((resolve) => {
            const int = setInterval(() => {
                if (this.canStart) {
                    clearInterval(int);
                    resolve(true);
                }
            }, 100);
        });
    }
    async waitStarted() {
        return this.waitStatus(ActivityState.Active);
    }
    async waitStatus(status) {
        return new Promise((resolve) => {
            const check = () => {
                if (this.activityState === status) {
                    resolve(true);
                }
                else {
                    setTimeout(check, 25);
                }
            };
            check();
        });
    }
    /**
     * basically we ask other tabs during constructor
     * and here we just apply 10ms delay just in case
     * */
    async start(...args) {
        if (this.activityState === ActivityState.Active ||
            this.activityState === ActivityState.Starting) {
            const reason = 'OpenReplay: trying to call `start()` on the instance that has been started already.';
            return Promise.resolve(UnsuccessfulStart(reason));
        }
        if (this.insideIframe) {
            this.signalIframeTracker();
        }
        if (!document.hidden) {
            await this.waitStart();
            return this._start(...args);
        }
        else {
            return new Promise((resolve) => {
                const onVisibilityChange = async () => {
                    if (!document.hidden) {
                        await this.waitStart();
                        // eslint-disable-next-line
                        document.removeEventListener('visibilitychange', onVisibilityChange);
                        resolve(this._start(...args));
                    }
                };
                // eslint-disable-next-line
                document.addEventListener('visibilitychange', onVisibilityChange);
            });
        }
    }
    forceFlushBatch() {
        this.worker?.postMessage('forceFlushBatch');
    }
    getTabId() {
        return this.session.getTabId();
    }
    clearBuffers() {
        this.bufferedMessages1.length = 0;
        this.bufferedMessages2.length = 0;
    }
    /**
     * Creates a named hook that expects event name, data string and msg direction (up/down),
     * it will skip any message bigger than 5 mb or event name bigger than 255 symbols
     * @returns {(msgType: string, data: string, dir: "up" | "down") => void}
     * */
    trackWs(channelName) {
        const channel = channelName;
        return (msgType, data, dir = 'down') => {
            if (typeof msgType !== 'string' ||
                typeof data !== 'string' ||
                data.length > 5 * 1024 * 1024 ||
                msgType.length > 255) {
                return;
            }
            this.send(WSChannel('websocket', channel, data, this.timestamp(), dir, msgType));
        };
    }
    stop(stopWorker = true) {
        if (this.activityState !== ActivityState.NotActive) {
            try {
                if (!this.insideIframe && this.options.crossdomain?.enabled) {
                    this.killChildrenFrames();
                }
                this.attributeSender.clear();
                this.sanitizer.clear();
                this.observer.disconnect();
                this.nodes.clear();
                this.ticker.stop();
                this.stopCallbacks.forEach((cb) => cb());
                this.tagWatcher.clear();
                if (this.worker && stopWorker) {
                    this.worker.postMessage('stop');
                }
                this.canvasRecorder?.clear();
                this.messages.length = 0;
                this.parentActive = false;
            }
            finally {
                this.activityState = ActivityState.NotActive;
                this.debug.log('OpenReplay tracking stopped.');
            }
        }
    }
}

function Connection (app) {
    const connection = navigator.connection ||
        navigator.mozConnection ||
        navigator.webkitConnection;
    if (connection === undefined) {
        return;
    }
    const sendConnectionInformation = () => app.send(ConnectionInformation(Math.round(connection.downlink * 1000), connection.type || 'unknown'));
    sendConnectionInformation();
    connection.addEventListener('change', sendConnectionInformation);
}

const printError = IN_BROWSER && 'InstallTrigger' in window // detect Firefox
    ? (e) => e.message + '\n' + e.stack
    : (e) => e.stack || e.message;
function printString(arg) {
    if (arg === undefined) {
        return 'undefined';
    }
    if (arg === null) {
        return 'null';
    }
    if (arg instanceof Error) {
        return printError(arg);
    }
    if (Array.isArray(arg)) {
        return `Array(${arg.length})`;
    }
    return String(arg);
}
function printFloat(arg) {
    if (typeof arg !== 'number')
        return 'NaN';
    return arg.toString();
}
function printInt(arg) {
    if (typeof arg !== 'number')
        return 'NaN';
    return Math.floor(arg).toString();
}
function printObject(arg) {
    if (arg === undefined) {
        return 'undefined';
    }
    if (arg === null) {
        return 'null';
    }
    if (arg instanceof Error) {
        return printError(arg);
    }
    if (Array.isArray(arg)) {
        const length = arg.length;
        const values = arg.slice(0, 10).map(printString).join(', ');
        return `Array(${length})[${values}]`;
    }
    if (typeof arg === 'object') {
        const res = [];
        let i = 0;
        for (const k in arg) {
            if (++i === 10) {
                break;
            }
            const v = arg[k];
            res.push(k + ': ' + printString(v));
        }
        return '{' + res.join(', ') + '}';
    }
    return arg.toString();
}
function printf(args) {
    if (typeof args[0] === 'string') {
        args.unshift(args.shift().replace(/%(o|s|f|d|i)/g, (s, t) => {
            const arg = args.shift();
            if (arg === undefined)
                return s;
            switch (t) {
                case 'o':
                    return printObject(arg);
                case 's':
                    return printString(arg);
                case 'f':
                    return printFloat(arg);
                case 'd':
                case 'i':
                    return printInt(arg);
                default:
                    return s;
            }
        }));
    }
    return args.map(printObject).join(' ');
}
const consoleMethods = ['log', 'info', 'warn', 'error', 'debug', 'assert'];
function Console (app, opts) {
    const options = Object.assign({
        consoleMethods,
        consoleThrottling: 30,
    }, opts);
    if (!Array.isArray(options.consoleMethods) || options.consoleMethods.length === 0) {
        return;
    }
    const sendConsoleLog = app.safe((level, args) => {
        let logMsg = printf(args);
        if (app.sanitizer.privateMode) {
            logMsg = logMsg.replaceAll(/./g, '*');
        }
        app.send(ConsoleLog(level, logMsg));
    });
    let n = 0;
    const reset = () => {
        n = 0;
    };
    app.attachStartCallback(reset);
    app.ticker.attach(reset, 33, false);
    const patchConsole = (console, ctx) => {
        const handler = {
            apply: function (target, thisArg, argumentsList) {
                Reflect.apply(target, ctx, argumentsList);
                n = n + 1;
                if (n > options.consoleThrottling) {
                    return;
                }
                else {
                    sendConsoleLog(target.name, argumentsList);
                }
            },
        };
        options.consoleMethods.forEach((method) => {
            if (consoleMethods.indexOf(method) === -1) {
                app.debug.error(`OpenReplay: unsupported console method "${method}"`);
                return;
            }
            const fn = ctx.console[method];
            console[method] = new Proxy(fn, handler);
        });
    };
    const patchContext = app.safe((context) => patchConsole(context.console, context));
    patchContext(window);
    app.observer.attachContextCallback(patchContext);
}

const FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
const CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
const SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code\])?$/;
function parse$1(error, options) {
  if (typeof error.stacktrace !== "undefined" || typeof error["opera#sourceloc"] !== "undefined")
    return parseOpera(error);
  else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP))
    return parseV8OrIE(error);
  else if (error.stack)
    return parseFFOrSafari(error);
  else throw new Error("Cannot parse given Error object");
}
function extractLocation(urlLike) {
  if (!urlLike.includes(":"))
    return [urlLike, void 0, void 0];
  const regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
  const parts = regExp.exec(urlLike.replace(/[()]/g, ""));
  return [parts[1], parts[2] || void 0, parts[3] || void 0];
}
function applySlice(lines, options) {
  return lines;
}
function parseV8OrIE(error, options) {
  return parseV8OrIeString(error.stack);
}
function parseV8OrIeString(stack, options) {
  const filtered = applySlice(
    stack.split("\n").filter((line) => {
      return !!line.match(CHROME_IE_STACK_REGEXP);
    }));
  return filtered.map((line) => {
    if (line.includes("(eval ")) {
      line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(,.*$)/g, "");
    }
    let sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(").replace(/^.*?\s+/, "");
    const location = sanitizedLine.match(/ (\(.+\)$)/);
    sanitizedLine = location ? sanitizedLine.replace(location[0], "") : sanitizedLine;
    const locationParts = extractLocation(location ? location[1] : sanitizedLine);
    const functionName = location && sanitizedLine || void 0;
    const fileName = ["eval", "<anonymous>"].includes(locationParts[0]) ? void 0 : locationParts[0];
    return {
      function: functionName,
      file: fileName,
      line: locationParts[1] ? +locationParts[1] : void 0,
      col: locationParts[2] ? +locationParts[2] : void 0,
      raw: line
    };
  });
}
function parseFFOrSafari(error, options) {
  return parseFFOrSafariString(error.stack);
}
function parseFFOrSafariString(stack, options) {
  const filtered = applySlice(
    stack.split("\n").filter((line) => {
      return !line.match(SAFARI_NATIVE_CODE_REGEXP);
    }));
  return filtered.map((line) => {
    if (line.includes(" > eval"))
      line = line.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g, ":$1");
    if (!line.includes("@") && !line.includes(":")) {
      return {
        function: line
      };
    } else {
      const functionNameRegex = /(([^\n\r"\u2028\u2029]*".[^\n\r"\u2028\u2029]*"[^\n\r@\u2028\u2029]*(?:@[^\n\r"\u2028\u2029]*"[^\n\r@\u2028\u2029]*)*(?:[\n\r\u2028\u2029][^@]*)?)?[^@]*)@/;
      const matches = line.match(functionNameRegex);
      const functionName = matches && matches[1] ? matches[1] : void 0;
      const locationParts = extractLocation(line.replace(functionNameRegex, ""));
      return {
        function: functionName,
        file: locationParts[0],
        line: locationParts[1] ? +locationParts[1] : void 0,
        col: locationParts[2] ? +locationParts[2] : void 0,
        raw: line
      };
    }
  });
}
function parseOpera(e, options) {
  if (!e.stacktrace || e.message.includes("\n") && e.message.split("\n").length > e.stacktrace.split("\n").length)
    return parseOpera9(e);
  else if (!e.stack)
    return parseOpera10(e);
  else
    return parseOpera11(e);
}
function parseOpera9(e, options) {
  const lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
  const lines = e.message.split("\n");
  const result = [];
  for (let i = 2, len = lines.length; i < len; i += 2) {
    const match = lineRE.exec(lines[i]);
    if (match) {
      result.push({
        file: match[2],
        line: +match[1],
        raw: lines[i]
      });
    }
  }
  return applySlice(result);
}
function parseOpera10(e, options) {
  const lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
  const lines = e.stacktrace.split("\n");
  const result = [];
  for (let i = 0, len = lines.length; i < len; i += 2) {
    const match = lineRE.exec(lines[i]);
    if (match) {
      result.push({
        function: match[3] || void 0,
        file: match[2],
        line: match[1] ? +match[1] : void 0,
        raw: lines[i]
      });
    }
  }
  return applySlice(result);
}
function parseOpera11(error, options) {
  const filtered = applySlice(
    // @ts-expect-error missing stack property
    error.stack.split("\n").filter((line) => {
      return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
    }));
  return filtered.map((line) => {
    const tokens = line.split("@");
    const locationParts = extractLocation(tokens.pop());
    const functionCall = tokens.shift() || "";
    const functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || void 0;
    let argsRaw;
    if (functionCall.match(/\(([^)]*)\)/))
      argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, "$1");
    const args = argsRaw === void 0 || argsRaw === "[arguments not available]" ? void 0 : argsRaw.split(",");
    return {
      function: functionName,
      args,
      file: locationParts[0],
      line: locationParts[1] ? +locationParts[1] : void 0,
      col: locationParts[2] ? +locationParts[2] : void 0,
      raw: line
    };
  });
}

function stackframesLiteToStackframes(liteStackframes) {
  return liteStackframes.map((liteStackframe) => {
    return {
      functionName: liteStackframe.function,
      args: liteStackframe.args,
      fileName: liteStackframe.file,
      lineNumber: liteStackframe.line,
      columnNumber: liteStackframe.col,
      source: liteStackframe.raw
    };
  });
}
function parse(error, options) {
  return stackframesLiteToStackframes(parse$1(error));
}

function getDefaultStack(e) {
    return [
        {
            columnNumber: e.colno,
            lineNumber: e.lineno,
            fileName: e.filename,
            functionName: '',
            source: '',
        },
    ];
}
function getExceptionMessage(error, fallbackStack, metadata = {}) {
    let stack = fallbackStack;
    try {
        stack = parse(error);
    }
    catch (e) { }
    return JSException(error.name, error.message, JSON.stringify(stack), JSON.stringify(metadata));
}
function getExceptionMessageFromEvent(e, context = window, metadata = {}) {
    if (e instanceof ErrorEvent) {
        if (e.error instanceof Error) {
            return getExceptionMessage(e.error, getDefaultStack(e), metadata);
        }
        else {
            let [name, message] = e.message.split(':');
            if (!message) {
                name = 'Error';
                message = e.message;
            }
            return JSException(name, message, JSON.stringify(getDefaultStack(e)), JSON.stringify(metadata));
        }
    }
    else if ('PromiseRejectionEvent' in context && e instanceof context.PromiseRejectionEvent) {
        if (e.reason instanceof Error) {
            return getExceptionMessage(e.reason, [], metadata);
        }
        else {
            let message;
            try {
                message = JSON.stringify(e.reason);
            }
            catch (_) {
                message = String(e.reason);
            }
            return JSException('Unhandled Promise Rejection', message, '[]', JSON.stringify(metadata));
        }
    }
    return null;
}
function Exception (app, opts) {
    const options = Object.assign({
        captureExceptions: true,
    }, opts);
    function patchContext(context) {
        function handler(e) {
            const msg = getExceptionMessageFromEvent(e, context);
            if (msg != null) {
                app.send(msg);
            }
        }
        try {
            app.attachEventListener(context, 'unhandledrejection', handler);
            app.attachEventListener(context, 'error', handler);
        }
        catch (e) {
            console.error('Error while attaching to error proto contexts', e);
        }
    }
    if (options.captureExceptions) {
        app.observer.attachContextCallback(patchContext); // TODO: attach once-per-iframe (?)
        patchContext(window);
    }
}

function resolveURL(url, location = document.location) {
    url = url.trim();
    if (url.startsWith('//') ||
        url.startsWith('http://') ||
        url.startsWith('https://') ||
        url.startsWith('data:') // any other possible value here? https://bugzilla.mozilla.org/show_bug.cgi?id=1758035
    ) {
        return url;
    }
    else if (url.startsWith('/')) {
        return location.origin + url;
    }
    else {
        return location.origin + location.pathname + url;
    }
}
// https://bugzilla.mozilla.org/show_bug.cgi?id=1607081
function isSVGInFireFox(url) {
    return IS_FIREFOX && (url.startsWith('data:image/svg+xml') || url.match(/.svg$|/i));
}
const PLACEHOLDER_SRC = 'https://static.openreplay.com/tracker/placeholder.jpeg';
function Img (app) {
    function sendPlaceholder(id, node) {
        app.attributeSender.sendSetAttribute(id, 'src', PLACEHOLDER_SRC);
        const { width, height } = node.getBoundingClientRect();
        if (!node.hasAttribute('width')) {
            app.attributeSender.sendSetAttribute(id, 'width', String(width));
        }
        if (!node.hasAttribute('height')) {
            app.attributeSender.sendSetAttribute(id, 'height', String(height));
        }
    }
    const sendSrcset = function (id, img) {
        const { srcset } = img;
        if (!srcset) {
            return;
        }
        const resolvedSrcset = srcset
            .split(srcset.match(/,\s+/) ? /,\s+/ : ',')
            .map((str) => resolveURL(str))
            .join(', ');
        app.attributeSender.sendSetAttribute(id, 'srcset', resolvedSrcset);
    };
    const sendSrc = function (id, img) {
        if (img.src.length > MAX_STR_LEN) {
            sendPlaceholder(id, img);
        }
        app.send(SetNodeAttributeURLBased(id, 'src', img.src, app.getBaseHref()));
    };
    const sendImgError = app.safe(function (img) {
        const resolvedSrc = resolveURL(img.src || ''); // Src type is null sometimes. - is it true?
        if (isURL(resolvedSrc)) {
            app.send(ResourceTiming(app.timestamp(), 0, 0, 0, 0, 0, resolvedSrc, 'img', 0, false));
        }
    });
    const sendImgAttrs = app.safe(function (img) {
        const id = app.nodes.getID(img);
        if (id === undefined) {
            return;
        }
        if (!img.complete) {
            return;
        }
        if (img.naturalHeight === 0 && img.naturalWidth === 0 && !isSVGInFireFox(img.src)) {
            sendImgError(img);
        }
        else if (app.sanitizer.isHidden(id) || app.sanitizer.isObscured(id)) {
            sendPlaceholder(id, img);
        }
        else {
            sendSrc(id, img);
            sendSrcset(id, img);
        }
    });
    const observer = createMutationObserver(app.safe((mutations) => {
        for (const mutation of mutations) {
            if (mutation.type === 'attributes') {
                const target = mutation.target;
                const id = app.nodes.getID(target);
                if (id === undefined) {
                    return;
                }
                if (mutation.attributeName === 'src') {
                    sendSrc(id, target);
                }
                if (mutation.attributeName === 'srcset') {
                    sendSrcset(id, target);
                }
            }
        }
    }), app.options.forceNgOff);
    app.attachStopCallback(() => {
        observer.disconnect();
    });
    app.nodes.attachNodeCallback((node) => {
        if (!hasTag(node, 'img')) {
            return;
        }
        app.nodes.attachNodeListener(node, 'error', () => sendImgError(node));
        app.nodes.attachNodeListener(node, 'load', () => sendImgAttrs(node));
        sendImgAttrs(node);
        observer.observe(node, { attributes: true, attributeFilter: ['src', 'srcset'] });
    });
}

const INPUT_TYPES = [
    'text',
    'password',
    'email',
    'search',
    'number',
    'range',
    'date',
    'tel',
    'time',
];
function isTextFieldElement(node) {
    if (hasTag(node, 'textarea')) {
        return true;
    }
    if (!hasTag(node, 'input')) {
        return false;
    }
    return INPUT_TYPES.includes(node.type);
}
function isCheckbox(node) {
    if (!hasTag(node, 'input')) {
        return false;
    }
    const type = node.type;
    return type === 'checkbox' || type === 'radio';
}
const labelElementFor = IN_BROWSER && 'labels' in HTMLInputElement.prototype
    ? (node) => {
        let p = node;
        while ((p = p.parentNode) !== null) {
            if (hasTag(p, 'label')) {
                return p;
            }
        }
        const labels = node.labels;
        if (labels !== null && labels.length === 1) {
            return labels[0];
        }
    }
    : (node) => {
        let p = node;
        while ((p = p.parentNode) !== null) {
            if (hasTag(p, 'label')) {
                return p;
            }
        }
        const id = node.id;
        if (id) {
            const labels = node.ownerDocument.querySelectorAll('label[for="' + id + '"]');
            if (labels !== null && labels.length === 1) {
                return labels[0];
            }
        }
    };
function getInputLabel(node) {
    let label = getLabelAttribute(node);
    if (label === null) {
        const labelElement = labelElementFor(node);
        label =
            (labelElement && labelElement.innerText) ||
                node.placeholder ||
                node.name ||
                node.id ||
                node.className ||
                node.type;
    }
    return normSpaces(label).slice(0, 100);
}
const InputMode = {
    Plain: 0,
    Obscured: 1,
    Hidden: 2,
};
function Input (app, opts) {
    const options = Object.assign({
        obscureInputNumbers: true,
        obscureInputEmails: true,
        defaultInputMode: InputMode.Obscured,
        obscureInputDates: false,
    }, opts);
    function getInputValue(id, node) {
        let value = node.value;
        let inputMode = options.defaultInputMode;
        if (node.type === 'password' || app.sanitizer.isHidden(id)) {
            inputMode = InputMode.Hidden;
        }
        else if (app.sanitizer.isObscured(id) ||
            (inputMode === InputMode.Plain &&
                ((options.obscureInputNumbers && node.type !== 'date' && /\d\d\d\d/.test(value)) ||
                    (options.obscureInputDates && node.type === 'date') ||
                    (options.obscureInputEmails && (node.type === 'email' || !!~value.indexOf('@')))))) {
            inputMode = InputMode.Obscured;
        }
        let mask = 0;
        switch (inputMode) {
            case InputMode.Hidden:
                mask = -1;
                value = '';
                break;
            case InputMode.Obscured:
                mask = value.length;
                value = '';
                break;
        }
        return { value, mask };
    }
    function sendInputValue(id, node) {
        const { value, mask } = getInputValue(id, node);
        app.send(SetInputValue(id, value, mask));
    }
    const inputValues = new Map();
    const checkboxValues = new Map();
    app.attachStopCallback(() => {
        inputValues.clear();
        checkboxValues.clear();
    });
    function trackInputValue(id, node) {
        if (inputValues.get(id) === node.value) {
            return;
        }
        inputValues.set(id, node.value);
        sendInputValue(id, node);
    }
    function trackCheckboxValue(id, value) {
        if (checkboxValues.get(id) === value) {
            return;
        }
        checkboxValues.set(id, value);
        app.send(SetInputChecked(id, value));
    }
    // The only way (to our knowledge) to track all kinds of input changes, including those made by JS
    app.ticker.attach(() => {
        inputValues.forEach((value, id) => {
            const node = app.nodes.getNode(id);
            if (!node)
                return inputValues.delete(id);
            trackInputValue(id, node);
        });
        checkboxValues.forEach((checked, id) => {
            const node = app.nodes.getNode(id);
            if (!node)
                return checkboxValues.delete(id);
            trackCheckboxValue(id, node.checked);
        });
    }, 3);
    function sendInputChange(id, node, hesitationTime, inputTime) {
        const { value, mask } = getInputValue(id, node);
        let label = getInputLabel(node);
        if (app.sanitizer.privateMode) {
            label = label.replaceAll(/./g, '*');
        }
        app.send(InputChange(id, value, mask !== 0, label, hesitationTime, inputTime));
    }
    app.nodes.attachNodeCallback(app.safe((node) => {
        const id = app.nodes.getID(node);
        if (id === undefined) {
            return;
        }
        // TODO: support multiple select (?): use selectedOptions;
        if (hasTag(node, 'select')) {
            sendInputValue(id, node);
            app.nodes.attachNodeListener(node, 'change', () => sendInputValue(id, node));
        }
        if (isTextFieldElement(node)) {
            trackInputValue(id, node);
            let nodeFocusTime = 0;
            let nodeHesitationTime = 0;
            let inputTime = 0;
            const onFocus = () => {
                nodeFocusTime = now();
            };
            const onInput = () => {
                if (nodeHesitationTime === 0 && nodeFocusTime !== 0) {
                    nodeHesitationTime = now() - nodeFocusTime;
                }
            };
            const onChange = () => {
                if (nodeFocusTime !== 0) {
                    inputTime = now() - nodeFocusTime;
                }
                sendInputChange(id, node, nodeHesitationTime, inputTime);
                nodeHesitationTime = 0;
                inputTime = 0;
                nodeFocusTime = 0;
            };
            app.nodes.attachNodeListener(node, 'focus', onFocus);
            app.nodes.attachNodeListener(node, 'input', onInput);
            app.nodes.attachNodeListener(node, 'change', onChange);
            return;
        }
        if (isCheckbox(node)) {
            trackCheckboxValue(id, node.checked);
            app.nodes.attachNodeListener(node, 'change', () => trackCheckboxValue(id, node.checked));
            return;
        }
    }));
}

// License: MIT
// Author: Anton Medvedev <anton@medv.io>
// Source: https://github.com/antonmedv/finder
const acceptedAttrNames = new Set(['role', 'name', 'aria-label', 'rel', 'href']);
/** Check if attribute name and value are word-like. */
function attr(name, value) {
    let nameIsOk = acceptedAttrNames.has(name);
    nameIsOk ||= name.startsWith('data-') && wordLike(name);
    let valueIsOk = wordLike(value) && value.length < 100;
    valueIsOk ||= value.startsWith('#') && wordLike(value.slice(1));
    return nameIsOk && valueIsOk;
}
/** Check if id name is word-like. */
function idName(name) {
    return wordLike(name);
}
/** Check if class name is word-like. */
function className(name) {
    return wordLike(name);
}
/** Check if tag name is word-like. */
function tagName(name) {
    return true;
}
/** Finds unique CSS selectors for the given element. */
function finder(input, options) {
    if (input.nodeType !== Node.ELEMENT_NODE) {
        throw new Error(`Can't generate CSS selector for non-element node type.`);
    }
    if (input.tagName.toLowerCase() === 'html') {
        return 'html';
    }
    const defaults = {
        root: document.body,
        idName: idName,
        className: className,
        tagName: tagName,
        attr: attr,
        timeoutMs: 1000,
        seedMinLength: 3,
        optimizedMinLength: 2,
        maxNumberOfPathChecks: Infinity,
    };
    const startTime = new Date();
    const config = { ...defaults, ...options };
    const rootDocument = findRootDocument(config.root, defaults);
    let foundPath;
    let count = 0;
    for (const candidate of search(input, config, rootDocument)) {
        const elapsedTimeMs = new Date().getTime() - startTime.getTime();
        if (elapsedTimeMs > config.timeoutMs ||
            count >= config.maxNumberOfPathChecks) {
            const fPath = fallback(input, rootDocument);
            if (!fPath) {
                throw new Error(`Timeout: Can't find a unique selector after ${config.timeoutMs}ms`);
            }
            return selector(fPath);
        }
        count++;
        if (unique(candidate, rootDocument)) {
            foundPath = candidate;
            break;
        }
    }
    if (!foundPath) {
        throw new Error(`Selector was not found.`);
    }
    const optimized = [
        ...optimize(foundPath, input, config, rootDocument, startTime),
    ];
    optimized.sort(byPenalty);
    if (optimized.length > 0) {
        return selector(optimized[0]);
    }
    return selector(foundPath);
}
function* search(input, config, rootDocument) {
    const stack = [];
    let paths = [];
    let current = input;
    let i = 0;
    while (current && current !== rootDocument) {
        const level = tie(current, config);
        for (const node of level) {
            node.level = i;
        }
        stack.push(level);
        current = current.parentElement;
        i++;
        paths.push(...combinations(stack));
        if (i >= config.seedMinLength) {
            paths.sort(byPenalty);
            for (const candidate of paths) {
                yield candidate;
            }
            paths = [];
        }
    }
    paths.sort(byPenalty);
    for (const candidate of paths) {
        yield candidate;
    }
}
function wordLike(name) {
    if (/^[a-z\-]{3,}$/i.test(name)) {
        const words = name.split(/-|[A-Z]/);
        for (const word of words) {
            if (word.length <= 2) {
                return false;
            }
            if (/[^aeiou]{4,}/i.test(word)) {
                return false;
            }
        }
        return true;
    }
    return false;
}
function tie(element, config) {
    const level = [];
    const elementId = element.getAttribute('id');
    if (elementId && config.idName(elementId)) {
        level.push({
            name: '#' + CSS.escape(elementId),
            penalty: 0,
        });
    }
    for (let i = 0; i < element.classList.length; i++) {
        const name = element.classList[i];
        if (config.className(name)) {
            level.push({
                name: '.' + CSS.escape(name),
                penalty: 1,
            });
        }
    }
    for (let i = 0; i < element.attributes.length; i++) {
        const attr = element.attributes[i];
        if (config.attr(attr.name, attr.value)) {
            level.push({
                name: `[${CSS.escape(attr.name)}="${CSS.escape(attr.value)}"]`,
                penalty: 2,
            });
        }
    }
    const tagName = element.tagName.toLowerCase();
    if (config.tagName(tagName)) {
        level.push({
            name: tagName,
            penalty: 5,
        });
        const index = indexOf(element, tagName);
        if (index !== undefined) {
            level.push({
                name: nthOfType(tagName, index),
                penalty: 10,
            });
        }
    }
    const nth = indexOf(element);
    if (nth !== undefined) {
        level.push({
            name: nthChild(tagName, nth),
            penalty: 50,
        });
    }
    return level;
}
function selector(path) {
    let node = path[0];
    let query = node.name;
    for (let i = 1; i < path.length; i++) {
        const level = path[i].level || 0;
        if (node.level === level - 1) {
            query = `${path[i].name} > ${query}`;
        }
        else {
            query = `${path[i].name} ${query}`;
        }
        node = path[i];
    }
    return query;
}
function penalty(path) {
    return path.map((node) => node.penalty).reduce((acc, i) => acc + i, 0);
}
function byPenalty(a, b) {
    return penalty(a) - penalty(b);
}
function indexOf(input, tagName) {
    const parent = input.parentNode;
    if (!parent) {
        return undefined;
    }
    let child = parent.firstChild;
    if (!child) {
        return undefined;
    }
    let i = 0;
    while (child) {
        if (child.nodeType === Node.ELEMENT_NODE &&
            (tagName === undefined ||
                child.tagName.toLowerCase() === tagName)) {
            i++;
        }
        if (child === input) {
            break;
        }
        child = child.nextSibling;
    }
    return i;
}
function fallback(input, rootDocument) {
    let i = 0;
    let current = input;
    const path = [];
    while (current && current !== rootDocument) {
        const tagName = current.tagName.toLowerCase();
        const index = indexOf(current, tagName);
        if (index === undefined) {
            return;
        }
        path.push({
            name: nthOfType(tagName, index),
            penalty: NaN,
            level: i,
        });
        current = current.parentElement;
        i++;
    }
    if (unique(path, rootDocument)) {
        return path;
    }
}
function nthChild(tagName, index) {
    if (tagName === 'html') {
        return 'html';
    }
    return `${tagName}:nth-child(${index})`;
}
function nthOfType(tagName, index) {
    if (tagName === 'html') {
        return 'html';
    }
    return `${tagName}:nth-of-type(${index})`;
}
function* combinations(stack, path = []) {
    if (stack.length > 0) {
        for (let node of stack[0]) {
            yield* combinations(stack.slice(1, stack.length), path.concat(node));
        }
    }
    else {
        yield path;
    }
}
function findRootDocument(rootNode, defaults) {
    if (rootNode.nodeType === Node.DOCUMENT_NODE) {
        return rootNode;
    }
    if (rootNode === defaults.root) {
        return rootNode.ownerDocument;
    }
    return rootNode;
}
function unique(path, rootDocument) {
    const css = selector(path);
    switch (rootDocument.querySelectorAll(css).length) {
        case 0:
            throw new Error(`Can't select any node with this selector: ${css}`);
        case 1:
            return true;
        default:
            return false;
    }
}
function* optimize(path, input, config, rootDocument, startTime) {
    if (path.length > 2 && path.length > config.optimizedMinLength) {
        for (let i = 1; i < path.length - 1; i++) {
            const elapsedTimeMs = new Date().getTime() - startTime.getTime();
            if (elapsedTimeMs > config.timeoutMs) {
                return;
            }
            const newPath = [...path];
            newPath.splice(i, 1);
            if (unique(newPath, rootDocument) &&
                rootDocument.querySelector(selector(newPath)) === input) {
                yield newPath;
                yield* optimize(newPath, input, config, rootDocument, startTime);
            }
        }
    }
}

function _getSelector(target, document, options) {
    const selector = finder(target, {
        root: document.body,
        seedMinLength: 3,
        optimizedMinLength: options?.minSelectorDepth || 2,
        maxNumberOfPathChecks: options?.maxOptimiseTries || 10000,
    });
    return selector;
}
function isClickable(element) {
    const tag = element.tagName.toUpperCase();
    return (tag === 'BUTTON' ||
        tag === 'A' ||
        tag === 'LI' ||
        tag === 'SELECT' ||
        tag === 'TR' ||
        tag === 'TH' ||
        element.onclick != null ||
        element.getAttribute('role') === 'button');
    //|| element.className.includes("btn")
    // MBTODO: intercept addEventListener
}
//TODO: fix (typescript is not sure about target variable after assignation of svg)
function getTarget(target, document) {
    if (target instanceof Element) {
        return _getTarget(target, document);
    }
    return null;
}
function _getTarget(target, document) {
    let element = target;
    while (element !== null && element !== document.documentElement) {
        if (hasOpenreplayAttribute(element, 'masked')) {
            return null;
        }
        element = element.parentElement;
    }
    if (isSVGElement(target)) {
        let owner = target.ownerSVGElement;
        while (owner !== null) {
            target = owner;
            owner = owner.ownerSVGElement;
        }
    }
    element = target;
    while (element !== null && element !== document.documentElement) {
        const tag = element.tagName.toUpperCase();
        if (tag === 'LABEL') {
            return null;
        }
        if (tag === 'INPUT') {
            return element;
        }
        if (isClickable(element) || getLabelAttribute(element) !== null) {
            return element;
        }
        element = element.parentElement;
    }
    return target === document.documentElement ? null : target;
}
function Mouse (app, options) {
    const { disableClickmaps = false } = options || {};
    function getTargetLabel(target) {
        const dl = getLabelAttribute(target);
        if (dl !== null) {
            return dl;
        }
        if (hasTag(target, 'input')) {
            return getInputLabel(target);
        }
        if (isClickable(target)) {
            let label = '';
            if (target instanceof HTMLElement) {
                label = app.sanitizer.getInnerTextSecure(target);
            }
            label = label || target.id || target.className;
            return normSpaces(label).slice(0, 100);
        }
        return '';
    }
    let mousePositionX = -1;
    let mousePositionY = -1;
    let mousePositionChanged = false;
    let mouseTarget = null;
    let mouseTargetTime = 0;
    let selectorMap = {};
    let velocity = 0;
    let direction = 0;
    let directionChangeCount = 0;
    let distance = 0;
    let checkIntervalId;
    const shakeThreshold = 0.008;
    const shakeCheckInterval = 225;
    function checkMouseShaking() {
        const nextVelocity = distance / shakeCheckInterval;
        if (!velocity) {
            velocity = nextVelocity;
            return;
        }
        const acceleration = (nextVelocity - velocity) / shakeCheckInterval;
        if (directionChangeCount > 4 && acceleration > shakeThreshold) {
            app.send(MouseThrashing(now()));
        }
        distance = 0;
        directionChangeCount = 0;
        velocity = nextVelocity;
    }
    app.attachStartCallback(() => {
        checkIntervalId = setInterval(() => checkMouseShaking(), shakeCheckInterval);
    });
    app.attachStopCallback(() => {
        mousePositionX = -1;
        mousePositionY = -1;
        mousePositionChanged = false;
        mouseTarget = null;
        selectorMap = {};
        if (checkIntervalId) {
            clearInterval(checkIntervalId);
        }
    });
    const sendMouseMove = () => {
        if (mousePositionChanged) {
            app.send(MouseMove(mousePositionX, mousePositionY));
            mousePositionChanged = false;
        }
    };
    const patchDocument = (document, topframe = false) => {
        function getSelector(id, target, options) {
            return (selectorMap[id] = selectorMap[id] || _getSelector(target, document, options));
        }
        const attachListener = topframe
            ? app.attachEventListener.bind(app) // attached/removed on start/stop
            : app.nodes.attachNodeListener.bind(app.nodes); // attached/removed on node register/unregister
        attachListener(document.documentElement, 'mouseover', (e) => {
            const target = getTarget(e.target, document);
            if (target !== mouseTarget) {
                mouseTarget = target;
                mouseTargetTime = performance.now();
            }
        });
        attachListener(document, 'mousemove', (e) => {
            const [left, top] = app.observer.getDocumentOffset(document); // MBTODO?: document-id related message
            mousePositionX = e.clientX + left;
            mousePositionY = e.clientY + top;
            mousePositionChanged = true;
            const nextDirection = Math.sign(e.movementX);
            distance += Math.abs(e.movementX) + Math.abs(e.movementY);
            if (nextDirection !== direction) {
                direction = nextDirection;
                directionChangeCount++;
            }
        }, false);
        attachListener(document, 'click', (e) => {
            const target = getTarget(e.target, document);
            if ((!e.clientX && !e.clientY) || target === null) {
                return;
            }
            const id = app.nodes.getID(target);
            if (id !== undefined) {
                const clickX = e.pageX;
                const clickY = e.pageY;
                const contentWidth = document.documentElement.scrollWidth;
                const contentHeight = document.documentElement.scrollHeight;
                const normalizedX = roundNumber(clickX / contentWidth);
                const normalizedY = roundNumber(clickY / contentHeight);
                sendMouseMove();
                const label = getTargetLabel(target);
                app.send(MouseClick(id, mouseTarget === target ? Math.round(performance.now() - mouseTargetTime) : 0, app.sanitizer.privateMode ? label.replaceAll(/./g, '*') : label, isClickable(target) && !disableClickmaps ? getSelector(id, target, options) : '', normalizedX, normalizedY), true);
            }
            mouseTarget = null;
        });
    };
    app.nodes.attachNodeCallback((node) => {
        if (isDocument(node)) {
            patchDocument(node);
        }
    });
    patchDocument(document, true);
    app.ticker.attach(sendMouseMove, options?.trackingOffset || 7);
}
/**
 * we get 0 to 1 decimal number, convert and round it, then turn to %
 * 0.39643 => 396.43 => 396 => 39.6%
 * */
function roundNumber(num) {
    return Math.round(num * 1e4);
}

var e,o=-1,a=function(e){addEventListener("pageshow",(function(n){n.persisted&&(o=n.timeStamp,e(n));}),true);},c=function(){var e=self.performance&&performance.getEntriesByType&&performance.getEntriesByType("navigation")[0];if(e&&e.responseStart>0&&e.responseStart<performance.now())return e},u=function(){var e=c();return e&&e.activationStart||0},f=function(e,n){var t=c(),r="navigate";o>=0?r="back-forward-cache":t&&(document.prerendering||u()>0?r="prerender":document.wasDiscarded?r="restore":t.type&&(r=t.type.replace(/_/g,"-")));return {name:e,value:void 0===n?-1:n,rating:"good",delta:0,entries:[],id:"v4-".concat(Date.now(),"-").concat(Math.floor(8999999999999*Math.random())+1e12),navigationType:r}},s=function(e,n,t){try{if(PerformanceObserver.supportedEntryTypes.includes(e)){var r=new PerformanceObserver((function(e){Promise.resolve().then((function(){n(e.getEntries());}));}));return r.observe(Object.assign({type:e,buffered:!0},t||{})),r}}catch(e){}},d=function(e,n,t,r){var i,o;return function(a){n.value>=0&&(a||r)&&((o=n.value-(i||0))||void 0===i)&&(i=n.value,n.delta=o,n.rating=function(e,n){return e>n[1]?"poor":e>n[0]?"needs-improvement":"good"}(n.value,t),e(n));}},l=function(e){requestAnimationFrame((function(){return requestAnimationFrame((function(){return e()}))}));},p=function(e){document.addEventListener("visibilitychange",(function(){"hidden"===document.visibilityState&&e();}));},v=function(e){var n=false;return function(){n||(e(),n=true);}},m=-1,h=function(){return "hidden"!==document.visibilityState||document.prerendering?1/0:0},g=function(e){"hidden"===document.visibilityState&&m>-1&&(m="visibilitychange"===e.type?e.timeStamp:0,T());},y=function(){addEventListener("visibilitychange",g,true),addEventListener("prerenderingchange",g,true);},T=function(){removeEventListener("visibilitychange",g,true),removeEventListener("prerenderingchange",g,true);},E=function(){return m<0&&(m=h(),y(),a((function(){setTimeout((function(){m=h(),y();}),0);}))),{get firstHiddenTime(){return m}}},C=function(e){document.prerendering?addEventListener("prerenderingchange",(function(){return e()}),true):e();},b=[1800,3e3],S=function(e,n){n=n||{},C((function(){var t,r=E(),i=f("FCP"),o=s("paint",(function(e){e.forEach((function(e){"first-contentful-paint"===e.name&&(o.disconnect(),e.startTime<r.firstHiddenTime&&(i.value=Math.max(e.startTime-u(),0),i.entries.push(e),t(true)));}));}));o&&(t=d(e,i,b,n.reportAllChanges),a((function(r){i=f("FCP"),t=d(e,i,b,n.reportAllChanges),l((function(){i.value=performance.now()-r.timeStamp,t(true);}));})));}));},L=[.1,.25],w=function(e,n){n=n||{},S(v((function(){var t,r=f("CLS",0),i=0,o=[],c=function(e){e.forEach((function(e){if(!e.hadRecentInput){var n=o[0],t=o[o.length-1];i&&e.startTime-t.startTime<1e3&&e.startTime-n.startTime<5e3?(i+=e.value,o.push(e)):(i=e.value,o=[e]);}})),i>r.value&&(r.value=i,r.entries=o,t());},u=s("layout-shift",c);u&&(t=d(e,r,L,n.reportAllChanges),p((function(){c(u.takeRecords()),t(true);})),a((function(){i=0,r=f("CLS",0),t=d(e,r,L,n.reportAllChanges),l((function(){return t()}));})),setTimeout(t,0));})));},A=0,I=1/0,P=0,M=function(e){e.forEach((function(e){e.interactionId&&(I=Math.min(I,e.interactionId),P=Math.max(P,e.interactionId),A=P?(P-I)/7+1:0);}));},k=function(){return e?A:performance.interactionCount||0},F=function(){"interactionCount"in performance||e||(e=s("event",M,{type:"event",buffered:true,durationThreshold:0}));},D=[],x=new Map,R=0,B=function(){var e=Math.min(D.length-1,Math.floor((k()-R)/50));return D[e]},H=[],q=function(e){if(H.forEach((function(n){return n(e)})),e.interactionId||"first-input"===e.entryType){var n=D[D.length-1],t=x.get(e.interactionId);if(t||D.length<10||e.duration>n.latency){if(t)e.duration>t.latency?(t.entries=[e],t.latency=e.duration):e.duration===t.latency&&e.startTime===t.entries[0].startTime&&t.entries.push(e);else {var r={id:e.interactionId,latency:e.duration,entries:[e]};x.set(r.id,r),D.push(r);}D.sort((function(e,n){return n.latency-e.latency})),D.length>10&&D.splice(10).forEach((function(e){return x.delete(e.id)}));}}},O=function(e){var n=self.requestIdleCallback||self.setTimeout,t=-1;return e=v(e),"hidden"===document.visibilityState?e():(t=n(e),p(e)),t},N=[200,500],j=function(e,n){"PerformanceEventTiming"in self&&"interactionId"in PerformanceEventTiming.prototype&&(n=n||{},C((function(){var t;F();var r,i=f("INP"),o=function(e){O((function(){e.forEach(q);var n=B();n&&n.latency!==i.value&&(i.value=n.latency,i.entries=n.entries,r());}));},c=s("event",o,{durationThreshold:null!==(t=n.durationThreshold)&&void 0!==t?t:40});r=d(e,i,N,n.reportAllChanges),c&&(c.observe({type:"first-input",buffered:true}),p((function(){o(c.takeRecords()),r(true);})),a((function(){R=k(),D.length=0,x.clear(),i=f("INP"),r=d(e,i,N,n.reportAllChanges);})));})));},_=[2500,4e3],z={},G=function(e,n){n=n||{},C((function(){var t,r=E(),i=f("LCP"),o=function(e){n.reportAllChanges||(e=e.slice(-1)),e.forEach((function(e){e.startTime<r.firstHiddenTime&&(i.value=Math.max(e.startTime-u(),0),i.entries=[e],t());}));},c=s("largest-contentful-paint",o);if(c){t=d(e,i,_,n.reportAllChanges);var m=v((function(){z[i.id]||(o(c.takeRecords()),c.disconnect(),z[i.id]=true,t(true));}));["keydown","click"].forEach((function(e){addEventListener(e,(function(){return O(m)}),{once:true,capture:true});})),p(m),a((function(r){i=f("LCP"),t=d(e,i,_,n.reportAllChanges),l((function(){i.value=performance.now()-r.timeStamp,z[i.id]=true,t(true);}));}));}}));},J=[800,1800],K=function e(n){document.prerendering?C((function(){return e(n)})):"complete"!==document.readyState?addEventListener("load",(function(){return e(n)}),true):setTimeout(n,0);},Q=function(e,n){n=n||{};var t=f("TTFB"),r=d(e,t,J,n.reportAllChanges);K((function(){var i=c();i&&(t.value=Math.max(i.responseStart-u(),0),t.entries=[i],r(true),a((function(){t=f("TTFB",0),(r=d(e,t,J,n.reportAllChanges))(true);})));}));};

function getPaintBlocks(resources) {
    const paintBlocks = [];
    const elements = document.getElementsByTagName('*');
    const styleURL = /url\(("[^"]*"|'[^']*'|[^)]*)\)/i;
    for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        let src = '';
        if (hasTag(element, 'img')) {
            src = element.currentSrc || element.src;
        }
        if (!src) {
            const backgroundImage = getComputedStyle(element).getPropertyValue('background-image');
            if (backgroundImage) {
                const matches = styleURL.exec(backgroundImage);
                if (matches !== null) {
                    src = matches[1];
                    if (src.startsWith('"') || src.startsWith("'")) {
                        src = src.substr(1, src.length - 2);
                    }
                }
            }
        }
        if (!src)
            continue;
        const time = src.substr(0, 10) === 'data:image' ? 0 : resources[src];
        if (time === undefined)
            continue;
        const rect = element.getBoundingClientRect();
        const top = Math.max(rect.top, 0);
        const left = Math.max(rect.left, 0);
        const bottom = Math.min(rect.bottom, window.innerHeight ||
            (document.documentElement && document.documentElement.clientHeight) ||
            0);
        const right = Math.min(rect.right, window.innerWidth || (document.documentElement && document.documentElement.clientWidth) || 0);
        if (bottom <= top || right <= left)
            continue;
        const area = (bottom - top) * (right - left);
        paintBlocks.push({ time, area });
    }
    return paintBlocks;
}
function calculateSpeedIndex(firstContentfulPaint, paintBlocks) {
    let a = (Math.max((document.documentElement && document.documentElement.clientWidth) || 0, window.innerWidth || 0) *
        Math.max((document.documentElement && document.documentElement.clientHeight) || 0, window.innerHeight || 0)) /
        10;
    let s = a * firstContentfulPaint;
    for (let i = 0; i < paintBlocks.length; i++) {
        const { time, area } = paintBlocks[i];
        a += area;
        s += area * (time > firstContentfulPaint ? time : firstContentfulPaint);
    }
    return a === 0 ? 0 : s / a;
}
function Timing (app, opts) {
    const options = Object.assign({
        captureResourceTimings: true,
        capturePageLoadTimings: true,
        capturePageRenderTimings: true,
        excludedResourceUrls: [],
    }, opts);
    if (!('PerformanceObserver' in window)) {
        options.captureResourceTimings = false;
    }
    if (!options.captureResourceTimings) {
        return;
    } // Resources are necessary for all timings
    let resources = {};
    function resourceTiming(entry) {
        if (entry.duration < 0 || !isURL(entry.name) || app.isServiceURL(entry.name))
            return;
        if (resources !== null) {
            resources[entry.name] = entry.startTime + entry.duration;
        }
        let shouldSkip = false;
        options.excludedResourceUrls?.forEach((url) => {
            if (entry.name.startsWith(url)) {
                shouldSkip = true;
                return;
            }
        });
        if (shouldSkip) {
            return;
        }
        const failed = entry.responseEnd === 0
            || (entry.transferSize === 0 && entry.decodedBodySize === 0);
        if (failed) {
            app.send(ResourceTiming(entry.startTime + getTimeOrigin(), 0, 0, 0, 0, 0, entry.name, entry.initiatorType, 0, true));
        }
        app.send(ResourceTiming(entry.startTime + getTimeOrigin(), entry.duration, entry.responseStart && entry.startTime ? entry.responseStart - entry.startTime : 0, entry.transferSize > entry.encodedBodySize ? entry.transferSize - entry.encodedBodySize : 0, entry.encodedBodySize || 0, entry.decodedBodySize || 0, app.sanitizer.privateMode ? entry.name.replaceAll(/./g, '*') : entry.name, entry.initiatorType, entry.transferSize, 
        // @ts-ignore
        (entry.responseStatus && entry.responseStatus === 304) || entry.transferSize === 0));
    }
    const observer = new PerformanceObserver((list) => list.getEntries().forEach(resourceTiming));
    function onVitalsSignal(msg) {
        if (app.active()) {
            return app.send(WebVitals(msg.name, String(msg.value)));
        }
    }
    let prevSessionID;
    app.attachStartCallback(function ({ sessionID }) {
        if (sessionID !== prevSessionID) {
            // Send past page resources on a newly started session
            performance.getEntriesByType('resource').forEach(resourceTiming);
            prevSessionID = sessionID;
        }
        observer.observe({ entryTypes: ['resource'] });
        // browser support:
        // onCLS(): Chromium
        // onFCP(): Chromium, Firefox, Safari
        // onFID(): Chromium, Firefox (Deprecated)
        // onINP(): Chromium
        // onLCP(): Chromium, Firefox
        // onTTFB(): Chromium, Firefox, Safari
        w(onVitalsSignal);
        j(onVitalsSignal);
        G(onVitalsSignal);
        Q(onVitalsSignal);
    });
    app.attachStopCallback(function () {
        observer.disconnect();
    });
    let firstPaint = 0, firstContentfulPaint = 0;
    if (options.capturePageLoadTimings) {
        let pageLoadTimingSent = false;
        app.ticker.attach(() => {
            if (pageLoadTimingSent) {
                return;
            }
            if (firstPaint === 0 || firstContentfulPaint === 0) {
                performance.getEntriesByType('paint').forEach((entry) => {
                    const { name, startTime } = entry;
                    switch (name) {
                        case 'first-paint':
                            firstPaint = startTime;
                            break;
                        case 'first-contentful-paint':
                            firstContentfulPaint = startTime;
                            break;
                    }
                });
            }
            if (performance.timing.loadEventEnd || performance.now() > 30000) {
                pageLoadTimingSent = true;
                const { 
                // should be ok to use here, (https://github.com/mdn/content/issues/4713)
                // since it is compared with the values obtained on the page load (before any possible sleep state)
                // deprecated though
                navigationStart, requestStart, responseStart, responseEnd, domContentLoadedEventStart, domContentLoadedEventEnd, loadEventStart, loadEventEnd, } = performance.timing;
                app.send(PageLoadTiming(requestStart - navigationStart || 0, responseStart - navigationStart || 0, responseEnd - navigationStart || 0, domContentLoadedEventStart - navigationStart || 0, domContentLoadedEventEnd - navigationStart || 0, loadEventStart - navigationStart || 0, loadEventEnd - navigationStart || 0, firstPaint, firstContentfulPaint));
            }
        }, 30);
    }
    if (options.capturePageRenderTimings) {
        let visuallyComplete = 0, interactiveWindowStartTime = 0, interactiveWindowTickTime = 0, paintBlocks = null;
        let pageRenderTimingSent = false;
        app.ticker.attach(() => {
            if (pageRenderTimingSent) {
                return;
            }
            const time = performance.now();
            if (resources !== null) {
                visuallyComplete = Math.max.apply(null, Object.keys(resources).map((k) => resources[k]));
                if (time - visuallyComplete > 1000) {
                    paintBlocks = getPaintBlocks(resources);
                    resources = null;
                }
            }
            if (interactiveWindowTickTime !== null) {
                if (time - interactiveWindowTickTime > 50) {
                    interactiveWindowStartTime = time;
                }
                interactiveWindowTickTime = time - interactiveWindowStartTime > 5000 ? null : time;
            }
            if ((paintBlocks !== null && interactiveWindowTickTime === null) || time > 30000) {
                pageRenderTimingSent = true;
                resources = null;
                const speedIndex = paintBlocks === null
                    ? 0
                    : calculateSpeedIndex(firstContentfulPaint || firstPaint, paintBlocks);
                const { domContentLoadedEventEnd, navigationStart } = performance.timing;
                const timeToInteractive = interactiveWindowTickTime === null
                    ? Math.max(interactiveWindowStartTime, firstContentfulPaint, domContentLoadedEventEnd - navigationStart || 0)
                    : 0;
                app.send(PageRenderTiming(speedIndex, firstContentfulPaint > visuallyComplete ? firstContentfulPaint : visuallyComplete, timeToInteractive));
            }
        });
    }
}

function getDocumentScroll(doc) {
    const win = doc.defaultView;
    return [
        (win && win.scrollX) ||
            (doc.documentElement && doc.documentElement.scrollLeft) ||
            (doc.body && doc.body.scrollLeft) ||
            0,
        (win && win.scrollY) ||
            (doc.documentElement && doc.documentElement.scrollTop) ||
            (doc.body && doc.body.scrollTop) ||
            0,
    ];
}
function Scroll (app, insideIframe) {
    let documentScroll = false;
    const nodeScroll = new Map();
    function setNodeScroll(target) {
        if (!isNode(target)) {
            return;
        }
        if (isElementNode(target)) {
            nodeScroll.set(target, [target.scrollLeft, target.scrollTop]);
        }
        if (isDocument(target)) {
            nodeScroll.set(target, getDocumentScroll(target));
        }
    }
    const sendSetViewportScroll = app.safe(() => {
        if (insideIframe) {
            return;
        }
        app.send(SetViewportScroll(...getDocumentScroll(document)));
    });
    const sendSetNodeScroll = app.safe((s, node) => {
        const id = app.nodes.getID(node);
        if (id !== undefined) {
            app.send(SetNodeScroll(id, s[0], s[1]));
        }
    });
    app.attachStartCallback(sendSetViewportScroll);
    app.attachStopCallback(() => {
        documentScroll = false;
        nodeScroll.clear();
    });
    app.nodes.attachNodeCallback((node, isStart) => {
        // MBTODO: iterate over all the nodes on start instead of using isStart hack
        if (isStart) {
            if (isElementNode(node) && node.scrollLeft + node.scrollTop > 0) {
                nodeScroll.set(node, [node.scrollLeft, node.scrollTop]);
            }
            else if (isDocument(node)) {
                // DRY somehow?
                nodeScroll.set(node, getDocumentScroll(node));
            }
        }
        if (isRootNode(node)) {
            // scroll is not-composed event (https://javascript.info/shadow-dom-events)
            app.nodes.attachNodeListener(node, 'scroll', (e) => {
                setNodeScroll(e.target);
            });
        }
    });
    app.attachEventListener(document, 'scroll', (e) => {
        const target = e.target;
        if (target === document) {
            documentScroll = true;
            return;
        }
        setNodeScroll(target);
    });
    app.ticker.attach(() => {
        if (documentScroll) {
            sendSetViewportScroll();
            documentScroll = false;
        }
        nodeScroll.forEach(sendSetNodeScroll);
        nodeScroll.clear();
    }, 5, false);
}

function Viewport (app) {
    let url, width, height;
    let navigationStart;
    let referrer = document.referrer;
    const sendSetPageLocation = app.safe(() => {
        const { URL } = document;
        if (URL !== url) {
            url = URL;
            const safeTitle = app.sanitizer.privateMode ? stringWiper(document.title) : document.title;
            const safeUrl = app.sanitizer.privateMode ? stringWiper(url) : url;
            const safeReferrer = app.sanitizer.privateMode ? stringWiper(referrer) : referrer;
            app.send(SetPageLocation(safeUrl, safeReferrer, navigationStart, safeTitle));
            navigationStart = 0;
            referrer = url;
        }
    });
    const sendSetViewportSize = app.safe(() => {
        const { innerWidth, innerHeight } = window;
        if (innerWidth !== width || innerHeight !== height) {
            width = innerWidth;
            height = innerHeight;
            app.send(SetViewportSize(width, height));
        }
    });
    const sendSetPageVisibility = document.hidden === undefined
        ? Function.prototype
        : app.safe(() => app.send(SetPageVisibility(document.hidden)));
    app.attachStartCallback(() => {
        url = null;
        navigationStart = getTimeOrigin();
        width = height = -1;
        sendSetPageLocation();
        sendSetViewportSize();
        sendSetPageVisibility();
    });
    if (document.hidden !== undefined) {
        app.attachEventListener(document, 'visibilitychange', sendSetPageVisibility, false, false);
    }
    app.ticker.attach(sendSetPageLocation, 1, false);
    app.ticker.attach(sendSetViewportSize, 5, false);
}

function hasAdoptedSS(node) {
    return (isRootNode(node) &&
        // @ts-ignore
        !!node.adoptedStyleSheets);
}
// TODO: encapsulate to be init-ed on-start and join with cssrules.ts under one folder
let _id = 0xf;
function nextID() {
    return _id++;
}
const styleSheetIDMap = new Map();
function ConstructedStyleSheets (app) {
    if (app === null) {
        return;
    }
    if (!hasAdoptedSS(document)) {
        return;
    }
    const styleSheetIDMap = new Map();
    const adoptedStyleSheetsOwnings = new Map();
    const sendAdoptedStyleSheetsUpdate = (root) => setTimeout(() => {
        let nodeID = app.nodes.getID(root);
        if (root === document) {
            nodeID = 0; // main document doesn't have nodeID. ID count starts from the documentElement
        }
        if (nodeID === undefined) {
            return;
        }
        let pastOwning = adoptedStyleSheetsOwnings.get(nodeID);
        if (!pastOwning) {
            pastOwning = [];
        }
        const nowOwning = [];
        const styleSheets = root.adoptedStyleSheets;
        if (styleSheets && Symbol.iterator in styleSheets) {
            for (const s of styleSheets) {
                let sheetID = styleSheetIDMap.get(s);
                const init = !sheetID;
                if (!sheetID) {
                    sheetID = nextID();
                    styleSheetIDMap.set(s, sheetID);
                }
                if (!pastOwning.includes(sheetID)) {
                    app.send(AdoptedSSAddOwner(sheetID, nodeID));
                }
                if (init) {
                    const rules = s.cssRules;
                    for (let i = 0; i < rules.length; i++) {
                        app.send(AdoptedSSInsertRuleURLBased(sheetID, rules[i].cssText, i, app.getBaseHref()));
                    }
                }
                nowOwning.push(sheetID);
            }
        }
        if (Symbol.iterator in pastOwning) {
            for (const sheetID of pastOwning) {
                if (!nowOwning.includes(sheetID)) {
                    app.send(AdoptedSSRemoveOwner(sheetID, nodeID));
                }
            }
        }
        adoptedStyleSheetsOwnings.set(nodeID, nowOwning);
    }, 20); // Mysterious bug:
    /* On the page https://explore.fast.design/components/fast-accordion
      the only rule inside the only adoptedStyleSheet of the iframe-s document
      gets changed during first milliseconds after the load.
      However, none of the documented methods (replace, insertRule) is triggered.
      The rule is not substituted (remains the same object), however the text gets changed.
    */
    function patchAdoptedStyleSheets(prototype) {
        const nativeAdoptedStyleSheetsDescriptor = Object.getOwnPropertyDescriptor(prototype, 'adoptedStyleSheets');
        if (nativeAdoptedStyleSheetsDescriptor) {
            Object.defineProperty(prototype, 'adoptedStyleSheets', {
                ...nativeAdoptedStyleSheetsDescriptor,
                set: function (value) {
                    // @ts-ignore
                    const retVal = nativeAdoptedStyleSheetsDescriptor.set.call(this, value);
                    sendAdoptedStyleSheetsUpdate(this);
                    return retVal;
                },
            });
        }
    }
    const patchContext = (context) => {
        // @ts-ignore
        if (context.__openreplay_adpss_patched__) {
            return;
        }
        else {
            // @ts-ignore
            context.__openreplay_adpss_patched__ = true;
        }
        patchAdoptedStyleSheets(context.Document.prototype);
        patchAdoptedStyleSheets(context.ShadowRoot.prototype);
        //@ts-ignore TODO: upgrade ts to 4.8+
        const { replace, replaceSync } = context.CSSStyleSheet.prototype;
        //@ts-ignore
        context.CSSStyleSheet.prototype.replace = function (text) {
            return replace.call(this, text).then((sheet) => {
                const sheetID = styleSheetIDMap.get(this);
                if (sheetID) {
                    app.send(AdoptedSSReplaceURLBased(sheetID, text, app.getBaseHref()));
                }
                return sheet;
            });
        };
        //@ts-ignore
        context.CSSStyleSheet.prototype.replaceSync = function (text) {
            const sheetID = styleSheetIDMap.get(this);
            if (sheetID) {
                app.send(AdoptedSSReplaceURLBased(sheetID, text, app.getBaseHref()));
            }
            return replaceSync.call(this, text);
        };
    };
    patchContext(window);
    app.observer.attachContextCallback(app.safe(patchContext));
    app.attachStopCallback(() => {
        styleSheetIDMap.clear();
        adoptedStyleSheetsOwnings.clear();
    });
    // So far main Document is not triggered with nodeCallbacks
    app.attachStartCallback(() => {
        sendAdoptedStyleSheetsUpdate(document);
    });
    app.nodes.attachNodeCallback((node) => {
        if (hasAdoptedSS(node)) {
            sendAdoptedStyleSheetsUpdate(node);
        }
    });
}

function CSSRules (app) {
    if (app === null) {
        return;
    }
    if (!window.CSSStyleSheet) {
        app.send(TechnicalInfo('no_stylesheet_prototype_in_window', ''));
        return;
    }
    const sendInsertDeleteRule = app.safe((sheet, index, rule) => {
        const sheetID = styleSheetIDMap.get(sheet);
        if (!sheetID) {
            // OK-case. Sheet haven't been registered yet. Rules will be sent on registration.
            return;
        }
        if (typeof rule === 'string') {
            app.send(AdoptedSSInsertRuleURLBased(sheetID, rule, index, app.getBaseHref()));
        }
        else {
            app.send(AdoptedSSDeleteRule(sheetID, index));
        }
    });
    // TODO: proper rule insertion/removal (how?)
    const sendReplaceGroupingRule = app.safe((rule) => {
        let topmostRule = rule;
        while (topmostRule.parentRule) {
            topmostRule = topmostRule.parentRule;
        }
        const sheet = topmostRule.parentStyleSheet;
        if (!sheet) {
            app.debug.warn('No parent StyleSheet found for', topmostRule, rule);
            return;
        }
        const sheetID = styleSheetIDMap.get(sheet);
        if (!sheetID) {
            app.debug.warn('No sheedID found for', sheet, styleSheetIDMap);
            return;
        }
        const cssText = topmostRule.cssText;
        const ruleList = sheet.cssRules;
        const idx = Array.from(ruleList).indexOf(topmostRule);
        if (idx >= 0) {
            app.send(AdoptedSSInsertRuleURLBased(sheetID, cssText, idx, app.getBaseHref()));
            app.send(AdoptedSSDeleteRule(sheetID, idx + 1)); // Remove previous clone
        }
        else {
            app.debug.warn('Rule index not found in', sheet, topmostRule);
        }
    });
    const patchContext = app.safe((context) => {
        const { insertRule, deleteRule } = context.CSSStyleSheet.prototype;
        const { insertRule: groupInsertRule, deleteRule: groupDeleteRule } = context.CSSGroupingRule.prototype;
        context.CSSStyleSheet.prototype.insertRule = function (rule, index = 0) {
            sendInsertDeleteRule(this, index, rule);
            return insertRule.call(this, rule, index);
        };
        context.CSSStyleSheet.prototype.deleteRule = function (index) {
            sendInsertDeleteRule(this, index);
            return deleteRule.call(this, index);
        };
        context.CSSGroupingRule.prototype.insertRule = function (rule, index = 0) {
            const result = groupInsertRule.call(this, rule, index);
            sendReplaceGroupingRule(this);
            return result;
        };
        context.CSSGroupingRule.prototype.deleteRule = function (index = 0) {
            const result = groupDeleteRule.call(this, index);
            sendReplaceGroupingRule(this);
            return result;
        };
    });
    patchContext(window);
    app.observer.attachContextCallback(patchContext);
    app.nodes.attachNodeCallback((node) => {
        if (!hasTag(node, 'style') || !node.sheet) {
            return;
        }
        if (node.textContent !== null && node.textContent.trim().length > 0) {
            return; // Non-virtual styles captured by the observer as a text
        }
        const nodeID = app.nodes.getID(node);
        if (!nodeID) {
            return;
        }
        const sheet = node.sheet;
        const sheetID = nextID();
        styleSheetIDMap.set(sheet, sheetID);
        app.send(AdoptedSSAddOwner(sheetID, nodeID));
        const rules = sheet.cssRules;
        for (let i = 0; i < rules.length; i++) {
            sendInsertDeleteRule(sheet, i, rules[i].cssText);
        }
    });
}

function Focus (app) {
    function sendSetNodeFocus(n) {
        const id = app.nodes.getID(n);
        if (id !== undefined) {
            app.send(SetNodeFocus(id));
        }
    }
    let blurred = false;
    app.nodes.attachNodeCallback((node) => {
        if (!hasTag(node, 'body')) {
            return;
        }
        app.nodes.attachNodeListener(node, 'focus', (e) => {
            if (!isNode(e.target)) {
                return;
            }
            sendSetNodeFocus(e.target);
            blurred = false;
        });
        app.nodes.attachNodeListener(node, 'blur', (e) => {
            if (e.relatedTarget === null) {
                blurred = true;
                setTimeout(() => {
                    if (blurred) {
                        app.send(SetNodeFocus(-1));
                    }
                }, 0);
            }
        });
    });
    app.attachStartCallback(() => {
        let elem = document.activeElement;
        while (elem && hasTag(elem, 'iframe') && elem.contentDocument) {
            elem = elem.contentDocument.activeElement;
        }
        if (elem && elem !== elem.ownerDocument.body) {
            sendSetNodeFocus(elem);
        }
    }, true);
}

function Fonts (app) {
    if (!window.FontFace) {
        return;
    }
    const docFonts = new Map();
    const patchWindow = (wnd) => {
        // @ts-ignore
        class FontFaceInterceptor extends wnd.FontFace {
            constructor(...args) {
                //maybe do this on load(). In this case check if the document.fonts.load(...) function calls the font's load()
                if (typeof args[1] === 'string') {
                    let desc = '';
                    if (args[2]) {
                        app.safe(() => {
                            desc = JSON.stringify(args[2]);
                        });
                    }
                    const ffData = [args[0], args[1], desc];
                    const ffDataArr = docFonts.get(wnd.document) || [];
                    ffDataArr.push(ffData);
                    docFonts.set(wnd.document, ffDataArr);
                    const parentID = wnd === window ? 0 : app.nodes.getID(wnd.document);
                    if (parentID === undefined) {
                        return;
                    }
                    if (app.active()) {
                        app.send(LoadFontFace(parentID, ...ffData));
                    }
                }
                super(...args);
            }
        }
        wnd.FontFace = FontFaceInterceptor;
    };
    app.observer.attachContextCallback(patchWindow);
    patchWindow(window);
    app.nodes.attachNodeCallback(app.safe((node) => {
        if (!isDocument(node)) {
            return;
        }
        const ffDataArr = docFonts.get(node);
        if (!ffDataArr) {
            return;
        }
        const parentID = node.defaultView === window ? 0 : app.nodes.getID(node);
        if (parentID === undefined) {
            return;
        }
        ffDataArr.forEach((ffData) => {
            app.send(LoadFontFace(parentID, ...ffData));
        });
    }));
}

function axiosSpy (app, instance, opts, sanitize, stringify) {
    app.debug.log('Openreplay: attaching axios spy to instance', instance);
    function captureResponseData(axiosResponseObj) {
        app.debug.log('Openreplay: capturing axios response data', axiosResponseObj);
        const { headers: reqHs, data: reqData, method, url, baseURL } = axiosResponseObj.config;
        const { data: rData, headers: rHs, status: globStatus, response } = axiosResponseObj;
        const { data: resData, headers: resHs, status: resStatus } = response || {};
        const ihOpt = opts.ignoreHeaders;
        const isHIgnoring = Array.isArray(ihOpt) ? (name) => ihOpt.includes(name) : () => ihOpt;
        function writeHeader(hsObj, header) {
            if (!isHIgnoring(header[0])) {
                hsObj[header[0]] = header[1];
            }
        }
        let requestHs = {};
        let responseHs = {};
        if (reqHs.toJSON) {
            requestHs = reqHs.toJSON();
        }
        else if (reqHs instanceof Headers) {
            reqHs.forEach((v, n) => writeHeader(requestHs, [n, v]));
        }
        else if (Array.isArray(reqHs)) {
            reqHs.forEach((h) => writeHeader(requestHs, h));
        }
        else if (typeof reqHs === 'object') {
            Object.entries(reqHs).forEach((h) => writeHeader(requestHs, h));
        }
        const usedResHeader = resHs ? resHs : rHs;
        if (usedResHeader.toJSON) {
            responseHs = usedResHeader.toJSON();
        }
        else if (usedResHeader instanceof Headers) {
            usedResHeader.forEach((v, n) => writeHeader(responseHs, [n, v]));
        }
        else if (Array.isArray(usedResHeader)) {
            usedResHeader.forEach((h) => writeHeader(responseHs, h));
        }
        else if (typeof usedResHeader === 'object') {
            Object.entries(usedResHeader).forEach(([n, v]) => {
                if (!isHIgnoring(n))
                    responseHs[n] = v;
            });
        }
        const reqResInfo = sanitize({
            url,
            method: method || '',
            status: globStatus || resStatus || 0,
            request: {
                headers: requestHs,
                body: reqData,
            },
            response: {
                headers: responseHs,
                body: resData || rData,
            },
        });
        if (!reqResInfo) {
            app.debug.log('Openreplay: empty request/response info, skipping');
            return;
        }
        const requestStart = axiosResponseObj.config.__openreplay_timing;
        const duration = performance.now() - requestStart;
        app.debug.log('Openreplay: final req object', reqResInfo);
        app.send(NetworkRequest('xhr', String(method), String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), reqResInfo.status, requestStart + getTimeOrigin(), duration, 0));
    }
    function getStartTime(config) {
        app.debug.log('Openreplay: capturing API request', config);
        config.__openreplay_timing = performance.now();
        if (opts.sessionTokenHeader) {
            const header = typeof opts.sessionTokenHeader === 'string'
                ? opts.sessionTokenHeader
                : 'X-OpenReplay-Session-Token';
            const headerValue = app.getSessionToken();
            if (headerValue) {
                config.headers.set(header, headerValue);
            }
        }
        return config;
    }
    function captureNetworkRequest(response) {
        if (opts.failuresOnly)
            return response;
        captureResponseData(response);
        return response;
    }
    function captureNetworkError(error) {
        app.debug.log('Openreplay: capturing API request error', error);
        if (isAxiosError(error) && Boolean(error.response)) {
            captureResponseData(error.response);
        }
        else if (error instanceof Error) {
            app.send(getExceptionMessage(error, []));
        }
        return Promise.reject(error);
    }
    function logRequestError(ev) {
        app.debug.log('Openreplay: failed API request, skipping', ev);
    }
    const reqInt = instance.interceptors.request.use(getStartTime, logRequestError, {
        synchronous: true,
    });
    const resInt = instance.interceptors.response.use(captureNetworkRequest, captureNetworkError, {
        synchronous: true,
    });
    app.attachStopCallback(() => {
        instance.interceptors.request.eject?.(reqInt);
        instance.interceptors.response.eject?.(resInt);
    });
}
function isAxiosError(payload) {
    return isObject(payload) && payload.isAxiosError === true;
}
function isObject(thing) {
    return thing !== null && typeof thing === 'object';
}

const sensitiveParams = new Set([
    "password",
    "pass",
    "pwd",
    "mdp",
    "token",
    "bearer",
    "jwt",
    "api_key",
    "api-key",
    "apiKey",
    "secret",
    "ssn",
    "zip",
    "zipcode",
    "x-api-key",
    "www-authenticate",
    "x-csrf-token",
    "x-requested-with",
    "x-forwarded-for",
    "x-real-ip",
    "cookie",
    "authorization",
    "auth",
    "proxy-authorization",
    "set-cookie",
    "account_key",
]);
function numDigits(x) {
    return (Math.log10((x ^ (x >> 31)) - (x >> 31)) | 0) + 1;
}
function obscure(value) {
    if (typeof value === "number") {
        const digits = numDigits(value);
        return "9".repeat(digits);
    }
    return value.replace(/[^\f\n\r\t\v\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff\s]/g, '*');
}
function filterHeaders(headers) {
    const filteredHeaders = {};
    if (Array.isArray(headers)) {
        headers.forEach(({ name, value }) => {
            if (sensitiveParams.has(name.toLowerCase())) {
                filteredHeaders[name] = obscure(value);
            }
            else {
                filteredHeaders[name] = value;
            }
        });
    }
    else {
        for (const [key, value] of Object.entries(headers)) {
            if (sensitiveParams.has(key.toLowerCase())) {
                filteredHeaders[key] = obscure(value);
            }
            else {
                filteredHeaders[key] = value;
            }
        }
    }
    return filteredHeaders;
}
function filterBody(body) {
    if (!body) {
        return body;
    }
    let parsedBody;
    let isJSON = false;
    try {
        parsedBody = JSON.parse(body);
        isJSON = true;
    }
    catch (e) {
        // not json
    }
    if (isJSON) {
        obscureSensitiveData(parsedBody);
        return JSON.stringify(parsedBody);
    }
    else {
        const params = new URLSearchParams(body);
        for (const key of params.keys()) {
            if (sensitiveParams.has(key.toLowerCase())) {
                const value = obscure(params.get(key));
                params.set(key, value);
            }
        }
        return params.toString();
    }
}
function sanitizeObject(obj) {
    obscureSensitiveData(obj);
    return obj;
}
function obscureSensitiveData(obj) {
    if (Array.isArray(obj)) {
        obj.forEach(obscureSensitiveData);
    }
    else if (obj && typeof obj === "object") {
        for (const key in obj) {
            if (Object.hasOwn(obj, key)) {
                if (sensitiveParams.has(key.toLowerCase())) {
                    obj[key] = obscure(obj[key]);
                }
                else if (obj[key] !== null && typeof obj[key] === "object") {
                    obscureSensitiveData(obj[key]);
                }
            }
        }
    }
}
function tryFilterUrl(url) {
    if (!url)
        return "";
    try {
        const urlObj = new URL(url);
        if (urlObj.searchParams) {
            for (const key of urlObj.searchParams.keys()) {
                if (sensitiveParams.has(key.toLowerCase())) {
                    urlObj.searchParams.set(key, "******");
                }
            }
        }
        return urlObj.toString();
    }
    catch (e) {
        return url;
    }
}

/**
 * I know we're not using most of the information from this class
 * but it can be useful in the future if we will decide to display more stuff in our ui
 * */
class NetworkMessage {
    constructor(ignoredHeaders = [], setSessionTokenHeader, sanitize) {
        this.ignoredHeaders = ignoredHeaders;
        this.setSessionTokenHeader = setSessionTokenHeader;
        this.sanitize = sanitize;
        this.id = '';
        this.name = '';
        this.method = '';
        this.url = '';
        this.status = 0;
        this.statusText = '';
        this.cancelState = 0;
        this.readyState = 0;
        this.header = {};
        this.responseType = '';
        this.requestType = 'xhr';
        this.requestHeader = {};
        this.responseSize = 0; // bytes
        this.responseSizeText = '';
        this.startTime = 0;
        this.endTime = 0;
        this.duration = 0;
        this.getData = {};
        this.requestData = null;
    }
    getMessage() {
        const { reqHs, resHs } = this.writeHeaders();
        const reqBody = this.method === 'GET'
            ? JSON.stringify(sanitizeObject(this.getData)) : filterBody(this.requestData);
        const request = {
            headers: filterHeaders(reqHs),
            body: reqBody,
        };
        const response = {
            headers: filterHeaders(resHs),
            body: filterBody(this.response)
        };
        const messageInfo = this.sanitize({
            url: tryFilterUrl(this.url),
            method: this.method,
            status: this.status,
            request,
            response,
        });
        if (!messageInfo)
            return null;
        const isGraphql = messageInfo.url.includes("/graphql");
        if (isGraphql && messageInfo.response.body && typeof messageInfo.response.body === 'string') {
            const isError = messageInfo.response.body.includes("errors");
            messageInfo.status = isError ? 400 : 200;
            this.requestType = 'graphql';
        }
        return {
            requestType: this.requestType,
            method: messageInfo.method,
            url: messageInfo.url,
            request: JSON.stringify(messageInfo.request),
            response: JSON.stringify(messageInfo.response),
            status: messageInfo.status,
            startTime: this.startTime,
            duration: this.duration,
            responseSize: this.responseSize,
        };
    }
    writeHeaders() {
        const reqHs = {};
        Object.entries(this.requestHeader).forEach(([key, value]) => {
            if (this.isHeaderIgnored(key))
                return;
            reqHs[key] = value;
        });
        this.setSessionTokenHeader((name, value) => {
            reqHs[name] = value;
        });
        const resHs = {};
        Object.entries(this.header).forEach(([key, value]) => {
            if (this.isHeaderIgnored(key))
                return;
            resHs[key] = value;
        });
        return { reqHs, resHs };
    }
    isHeaderIgnored(key) {
        if (Array.isArray(this.ignoredHeaders)) {
            return this.ignoredHeaders.map((k) => k.toLowerCase()).includes(key.toLowerCase());
        }
        else {
            return this.ignoredHeaders;
        }
    }
}

const getStringResponseByType = (responseType, response) => {
    let result = '';
    switch (responseType) {
        case '':
        case 'text':
        case 'json':
            if (typeof response == 'string') {
                result = response;
            }
            else if (isPureObject(response) || Array.isArray(response)) {
                result = JSON.stringify(response);
            }
            else if (typeof response !== 'undefined') {
                result = Object.prototype.toString.call(response);
            }
            break;
        case 'blob':
        case 'document':
        case 'arraybuffer':
        default:
            if (typeof response !== 'undefined') {
                result = Object.prototype.toString.call(response);
            }
            break;
    }
    return result;
};
const genStringBody = (body) => {
    if (!body) {
        return null;
    }
    let result;
    if (typeof body === 'string') {
        if (body[0] === '{' || body[0] === '[') {
            result = body;
        }
        // 'a=1&b=2' => try to parse as query
        const arr = body.split('&');
        if (arr.length === 1) {
            // not a query, parse as original string
            result = body;
        }
        else {
            // 'a=1&b=2&c' => parse as query
            result = arr.join(',');
        }
    }
    else if (isIterable(body)) {
        // FormData or URLSearchParams or Array
        const arr = [];
        for (const [key, value] of body) {
            arr.push(`${key}=${typeof value === 'string' ? value : '[object Object]'}`);
        }
        result = arr.join(',');
    }
    else if (body instanceof Blob ||
        body instanceof ReadableStream ||
        body instanceof ArrayBuffer) {
        result = 'byte data';
    }
    else if (isPureObject(body)) {
        // overriding ArrayBufferView which is not convertable to string
        result = body;
    }
    else {
        result = `can't parse body ${typeof body}`;
    }
    return result;
};
const genGetDataByUrl = (url, getData = {}) => {
    if (!isPureObject(getData)) {
        getData = {};
    }
    let query = url ? url.split('?') : []; // a.php?b=c&d=?e => ['a.php', 'b=c&d=', 'e']
    query.shift(); // => ['b=c&d=', 'e']
    if (query.length > 0) {
        query = query.join('?').split('&'); // => 'b=c&d=?e' => ['b=c', 'd=?e']
        for (const q of query) {
            const kv = q.split('=');
            try {
                getData[kv[0]] = decodeURIComponent(kv[1]);
            }
            catch (e) {
                // "URIError: URI malformed" will be thrown when `kv[1]` contains "%", so just use raw data
                // @issue #470
                // @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Malformed_URI
                getData[kv[0]] = kv[1];
            }
        }
    }
    return getData;
};
function isPureObject(input) {
    return null !== input && typeof input === 'object';
}
function isIterable(value) {
    if (value === null || value === undefined) {
        return false;
    }
    if (ArrayBuffer.isView(value)) {
        return false;
    }
    return typeof Symbol !== 'undefined' && typeof value[Symbol.iterator] === 'function';
}
function formatByteSize(bytes) {
    if (bytes <= 0) {
        // shouldn't happen?
        return '';
    }
    if (bytes >= 1000 * 1000) {
        return (bytes / 1000 / 1000).toFixed(1) + ' MB';
    }
    if (bytes >= 1000) {
        return (bytes / 1000).toFixed(1) + ' KB';
    }
    return `${bytes}B`;
}
const getURL = (urlString) => {
    if (urlString.startsWith('//')) {
        const baseUrl = new URL(window.location.href);
        urlString = `${baseUrl.protocol}${urlString}`;
    }
    if (urlString.startsWith('http')) {
        return new URL(urlString);
    }
    else {
        return new URL(urlString, window.location.href);
    }
};

// https://fetch.spec.whatwg.org/#concept-bodyinit-extract
const getContentType = (data) => {
    if (data instanceof Blob) {
        return data.type;
    }
    if (data instanceof FormData) {
        return 'multipart/form-data';
    }
    if (data instanceof URLSearchParams) {
        return 'application/x-www-form-urlencoded;charset=UTF-8';
    }
    return 'text/plain;charset=UTF-8';
};
class BeaconProxyHandler {
    constructor(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl) {
        this.ignoredHeaders = ignoredHeaders;
        this.setSessionTokenHeader = setSessionTokenHeader;
        this.sanitize = sanitize;
        this.sendMessage = sendMessage;
        this.isServiceUrl = isServiceUrl;
    }
    apply(target, thisArg, argsList) {
        const urlString = argsList[0];
        const data = argsList[1];
        const item = new NetworkMessage(this.ignoredHeaders, this.setSessionTokenHeader, this.sanitize);
        if (this.isServiceUrl(urlString)) {
            return target.apply(thisArg, argsList);
        }
        const url = getURL(urlString);
        item.method = 'POST';
        item.url = urlString;
        item.name = (url.pathname.split('/').pop() || '') + url.search;
        item.requestType = 'beacon';
        item.requestHeader = { 'Content-Type': getContentType(data) };
        item.status = 0;
        item.statusText = 'Pending';
        if (url.search && url.searchParams) {
            item.getData = {};
            for (const [key, value] of url.searchParams) {
                item.getData[key] = value;
            }
        }
        item.requestData = genStringBody(data);
        if (!item.startTime) {
            item.startTime = performance.now();
        }
        const isSuccess = target.apply(thisArg, argsList);
        if (isSuccess) {
            item.endTime = performance.now();
            item.duration = item.endTime - (item.startTime || item.endTime);
            item.status = 0;
            item.statusText = 'Sent';
            item.readyState = 4;
        }
        else {
            item.status = 500;
            item.statusText = 'Unknown';
        }
        const msg = item.getMessage();
        if (msg) {
            this.sendMessage(msg);
        }
        return isSuccess;
    }
}
class BeaconProxy {
    static create(originalSendBeacon, ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl) {
        if (!originalSendBeacon) {
            return undefined;
        }
        return new Proxy(originalSendBeacon, new BeaconProxyHandler(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl));
    }
}

var RequestState;
(function (RequestState) {
    RequestState[RequestState["UNSENT"] = 0] = "UNSENT";
    RequestState[RequestState["OPENED"] = 1] = "OPENED";
    RequestState[RequestState["HEADERS_RECEIVED"] = 2] = "HEADERS_RECEIVED";
    RequestState[RequestState["LOADING"] = 3] = "LOADING";
    RequestState[RequestState["DONE"] = 4] = "DONE";
})(RequestState || (RequestState = {}));

/**
 * I took inspiration in few stack exchange posts
 * and Tencent vConsole library (MIT)
 * by wrapping the XMLHttpRequest object in a Proxy
 * we can intercept the network requests
 * in not-so-hacky way
 * */
class ResponseProxyHandler {
    constructor(resp, item) {
        this.resp = resp;
        this.item = item;
        this.mockReader();
    }
    set(target, key, value) {
        return Reflect.set(target, key, value);
    }
    get(target, key) {
        const value = Reflect.get(target, key);
        switch (key) {
            case 'arrayBuffer':
            case 'blob':
            case 'formData':
            case 'json':
            case 'text':
                return () => {
                    this.item.responseType = key.toLowerCase();
                    // @ts-ignore
                    return value.apply(target).then((resp) => {
                        this.item.response = getStringResponseByType(this.item.responseType, resp);
                        return resp;
                    });
                };
        }
        if (typeof value === 'function') {
            return value.bind(target);
        }
        else {
            return value;
        }
    }
    mockReader() {
        let readerReceivedValue;
        if (!this.resp.body) {
            // some browsers do not return `body` in some cases, like `OPTIONS` method
            return;
        }
        if (typeof this.resp.body.getReader !== 'function') {
            return;
        }
        const _getReader = this.resp.body.getReader;
        // @ts-ignore
        this.resp.body.getReader = () => {
            const reader = _getReader.apply(this.resp.body);
            // when readyState is already 4,
            // it's not a chunked stream, or it had already been read.
            // so should not update status.
            if (this.item.readyState === RequestState.DONE) {
                return reader;
            }
            const _read = reader.read;
            const _cancel = reader.cancel;
            this.item.responseType = 'arraybuffer';
            // @ts-ignore
            reader.read = () => {
                return _read.apply(reader).then((result) => {
                    if (!readerReceivedValue) {
                        // @ts-ignore
                        readerReceivedValue = new Uint8Array(result.value);
                    }
                    else {
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        const newValue = new Uint8Array(readerReceivedValue.length + result.value.length);
                        newValue.set(readerReceivedValue);
                        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                        newValue.set(result.value, readerReceivedValue.length);
                        readerReceivedValue = newValue;
                    }
                    this.item.endTime = performance.now();
                    this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);
                    this.item.readyState = result.done ? 4 : 3;
                    this.item.statusText = result.done ? String(this.item.status) : 'Loading';
                    this.item.responseSize = readerReceivedValue.length;
                    this.item.responseSizeText = formatByteSize(this.item.responseSize);
                    if (result.done) {
                        this.item.response = getStringResponseByType(this.item.responseType, readerReceivedValue);
                    }
                    return result;
                });
            };
            reader.cancel = (...args) => {
                this.item.cancelState = 2;
                this.item.statusText = 'Cancel';
                this.item.endTime = performance.now();
                this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);
                this.item.response = getStringResponseByType(this.item.responseType, readerReceivedValue);
                return _cancel.apply(reader, args);
            };
            return reader;
        };
    }
}
class FetchProxyHandler {
    constructor(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {
        this.ignoredHeaders = ignoredHeaders;
        this.setSessionTokenHeader = setSessionTokenHeader;
        this.sanitize = sanitize;
        this.sendMessage = sendMessage;
        this.isServiceUrl = isServiceUrl;
        this.tokenUrlMatcher = tokenUrlMatcher;
    }
    apply(target, _, argsList) {
        const input = argsList[0];
        const init = argsList[1];
        if (!input ||
            // @ts-ignore
            (typeof input !== 'string' && !(input === null || input === void 0 ? void 0 : input.url))) {
            return target.apply(window, argsList);
        }
        const isORUrl = input instanceof URL || typeof input === 'string'
            ? this.isServiceUrl(String(input))
            : this.isServiceUrl(String(input.url));
        if (isORUrl) {
            return target.apply(window, argsList);
        }
        const item = new NetworkMessage(this.ignoredHeaders, this.setSessionTokenHeader, this.sanitize);
        this.beforeFetch(item, input, init);
        this.setSessionTokenHeader((name, value) => {
            if (this.tokenUrlMatcher !== undefined) {
                if (!this.tokenUrlMatcher(item.url)) {
                    return;
                }
            }
            if (argsList[1] === undefined && argsList[0] instanceof Request) {
                return argsList[0].headers.append(name, value);
            }
            else {
                if (!argsList[1])
                    argsList[1] = {};
                if (argsList[1].headers === undefined) {
                    argsList[1] = Object.assign(Object.assign({}, argsList[1]), { headers: {} });
                }
                if (argsList[1].headers instanceof Headers) {
                    argsList[1].headers.append(name, value);
                }
                else if (Array.isArray(argsList[1].headers)) {
                    argsList[1].headers.push([name, value]);
                }
                else {
                    // @ts-ignore
                    argsList[1].headers[name] = value;
                }
            }
        });
        return target.apply(window, argsList)
            .then(this.afterFetch(item))
            .catch((e) => {
            // mock finally
            item.endTime = performance.now();
            item.duration = item.endTime - (item.startTime || item.endTime);
            throw e;
        });
    }
    beforeFetch(item, input, init) {
        let url, method = 'GET', requestHeader = {};
        // handle `input` content
        if (typeof input === 'string') {
            // when `input` is a string
            method = (init === null || init === void 0 ? void 0 : init.method) || 'GET';
            url = getURL(input);
            requestHeader = (init === null || init === void 0 ? void 0 : init.headers) || {};
        }
        else {
            // when `input` is a `Request` object
            method = input.method || 'GET';
            url = getURL(input.url);
            requestHeader = input.headers;
        }
        item.method = method;
        item.requestType = 'fetch';
        item.requestHeader = requestHeader;
        item.url = url.toString();
        item.name = (url.pathname.split('/').pop() || '') + url.search;
        item.status = 0;
        item.statusText = 'Pending';
        item.readyState = 1;
        if (!item.startTime) {
            // UNSENT
            item.startTime = performance.now();
        }
        if (Object.prototype.toString.call(requestHeader) === '[object Headers]') {
            item.requestHeader = {};
            for (const [key, value] of requestHeader) {
                item.requestHeader[key] = value;
            }
        }
        else {
            item.requestHeader = requestHeader;
        }
        // save GET data
        if (url.search && url.searchParams) {
            item.getData = {};
            for (const [key, value] of url.searchParams) {
                item.getData[key] = value;
            }
        }
        // save POST data
        if (init === null || init === void 0 ? void 0 : init.body) {
            item.requestData = genStringBody(init.body);
        }
    }
    afterFetch(item) {
        return (resp) => {
            item.endTime = performance.now();
            item.duration = item.endTime - (item.startTime || item.endTime);
            item.status = resp.status;
            item.statusText = String(resp.status);
            let isChunked = false;
            item.header = {};
            for (const [key, value] of resp.headers) {
                item.header[key] = value;
                isChunked = value.toLowerCase().indexOf('chunked') > -1 ? true : isChunked;
            }
            if (isChunked) {
                // when `transfer-encoding` is chunked, the response is a stream which is under loading,
                // so the `readyState` should be 3 (Loading),
                // and the response should NOT be `clone()` which will affect stream reading.
                item.readyState = 3;
            }
            else {
                // Otherwise, not chunked, the response is not a stream,
                // so it's completed and can be cloned for `text()` calling.
                item.readyState = 4;
                this.handleResponseBody(resp.clone(), item)
                    .then((responseValue) => {
                    item.responseSize =
                        typeof responseValue === 'string' ? responseValue.length : responseValue.byteLength;
                    item.responseSizeText = formatByteSize(item.responseSize);
                    item.response = getStringResponseByType(item.responseType, responseValue);
                    const msg = item.getMessage();
                    if (msg) {
                        this.sendMessage(msg);
                    }
                })
                    .catch((e) => {
                    if (e.name !== 'AbortError') {
                        throw e;
                    }
                });
            }
            return new Proxy(resp, new ResponseProxyHandler(resp, item));
        };
    }
    handleResponseBody(resp, item) {
        // parse response body by Content-Type
        const contentType = resp.headers.get('content-type');
        if (contentType && contentType.includes('application/json')) {
            item.responseType = 'json';
            return resp.text();
        }
        else if (contentType &&
            (contentType.includes('text/html') || contentType.includes('text/plain'))) {
            item.responseType = 'text';
            return resp.text();
        }
        else {
            item.responseType = 'arraybuffer';
            return resp.arrayBuffer();
        }
    }
}
class FetchProxy {
    static create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {
        return new Proxy(fetch, new FetchProxyHandler(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher));
    }
}

/**
 * I took inspiration in few stack exchange posts
 * and Tencent vConsole library (MIT)
 * by wrapping the XMLHttpRequest object in a Proxy
 * we can intercept the network requests
 * in not-so-hacky way
 * */
class XHRProxyHandler {
    constructor(XMLReq, ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {
        this.ignoredHeaders = ignoredHeaders;
        this.setSessionTokenHeader = setSessionTokenHeader;
        this.sanitize = sanitize;
        this.sendMessage = sendMessage;
        this.isServiceUrl = isServiceUrl;
        this.tokenUrlMatcher = tokenUrlMatcher;
        this.XMLReq = XMLReq;
        this.XMLReq.onreadystatechange = () => {
            this.onReadyStateChange();
        };
        this.XMLReq.onabort = () => {
            this.onAbort();
        };
        this.XMLReq.ontimeout = () => {
            this.onTimeout();
        };
        this.item = new NetworkMessage(ignoredHeaders, setSessionTokenHeader, sanitize);
        this.item.requestType = 'xhr';
    }
    get(target, key) {
        switch (key) {
            case 'open':
                return this.getOpen(target);
            case 'send':
                this.setSessionTokenHeader((name, value) => {
                    if (this.tokenUrlMatcher !== undefined) {
                        if (!this.tokenUrlMatcher(this.item.url)) {
                            return;
                        }
                    }
                    target.setRequestHeader(name, value);
                });
                return this.getSend(target);
            case 'setRequestHeader':
                return this.getSetRequestHeader(target);
            default:
                // eslint-disable-next-line no-case-declarations
                const value = Reflect.get(target, key);
                if (typeof value === 'function') {
                    return value.bind(target);
                }
                else {
                    return value;
                }
        }
    }
    set(target, key, value) {
        switch (key) {
            case 'onreadystatechange':
                return this.setOnReadyStateChange(target, key, value);
            case 'onabort':
                return this.setOnAbort(target, key, value);
            case 'ontimeout':
                return this.setOnTimeout(target, key, value);
            // not tracked methods
        }
        return Reflect.set(target, key, value);
    }
    onReadyStateChange() {
        if (this.item.url && this.isServiceUrl(this.item.url))
            return;
        this.item.readyState = this.XMLReq.readyState;
        this.item.responseType = this.XMLReq.responseType;
        this.item.endTime = performance.now();
        this.item.duration = this.item.endTime - this.item.startTime;
        this.updateItemByReadyState();
        setTimeout(() => {
            this.item.response = getStringResponseByType(this.item.responseType, this.item.response);
        }, 0);
        if (this.XMLReq.readyState === RequestState.DONE) {
            const msg = this.item.getMessage();
            if (msg) {
                this.sendMessage(msg);
            }
        }
    }
    onAbort() {
        this.item.cancelState = 1;
        this.item.statusText = 'Abort';
        const msg = this.item.getMessage();
        if (msg) {
            this.sendMessage(msg);
        }
    }
    onTimeout() {
        this.item.cancelState = 3;
        this.item.statusText = 'Timeout';
        const msg = this.item.getMessage();
        if (msg) {
            this.sendMessage(msg);
        }
    }
    getOpen(target) {
        const targetFunction = Reflect.get(target, 'open');
        return (...args) => {
            var _a, _b, _c;
            const method = args[0];
            const url = args[1];
            this.item.method = method ? method.toUpperCase() : 'GET';
            this.item.url = ((_a = url.toString) === null || _a === void 0 ? void 0 : _a.call(url)) || '';
            this.item.name = (_c = (_b = this.item.url) === null || _b === void 0 ? void 0 : _b.replace(new RegExp('/*$'), '').split('/').pop()) !== null && _c !== void 0 ? _c : '';
            this.item.getData = genGetDataByUrl(this.item.url, {});
            return targetFunction.apply(target, args);
        };
    }
    getSend(target) {
        const targetFunction = Reflect.get(target, 'send');
        return (...args) => {
            const data = args[0];
            this.item.requestData = genStringBody(data);
            return targetFunction.apply(target, args);
        };
    }
    getSetRequestHeader(target) {
        const targetFunction = Reflect.get(target, 'setRequestHeader');
        return (...args) => {
            if (!this.item.requestHeader) {
                this.item.requestHeader = {};
            }
            // @ts-ignore
            this.item.requestHeader[args[0]] = args[1];
            return targetFunction.apply(target, args);
        };
    }
    setOnReadyStateChange(target, key, orscFunction) {
        return Reflect.set(target, key, (...args) => {
            this.onReadyStateChange();
            orscFunction === null || orscFunction === void 0 ? void 0 : orscFunction.apply(target, args);
        });
    }
    setOnAbort(target, key, oaFunction) {
        return Reflect.set(target, key, (...args) => {
            this.onAbort();
            oaFunction.apply(target, args);
        });
    }
    setOnTimeout(target, key, otFunction) {
        return Reflect.set(target, key, (...args) => {
            this.onTimeout();
            otFunction.apply(target, args);
        });
    }
    /**
     * Update item's properties according to readyState.
     */
    updateItemByReadyState() {
        switch (this.XMLReq.readyState) {
            case RequestState.UNSENT:
            case RequestState.OPENED:
                this.item.status = RequestState.UNSENT;
                this.item.statusText = 'Pending';
                if (!this.item.startTime) {
                    this.item.startTime = performance.now();
                }
                break;
            case RequestState.HEADERS_RECEIVED:
                this.item.status = this.XMLReq.status;
                this.item.statusText = 'Loading';
                this.item.header = {};
                // eslint-disable-next-line no-case-declarations
                const header = this.XMLReq.getAllResponseHeaders() || '', headerArr = header.split('\n');
                // extract plain text to key-value format
                for (let i = 0; i < headerArr.length; i++) {
                    const line = headerArr[i];
                    if (!line) {
                        continue;
                    }
                    const arr = line.split(': ');
                    const key = arr[0];
                    this.item.header[key] = arr.slice(1).join(': ');
                }
                break;
            case RequestState.LOADING:
                this.item.status = this.XMLReq.status;
                this.item.statusText = 'Loading';
                if (!!this.XMLReq.response && this.XMLReq.response.length) {
                    this.item.responseSize = this.XMLReq.response.length;
                    this.item.responseSizeText = formatByteSize(this.item.responseSize);
                }
                break;
            case RequestState.DONE:
                // `XMLReq.abort()` will change `status` from 200 to 0, so use previous value in this case
                this.item.status = this.XMLReq.status || this.item.status || 0;
                // show status code when request completed
                this.item.statusText = String(this.item.status);
                this.item.endTime = performance.now();
                this.item.duration = this.item.endTime - (this.item.startTime || this.item.endTime);
                this.item.response = this.XMLReq.response;
                if (!!this.XMLReq.response && this.XMLReq.response.length) {
                    this.item.responseSize = this.XMLReq.response.length;
                    this.item.responseSizeText = formatByteSize(this.item.responseSize);
                }
                break;
            default:
                this.item.status = this.XMLReq.status;
                this.item.statusText = 'Unknown';
                break;
        }
    }
}
class XHRProxy {
    static create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher) {
        return new Proxy(XMLHttpRequest, {
            construct(original) {
                const XMLReq = new original();
                return new Proxy(XMLReq, new XHRProxyHandler(XMLReq, ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher));
            },
        });
    }
}

const getWarning = (api) => {
    const str = `Openreplay: Can't find ${api} in global context.`;
    console.warn(str);
};
/**
 * Creates network proxies for XMLHttpRequest, fetch, and sendBeacon to intercept and monitor network requests and
 * responses.
 *
 * @param {Window | typeof globalThis} context - The global context object (e.g., window or globalThis).
 * @param {boolean | string[]} ignoredHeaders - Headers to ignore from requests. If `true`, all headers are ignored; if
 *   an array of strings, those header names are ignored.
 * @param {(cb: (name: string, value: string) => void) => void} setSessionTokenHeader - Function to set a session token
 *   header; accepts a callback that sets the header name and value.
 * @param {(data: RequestResponseData) => RequestResponseData | null} sanitize - Function to sanitize request and
 *   response data; should return sanitized data or `null` to ignore the data.
 * @param {(message: INetworkMessage) => void} sendMessage - Function to send network messages for further processing
 *   or logging.
 * @param {(url: string) => boolean} isServiceUrl - Function to determine if a URL is a service URL that should be
 *   ignored by the proxy.
 * @param {Object} [modules] - Modules to apply the proxies to.
 * @param {boolean} [modules.xhr=true] - Whether to proxy XMLHttpRequest.
 * @param {boolean} [modules.fetch=true] - Whether to proxy the fetch API.
 * @param {boolean} [modules.beacon=true] - Whether to proxy navigator.sendBeacon.
 * @param {(url: string) => boolean} [tokenUrlMatcher] - Optional function; the session token header will only be
 *   applied to requests matching this function.
 *
 * @returns {void}
 */
function createNetworkProxy(context, ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, modules = {
    xhr: true,
    fetch: true,
    beacon: true,
}, tokenUrlMatcher) {
    var _a;
    if (!context)
        return;
    if (modules.xhr) {
        if (context.XMLHttpRequest) {
            context.XMLHttpRequest = XHRProxy.create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher);
        }
        else {
            getWarning("XMLHttpRequest");
        }
    }
    if (modules.fetch) {
        if (context.fetch) {
            context.fetch = FetchProxy.create(ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl, tokenUrlMatcher);
        }
        else {
            getWarning("fetch");
        }
    }
    if (modules.beacon) {
        if ((_a = context.navigator) === null || _a === void 0 ? void 0 : _a.sendBeacon) {
            const origBeacon = context.navigator.sendBeacon;
            context.navigator.sendBeacon = BeaconProxy.create(origBeacon, ignoredHeaders, setSessionTokenHeader, sanitize, sendMessage, isServiceUrl);
        }
    }
}

function getXHRRequestDataObject(xhr) {
    // @ts-ignore  this is 3x faster than using Map<XHR, XHRRequestData>
    if (!xhr.__or_req_data__) {
        // @ts-ignore
        xhr.__or_req_data__ = { body: undefined, headers: {} };
    }
    // @ts-ignore
    return xhr.__or_req_data__;
}
function strMethod(method) {
    return typeof method === 'string' ? method.toUpperCase() : 'GET';
}
function Network (app, opts = {}) {
    if (opts.disabled) {
        return;
    }
    const options = Object.assign({
        failuresOnly: false,
        ignoreHeaders: ['cookie', 'set-cookie', 'authorization'],
        capturePayload: false,
        sessionTokenHeader: false,
        captureInIframes: true,
        axiosInstances: undefined,
        useProxy: true,
    }, opts);
    if (options.useProxy === false) {
        app.debug.warn('Network module is migrating to proxy api, to gradually migrate and test it set useProxy to true');
    }
    const ignoreHeaders = options.ignoreHeaders;
    const isHIgnored = Array.isArray(ignoreHeaders)
        ? (name) => ignoreHeaders.includes(name)
        : () => ignoreHeaders;
    const stHeader = options.sessionTokenHeader === true ? 'X-OpenReplay-SessionToken' : options.sessionTokenHeader;
    function setSessionTokenHeader(setRequestHeader) {
        if (stHeader) {
            const sessionToken = app.getSessionToken();
            if (sessionToken) {
                app.safe(setRequestHeader)(stHeader, sessionToken);
            }
        }
    }
    function sanitize(reqResInfo) {
        if (!options.capturePayload || app.sanitizer.privateMode) {
            // @ts-ignore
            delete reqResInfo.request.body;
            delete reqResInfo.response.body;
        }
        if (options.sanitizer) {
            const resBody = reqResInfo.response.body;
            if (typeof resBody === 'string') {
                // Parse response in order to have handy view in sanitization function
                try {
                    reqResInfo.response.body = JSON.parse(resBody);
                }
                catch { }
            }
            return options.sanitizer(reqResInfo);
        }
        return reqResInfo;
    }
    function stringify(r) {
        if (r && typeof r.body !== 'string') {
            try {
                r.body = JSON.stringify(r.body);
            }
            catch {
                r.body = '<unable to stringify>';
                app.notify.warn("Openreplay fetch couldn't stringify body:", r.body);
            }
        }
        return JSON.stringify(r);
    }
    const patchWindow = (context) => {
        /* ====== modern way ====== */
        if (options.useProxy) {
            return createNetworkProxy(context, app.sanitizer.privateMode ? true : options.ignoreHeaders, setSessionTokenHeader, sanitize, (message) => {
                if (options.failuresOnly && message.status < 400) {
                    return;
                }
                const url = app.sanitizer.privateMode ? '************' : message.url;
                app.send(NetworkRequest(message.requestType, message.method, url, message.request, message.response, message.status, message.startTime + getTimeOrigin(), message.duration, message.responseSize));
            }, (url) => app.isServiceURL(url), { xhr: true, fetch: true, beacon: true }, options.tokenUrlMatcher);
        }
        /* ====== Fetch ====== */
        const origFetch = context.fetch.bind(context);
        const trackFetch = (input, init = {}) => {
            if (!(typeof input === 'string' || input instanceof URL) || app.isServiceURL(String(input))) {
                return origFetch(input, init);
            }
            setSessionTokenHeader(function (name, value) {
                if (init.headers === undefined) {
                    init.headers = {};
                }
                if (init.headers instanceof Headers) {
                    init.headers.append(name, value);
                }
                else if (Array.isArray(init.headers)) {
                    init.headers.push([name, value]);
                }
                else {
                    init.headers[name] = value;
                }
            });
            const startTime = performance.now();
            return origFetch(input, init).then((response) => {
                const duration = performance.now() - startTime;
                if (options.failuresOnly && response.status < 400) {
                    return response;
                }
                const r = response.clone();
                r.text()
                    .then((text) => {
                    const reqHs = {};
                    const resHs = {};
                    if (ignoreHeaders !== true) {
                        // request headers
                        const writeReqHeader = ([n, v]) => {
                            if (!isHIgnored(n)) {
                                reqHs[n] = v;
                            }
                        };
                        if (init.headers instanceof Headers) {
                            init.headers.forEach((v, n) => writeReqHeader([n, v]));
                        }
                        else if (Array.isArray(init.headers)) {
                            init.headers.forEach(writeReqHeader);
                        }
                        else if (typeof init.headers === 'object') {
                            Object.entries(init.headers).forEach(writeReqHeader);
                        }
                        // response headers
                        r.headers.forEach((v, n) => {
                            if (!isHIgnored(n))
                                resHs[n] = v;
                        });
                    }
                    const method = strMethod(init.method);
                    const reqResInfo = sanitize({
                        url: String(input),
                        method,
                        status: r.status,
                        request: {
                            headers: reqHs,
                            // @ts-ignore
                            body: init.body || null,
                        },
                        response: {
                            headers: resHs,
                            body: text,
                        },
                    });
                    if (!reqResInfo) {
                        return;
                    }
                    app.send(NetworkRequest('fetch', method, String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), r.status, startTime + getTimeOrigin(), duration, 0));
                })
                    .catch((e) => app.debug.error('Could not process Fetch response:', e));
                return response;
            });
        };
        // @ts-ignore
        context.fetch = trackFetch;
        /* ====== <> ====== */
        /* ====== XHR ====== */
        const nativeOpen = context.XMLHttpRequest.prototype.open;
        const nativeSetRequestHeader = context.XMLHttpRequest.prototype.setRequestHeader;
        const nativeSend = context.XMLHttpRequest.prototype.send;
        function trackXMLHttpReqOpen(initMethod, url) {
            const xhr = this;
            setSessionTokenHeader((name, value) => xhr.setRequestHeader(name, value));
            let startTime = 0;
            xhr.addEventListener('loadstart', (e) => {
                startTime = e.timeStamp;
            });
            xhr.addEventListener('load', app.safe((e) => {
                const { headers: reqHs, body: reqBody } = getXHRRequestDataObject(xhr);
                const duration = startTime > 0 ? e.timeStamp - startTime : 0;
                const hString = xhr.getAllResponseHeaders() || ''; // might be null (only if no response received though)
                const headersArr = hString.trim().split(/[\r\n]+/);
                const headerMap = {};
                headersArr.forEach(function (line) {
                    const parts = line.split(': ');
                    const header = parts.shift();
                    if (!isHIgnored(header)) {
                        headerMap[header] = parts.join(': ');
                    }
                });
                const method = strMethod(initMethod);
                const reqResInfo = sanitize({
                    url: String(url),
                    method,
                    status: xhr.status,
                    request: {
                        headers: reqHs,
                        // @ts-ignore
                        body: reqBody || null,
                    },
                    response: {
                        headers: headerMap,
                        body: xhr.response,
                    },
                });
                if (!reqResInfo) {
                    return;
                }
                app.send(NetworkRequest('xhr', method, String(reqResInfo.url), stringify(reqResInfo.request), stringify(reqResInfo.response), xhr.status, startTime + getTimeOrigin(), duration, 0));
            }));
            //TODO: handle error (though it has no Error API nor any useful information)
            //xhr.addEventListener('error', (e) => {})
            return nativeOpen.apply(this, arguments);
        }
        function trackXHRSend(body) {
            const rdo = getXHRRequestDataObject(this);
            rdo.body = body;
            // @ts-ignore ??? this -> XMLHttpRequest
            return nativeSend.apply(this, arguments);
        }
        function trackSetReqHeader(name, value) {
            if (!isHIgnored(name)) {
                const rdo = getXHRRequestDataObject(this);
                rdo.headers[name] = value;
            }
            return nativeSetRequestHeader.apply(this, arguments);
        }
        if (!options.axiosInstances) {
            context.XMLHttpRequest.prototype.open = trackXMLHttpReqOpen;
            context.XMLHttpRequest.prototype.send = trackXHRSend;
            context.XMLHttpRequest.prototype.setRequestHeader = trackSetReqHeader;
        }
        /* ====== <> ====== */
    };
    patchWindow(window);
    if (options.axiosInstances) {
        options.axiosInstances.forEach((axiosInstance) => {
            axiosSpy(app, axiosInstance, options, sanitize, stringify);
        });
    }
    if (options.captureInIframes) {
        app.observer.attachContextCallback(app.safe(patchWindow));
    }
}

function selection(app) {
    app.attachEventListener(document, 'selectionchange', () => {
        const selection = document.getSelection();
        if (selection !== null && !selection.isCollapsed) {
            const selectionStart = app.nodes.getID(selection.anchorNode);
            const selectionEnd = app.nodes.getID(selection.focusNode);
            const selectedText = selection.toString().replace(/\s+/g, ' ');
            if (selectionStart && selectionEnd) {
                app.send(SelectionChange(selectionStart, selectionEnd, selectedText));
            }
        }
        else {
            app.send(SelectionChange(-1, -1, ''));
        }
    });
}
/** TODO: research how to get all in-between nodes inside selection range
 *        including nodes between anchor and focus nodes and their children
 *        without recursively searching the dom tree
 */
// if (selection.rangeCount) {
//   const nodes = [];
//   for (let i = 0; i < selection.rangeCount; i++) {
//     const range = selection.getRangeAt(i);
//     let node: Node | null = range.startContainer;
//     while (node) {
//       nodes.push(node);
//       if (node === range.endContainer) break;
//       node = node.nextSibling;
//     }
//   }
//   // send selected nodes
// }

function Tabs (app) {
    function changeTab() {
        if (!document.hidden) {
            app.debug.log('Openreplay: tab change to' + app.session.getTabId());
            app.send(TabChange(app.session.getTabId()));
        }
    }
    app.attachEventListener(window, 'focus', changeTab, false, false);
}

const Messages = _Messages;
const DOCS_SETUP = '/en/sdk';
function processOptions(obj) {
    if (obj == null) {
        console.error(`OpenReplay: invalid options argument type. Please, check documentation on ${DOCS_HOST}${DOCS_SETUP}`);
        return false;
    }
    if (typeof obj.projectKey !== 'string') {
        if (typeof obj.projectKey !== 'number') {
            if (typeof obj.projectID !== 'number') {
                // Back compatability
                console.error(`OpenReplay: projectKey is missing or wrong type (string is expected). Please, check ${DOCS_HOST}${DOCS_SETUP} for more information.`);
                return false;
            }
            else {
                obj.projectKey = obj.projectID.toString();
                deprecationWarn('`projectID` option', '`projectKey` option', DOCS_SETUP);
            }
        }
        else {
            console.warn('OpenReplay: projectKey is expected to have a string type.');
            obj.projectKey = obj.projectKey.toString();
        }
    }
    if (obj.sessionToken != null) {
        deprecationWarn('`sessionToken` option', '`sessionHash` start() option', '/');
    }
    return true;
}
const canAccessTop = () => {
    try {
        return Boolean(window.top?.document);
    }
    catch {
        return false;
    }
};
class API {
    constructor(options) {
        this.options = options;
        this.app = null;
        this.crossdomainMode = false;
        this.checkDoNotTrack = () => {
            return (this.options.respectDoNotTrack &&
                (navigator.doNotTrack == '1' ||
                    // @ts-ignore
                    window.doNotTrack == '1'));
        };
        this.signalStartIssue = (reason, missingApi) => {
            const doNotTrack = this.checkDoNotTrack();
            console.log("Tracker couldn't start due to:", JSON.stringify({
                trackerVersion: '16.1.1',
                projectKey: this.options.projectKey,
                doNotTrack,
                reason: missingApi.length ? `missing api: ${missingApi.join(',')}` : reason,
            }));
        };
        this.restartCanvasTracking = () => {
            if (this.app === null) {
                return;
            }
            this.app.restartCanvasTracking();
        };
        this.handleError = (e, metadata = {}) => {
            if (this.app === null) {
                return;
            }
            if (e instanceof Error) {
                const msg = getExceptionMessage(e, [], metadata);
                this.app.send(msg);
            }
            else if (e instanceof ErrorEvent ||
                ('PromiseRejectionEvent' in window && e instanceof PromiseRejectionEvent)) {
                const msg = getExceptionMessageFromEvent(e, undefined, metadata);
                if (msg != null) {
                    this.app.send(msg);
                }
            }
        };
        this.crossdomainMode = Boolean(inIframe() && options.crossdomain?.enabled);
        if (!IN_BROWSER || !processOptions(options)) {
            return;
        }
        if (window.__OPENREPLAY__ ||
            (!this.crossdomainMode && inIframe() && canAccessTop() && window.top.__OPENREPLAY__)) {
            console.error('OpenReplay: one tracker instance has been initialised already');
            return;
        }
        if (!options.__DISABLE_SECURE_MODE && location.protocol !== 'https:') {
            console.error('OpenReplay: Your website must be publicly accessible and running on SSL in order for OpenReplay to properly capture and replay the user session. You can disable this check by setting `__DISABLE_SECURE_MODE` option to `true` if you are testing in localhost. Keep in mind, that asset files on a local machine are not available to the outside world. This might affect tracking if you use css files.');
            return;
        }
        const doNotTrack = this.checkDoNotTrack();
        const failReason = [];
        const conditions = [
            'Map',
            'Set',
            'MutationObserver',
            'performance',
            'timing',
            'startsWith',
            'Blob',
            'Worker',
        ];
        if (doNotTrack) {
            failReason.push('doNotTrack');
        }
        else {
            for (const condition of conditions) {
                if (condition === 'timing') {
                    if ('performance' in window && !(condition in performance)) {
                        failReason.push(condition);
                        break;
                    }
                }
                else if (condition === 'startsWith') {
                    if (!(condition in String.prototype)) {
                        failReason.push(condition);
                        break;
                    }
                }
                else {
                    if (!(condition in window)) {
                        failReason.push(condition);
                        break;
                    }
                }
            }
        }
        if (failReason.length > 0) {
            const missingApi = failReason.join(',');
            console.error(`OpenReplay: browser doesn't support API required for tracking or doNotTrack is set to 1. Reason: ${missingApi}`);
            this.signalStartIssue('missing_api', failReason);
            return;
        }
        const app = new App(options.projectKey, options.sessionToken, options, this.signalStartIssue, this.crossdomainMode);
        this.app = app;
        if (!this.crossdomainMode) {
            // no need to send iframe viewport data since its a node for us
            Viewport(app);
            // calculated in main window
            Connection(app);
            // while we can calculate it here, trying to compute it for all parts is hard
            Performance(app, options);
            // no tabs in iframes yet
            Tabs(app);
        }
        Mouse(app, options.mouse);
        // inside iframe, we ignore viewport scroll
        Scroll(app, this.crossdomainMode);
        CSSRules(app);
        ConstructedStyleSheets(app);
        Console(app, options);
        Exception(app, options);
        Img(app);
        Input(app, options);
        Timing(app, options);
        Focus(app);
        Fonts(app);
        const skipNetwork = options.network?.disabled;
        if (!skipNetwork) {
            Network(app, options.network);
        }
        selection(app);
        window.__OPENREPLAY__ = this;
        if (options.flags && options.flags.onFlagsLoad) {
            this.onFlagsLoad(options.flags.onFlagsLoad);
        }
        const wOpen = window.open;
        if (options.autoResetOnWindowOpen || options.resetTabOnWindowOpen) {
            app.attachStartCallback(() => {
                const tabId = app.getTabId();
                const sessStorage = app.sessionStorage ?? window.sessionStorage;
                window.open = function (...args) {
                    if (options.autoResetOnWindowOpen) {
                        app.resetNextPageSession(true);
                    }
                    if (options.resetTabOnWindowOpen) {
                        sessStorage.removeItem(options.session_tabid_key || '__openreplay_tabid');
                    }
                    app.resetNextPageSession(false);
                    sessStorage.setItem(options.session_tabid_key || '__openreplay_tabid', tabId);
                    return wOpen.call(window, ...args);
                };
            });
            app.attachStopCallback(() => {
                window.open = wOpen;
            });
        }
    }
    isFlagEnabled(flagName) {
        return this.featureFlags.isFlagEnabled(flagName);
    }
    onFlagsLoad(callback) {
        this.app?.featureFlags.onFlagsLoad(callback);
    }
    clearPersistFlags() {
        this.app?.featureFlags.clearPersistFlags();
    }
    reloadFlags() {
        return this.app?.featureFlags.reloadFlags();
    }
    getFeatureFlag(flagName) {
        return this.app?.featureFlags.getFeatureFlag(flagName);
    }
    getAllFeatureFlags() {
        return this.app?.featureFlags.flags;
    }
    use(fn) {
        return fn(this.app, this.options);
    }
    isActive() {
        if (this.app === null) {
            return false;
        }
        return this.app.active();
    }
    /**
     * Creates a named hook that expects event name, data string and msg direction (up/down),
     * it will skip any message bigger than 5 mb or event name bigger than 255 symbols
     * msg direction is "down" (incoming) by default
     *
     * @returns {(msgType: string, data: string, dir: 'up' | 'down') => void}
     * */
    trackWs(channelName) {
        if (this.app === null) {
            return;
        }
        return this.app.trackWs(channelName);
    }
    start(startOpts) {
        if (this.browserEnvCheck()) {
            if (this.app === null) {
                return Promise.reject("Browser doesn't support required api, or doNotTrack is active.");
            }
            return this.app.start(startOpts);
        }
        else {
            return Promise.reject('Trying to start not in browser.');
        }
    }
    browserEnvCheck() {
        if (!IN_BROWSER) {
            console.error(`OpenReplay: you are trying to start Tracker on a node.js environment. If you want to use OpenReplay with SSR, please, use componentDidMount or useEffect API for placing the \`tracker.start()\` line. Check documentation on ${DOCS_HOST}${DOCS_SETUP}`);
            return false;
        }
        return true;
    }
    /**
     * start buffering messages without starting the actual session, which gives user 30 seconds to "activate" and record
     * session by calling start() on conditional trigger and we will then send buffered batch, so it won't get lost
     * */
    coldStart(startOpts, conditional) {
        if (this.browserEnvCheck()) {
            if (this.app === null) {
                return Promise.reject('Tracker not initialized');
            }
            void this.app.coldStart(startOpts, conditional);
        }
        else {
            return Promise.reject('Trying to start not in browser.');
        }
    }
    /**
     * Starts offline session recording. Keep in mind that only user device time will be used for timestamps.
     * (no backend delay sync)
     *
     * @param {Object} startOpts - options for session start, same as .start()
     * @param {Function} onSessionSent - callback that will be called once session is fully sent
     * @returns methods to manipulate buffer:
     *
     * saveBuffer - to save it in localStorage
     *
     * getBuffer - returns current buffer
     *
     * setBuffer - replaces current buffer with given
     * */
    startOfflineRecording(startOpts, onSessionSent) {
        if (this.browserEnvCheck()) {
            if (this.app === null) {
                return Promise.reject('Tracker not initialized');
            }
            return this.app.offlineRecording(startOpts, onSessionSent);
        }
        else {
            return Promise.reject('Trying to start not in browser.');
        }
    }
    /**
     * Uploads the stored session buffer to backend
     * @returns promise that resolves once messages are loaded, it has to be awaited
     * so the session can be uploaded properly
     * @resolve - if messages were loaded into service worker successfully
     * @reject {string} - error message
     * */
    uploadOfflineRecording() {
        if (this.app === null) {
            return;
        }
        return this.app.uploadOfflineRecording();
    }
    stop() {
        if (this.app === null) {
            return;
        }
        this.app.stop();
        return this.app.session.getSessionHash();
    }
    forceFlushBatch() {
        if (this.app === null) {
            return;
        }
        this.app.forceFlushBatch();
    }
    getSessionToken() {
        if (this.app === null) {
            return null;
        }
        return this.app.getSessionToken();
    }
    getSessionInfo() {
        if (this.app === null) {
            return null;
        }
        return this.app.session.getInfo();
    }
    getSessionID() {
        if (this.app === null) {
            return null;
        }
        return this.app.getSessionID();
    }
    getTabId() {
        if (this.app === null) {
            return null;
        }
        return this.app.getTabId();
    }
    getUxId() {
        if (this.app === null) {
            return null;
        }
        return this.app.getUxtId();
    }
    sessionID() {
        deprecationWarn("'sessionID' method", "'getSessionID' method", '/');
        return this.getSessionID();
    }
    getSessionURL(options) {
        if (this.app === null) {
            return undefined;
        }
        return this.app.getSessionURL(options);
    }
    setUserID(id) {
        if (typeof id === 'string' && this.app !== null) {
            this.app.session.setUserID(id);
        }
    }
    userID(id) {
        deprecationWarn("'userID' method", "'setUserID' method", '/');
        this.setUserID(id);
    }
    setUserAnonymousID(id) {
        if (typeof id === 'string' && this.app !== null) {
            this.app.send(UserAnonymousID(id));
        }
    }
    userAnonymousID(id) {
        deprecationWarn("'userAnonymousID' method", "'setUserAnonymousID' method", '/');
        this.setUserAnonymousID(id);
    }
    setMetadata(key, value) {
        if (typeof key === 'string' && typeof value === 'string' && this.app !== null) {
            this.app.session.setMetadata(key, value);
        }
    }
    metadata(key, value) {
        deprecationWarn("'metadata' method", "'setMetadata' method", '/');
        this.setMetadata(key, value);
    }
    event(key, payload = null, issue = false) {
        if (typeof key === 'string' && this.app !== null) {
            if (issue) {
                return this.issue(key, payload);
            }
            else {
                try {
                    payload = JSON.stringify(payload);
                }
                catch (e) {
                    return;
                }
                this.app.send(CustomEvent(key, payload));
            }
        }
    }
    issue(key, payload = null) {
        if (typeof key === 'string' && this.app !== null) {
            try {
                payload = JSON.stringify(payload);
            }
            catch (e) {
                return;
            }
            this.app.send(CustomIssue(key, payload));
        }
    }
}

exports.App = App;
exports.Messages = Messages;
exports.default = API;
//# sourceMappingURL=index.js.map
