import Tracker, { App, Options } from './index.js';
import type { StartOptions, StartPromiseReturn } from './app/index.js';
declare class TrackerSingleton {
    private instance;
    private isConfigured;
    /**
     * Call this method once to create tracker configuration
     * @param options {Object} Check available options:
     * https://docs.openreplay.com/en/sdk/constructor/#initialization-options
     */
    configure(options: Partial<Options>): void;
    get options(): Partial<Options> | null;
    start(startOpts?: Partial<StartOptions>): Promise<StartPromiseReturn>;
    /**
     * Stop the session and return sessionHash
     * (which can be used to stitch sessions together)
     * */
    stop(): string | undefined;
    setUserID(id: string): void;
    /**
     * Set metadata for the current session
     *
     * Make sure that its configured in project settings first
     *
     * Read more: https://docs.openreplay.com/en/installation/metadata/
     */
    setMetadata(key: string, value: string): void;
    /**
     * Returns full URL for the current session
     */
    getSessionURL(options?: {
        withCurrentTime?: boolean;
    }): string | undefined;
    getSessionID(): string | null | undefined;
    getSessionToken(): string | null | undefined;
    event(key: string, payload?: any, issue?: boolean): void;
    issue(key: string, payload?: any): void;
    handleError(e: Error | ErrorEvent | PromiseRejectionEvent, metadata?: Record<string, any>): void;
    isFlagEnabled(flagName: string): boolean;
    onFlagsLoad(...args: Parameters<Tracker['onFlagsLoad']>): void;
    clearPersistFlags(): void;
    reloadFlags(): Promise<void> | undefined;
    getFeatureFlag(flagName: string): import("./modules/featureFlags.js").IFeatureFlag | undefined;
    getAllFeatureFlags(): import("./modules/featureFlags.js").IFeatureFlag[] | undefined;
    restartCanvasTracking(): void;
    /**
     * Set the anonymous user ID
     */
    setUserAnonymousID(id: string): void;
    /**
     * Check if the tracker is active
     */
    isActive(): boolean;
    /**
     * Get the underlying Tracker instance
     *
     * Use when you need access to methods not exposed by the singleton
     */
    getInstance(): Tracker | null;
    /**
     * start buffering messages without starting the actual session, which gives user 30 seconds to "activate" and record
     * session by calling start() on conditional trigger and we will then send buffered batch, so it won't get lost
     * */
    coldStart(startOpts?: Partial<StartOptions>, conditional?: boolean): Promise<never> | undefined;
    /**
     * Creates a named hook that expects event name, data string and msg direction (up/down),
     * it will skip any message bigger than 5 mb or event name bigger than 255 symbols
     * msg direction is "down" (incoming) by default
     *
     * @returns {(msgType: string, data: string, dir: 'up' | 'down') => void}
     * */
    trackWs(channelName: string): ((msgType: string, data: string, dir: 'up' | 'down') => void) | undefined;
    private ensureConfigured;
    use<T>(fn: (app: App | null, options?: Partial<Options>) => T): T;
    /**
     * Starts offline session recording. Keep in mind that only user device time will be used for timestamps.
     * (no backend delay sync)
     *
     * @param {Object} startOpts - options for session start, same as .start()
     * @param {Function} onSessionSent - callback that will be called once session is fully sent
     * @returns methods to manipulate buffer:
     *
     * saveBuffer - to save it in localStorage
     *
     * getBuffer - returns current buffer
     *
     * setBuffer - replaces current buffer with given
     * */
    startOfflineRecording(...args: Parameters<Tracker['startOfflineRecording']>): Promise<never> | {
        saveBuffer: () => void;
        getBuffer: () => import("./app/messages.gen.js").default[];
        setBuffer: (buffer: import("./app/messages.gen.js").default[]) => void;
    } | undefined;
    /**
     * Uploads the stored session buffer to backend
     * @returns promise that resolves once messages are loaded, it has to be awaited
     * so the session can be uploaded properly
     * @resolve - if messages were loaded into service worker successfully
     * @reject {string} - error message
     * */
    uploadOfflineRecording(): Promise<void> | undefined;
    forceFlushBatch(): void;
    getSessionInfo(): import("./app/session.js").SessionInfo | null;
    getTabId(): string | null;
    getUxId(): number | null;
}
declare const tracker: TrackerSingleton;
export default tracker;
